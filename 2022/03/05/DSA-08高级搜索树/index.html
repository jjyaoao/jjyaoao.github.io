<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>高级搜索树 | jjyaoao's Home</title><meta name="keywords" content="DSA-08"><meta name="author" content="jjyaoao,jjyaoao@126.com"><meta name="copyright" content="jjyaoao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DSA第八章">
<meta property="og:type" content="article">
<meta property="og:title" content="高级搜索树">
<meta property="og:url" content="http://jjyaoao.space/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/index.html">
<meta property="og:site_name" content="jjyaoao&#39;s Home">
<meta property="og:description" content="DSA第八章">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/03/05/TOfhyZxuDSe6BkR.png">
<meta property="article:published_time" content="2022-03-05T08:43:36.000Z">
<meta property="article:modified_time" content="2022-03-06T03:09:22.203Z">
<meta property="article:author" content="jjyaoao">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="思维过程">
<meta property="article:tag" content="实战代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/03/05/TOfhyZxuDSe6BkR.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/01/09/le6jcmPKuJihDdU.jpg"><link rel="canonical" href="http://jjyaoao.space/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?06fb7a80772d98cbf9e7beeb76e262e4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JOZPQM4N5F","apiKey":"42451c032f2166ed9800520810e2d223","indexName":"jjyaoao-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高级搜索树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-06 11:09:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/01/09/le6jcmPKuJihDdU.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/03/05/TOfhyZxuDSe6BkR.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">jjyaoao's Home</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">高级搜索树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-05T08:43:36.000Z" title="发表于 2022-03-05 16:43:36">2022-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-06T03:09:22.203Z" title="更新于 2022-03-06 11:09:22">2022-03-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/">DSA-08高级搜索树</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="高级搜索树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>以下笔记为jjyaoao本人制作，欢迎借鉴学习和提出相关建议，转载需要标明出处<a target="_blank" rel="noopener" href="http://www.jjyaoao.space/">www.jjyaoao.space</a></p>
</blockquote>
<h1 id="伸展树-Splay-Tree"><a href="#伸展树-Splay-Tree" class="headerlink" title="伸展树(Splay Tree)"></a>伸展树(Splay Tree)</h1><p>​        虽然对于标准平衡树而言，AVL已经在条件上略有放松，但是这种平衡任然显得过于苛刻，就像一个小心谨慎走路的人，那么我们能否走的更潇洒一点呢？</p>
<p>​        也就是说，我们可否秉持一种更为宽泛的准则，并且从长远来看仍然不失一定的稳定性呢？</p>
<h2 id="逐层伸展"><a href="#逐层伸展" class="headerlink" title="逐层伸展"></a>逐层伸展</h2><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305181931446.png" alt="image-20220305181931446"></p>
<h3 id="自适应调整"><a href="#自适应调整" class="headerlink" title="自适应调整"></a>自适应调整</h3><p>使刚被访问的节点往上走</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305182241903.png" alt="image-20220305182241903"></p>
<h3 id="逐层伸展-1"><a href="#逐层伸展-1" class="headerlink" title="逐层伸展"></a>逐层伸展</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305182426063.png" alt="image-20220305182426063"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们通过观察这个实例，发现这个过程是一个左右摇摆，逐渐伸展的过程</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305182504288.png" alt="image-20220305182504288"></p>
<p>​        所以我们也称这个过程叫伸展，Splay</p>
<p>​        然而就效率而言，这并<strong>不是最佳</strong>的选择，原因在于，他有<strong>最坏情况</strong></p>
<h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305182929970.png" alt="image-20220305182929970"></p>
<p>​        </p>
<p>​        这也并不是令我们满意的，甚至离logn都相距甚远</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305183213889.png" alt="image-20220305183213889"></p>
<p>​        不过好消息是，造成这一结果并不是伸展本身，而是我们伸展的方式，就好比画龙点睛，作为一条龙，目前的伸展策略已经相当完备，它所缺少的只是体现其灵魂的一只眼睛，没错，不是一双眼睛，<strong>仅仅是一只</strong></p>
<h2 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h2><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305183405993.png" alt="image-20220305183405993"></p>
<h3 id="子孙异侧"><a href="#子孙异侧" class="headerlink" title="子孙异侧"></a>子孙异侧</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305183450456.png" alt="image-20220305183450456"></p>
<p>如果能发现这两个策略，那其实是非常好的，因为这就是那条龙的一只眼睛，真正有差别的在于另一只眼睛….</p>
<h3 id="子孙同侧"><a href="#子孙同侧" class="headerlink" title="子孙同侧"></a>子孙同侧</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305183820195.png" alt="image-20220305183820195"></p>
<p>的确不易察觉，更重要的是，这种局部的微妙差异将导致全局的不同，这种不同将是根本性的，颠覆性的。</p>
<h3 id="点睛之笔"><a href="#点睛之笔" class="headerlink" title="点睛之笔"></a>点睛之笔</h3><p>第一次调整以后，它拥有了新的祖父和父亲（5，4）</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305184028793.png" alt="image-20220305184028793"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305184140248.png" alt="image-20220305184140248"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305184149207.png" alt="image-20220305184149207"></p>
<p><strong>每调整一次，树的高度都将缩减一半</strong></p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305183959934.png" alt="image-20220305183959934"></p>
<p>因此，我们不仅能处理之前那种最坏情况，还能面队其他的最坏情况，这是再好不过的消息了</p>
<h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305184539482.png" alt="image-20220305184539482"></p>
<p>我们说这个情况并不严重，我们只需要在最后做一次左旋或者右旋就好，那么，这种策略又当如何具体实现呢？</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305184658491.png" alt="image-20220305184658491"></p>
<p>在这里，除了重写插入和删除，search（）也需要重写，即便是查找操作，也会引起全树的拓扑结构变换，我们马上就可以知道，这种变换是举足轻重的。</p>
<p>这个search的实质功能无非是完成伸展，我们这也提供了一个splay的保护接口用以实现这个功能</p>
<h3 id="伸展算法"><a href="#伸展算法" class="headerlink" title="伸展算法"></a>伸展算法</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305185239427.png" alt="image-20220305185239427"></p>
<h4 id="zIg-zIg示范"><a href="#zIg-zIg示范" class="headerlink" title="zIg-zIg示范"></a>zIg-zIg示范</h4><p>右旋-右旋</p>
<p>第一句将p的右孩子当作g的左孩子</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305185549543.png" alt="image-20220305185549543"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*lc（可能为空）之间建立父（左）子关系</span></span><br><span class="line"><span class="number">0002</span> <span class="function"><span class="keyword">void</span> <span class="title">attachAsLC</span> <span class="params">( NodePosi lc, NodePosi p )</span> </span>&#123; p-&gt;lc = lc; <span class="keyword">if</span> ( lc ) lc-&gt;parent = p; &#125;</span><br><span class="line"><span class="number">0003</span> </span><br><span class="line"><span class="number">0004</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*rc（可能为空）之间建立父（右）子关系</span></span><br><span class="line"><span class="number">0005</span> <span class="function"><span class="keyword">void</span> <span class="title">attachAsRC</span> <span class="params">( NodePosi p, NodePosi rc )</span> </span>&#123; p-&gt;rc = rc; <span class="keyword">if</span> ( rc ) rc-&gt;parent = p; &#125;</span><br><span class="line"><span class="number">0006</span> </span><br><span class="line"><span class="number">0007</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//Splay树伸展算法：从节点v出发逐层伸展</span></span><br><span class="line"><span class="number">0008</span> BinNodePosi&lt;T&gt; Splay&lt;T&gt;::<span class="built_in">splay</span> ( BinNodePosi&lt;T&gt; v ) &#123; <span class="comment">//v为因最近访问而需伸展的节点位置</span></span><br><span class="line"><span class="number">0009</span>    <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">NULL</span>; BinNodePosi&lt;T&gt; p; BinNodePosi&lt;T&gt; g; <span class="comment">//*v的父亲与祖父</span></span><br><span class="line"><span class="number">0010</span>    <span class="keyword">while</span> ( ( p = v-&gt;parent ) &amp;&amp; ( g = p-&gt;parent ) ) &#123; <span class="comment">//自下而上，反复对*v做双层伸展</span></span><br><span class="line"><span class="number">0011</span>       BinNodePosi&lt;T&gt; gg = g-&gt;parent; <span class="comment">//每轮之后*v都以原曾祖父（great-grand parent）为父</span></span><br><span class="line"><span class="number">0012</span>       <span class="keyword">if</span> ( <span class="built_in">IsLChild</span> ( *v ) )</span><br><span class="line"><span class="number">0013</span>          <span class="keyword">if</span> ( <span class="built_in">IsLChild</span> ( *p ) ) &#123; <span class="comment">//zig-zig</span></span><br><span class="line"><span class="number">0014</span>             <span class="built_in">attachAsLC</span> ( p-&gt;rc, g ); <span class="built_in">attachAsLC</span> ( v-&gt;rc, p );</span><br><span class="line"><span class="number">0015</span>             <span class="built_in">attachAsRC</span> ( p, g ); <span class="built_in">attachAsRC</span> ( v, p );</span><br><span class="line"><span class="number">0016</span>          &#125; <span class="keyword">else</span> &#123; <span class="comment">//zig-zag</span></span><br><span class="line"><span class="number">0017</span>             <span class="built_in">attachAsLC</span> ( v-&gt;rc, p ); <span class="built_in">attachAsRC</span> ( g, v-&gt;lc );</span><br><span class="line"><span class="number">0018</span>             <span class="built_in">attachAsLC</span> ( g, v ); <span class="built_in">attachAsRC</span> ( v, p );</span><br><span class="line"><span class="number">0019</span>          &#125;</span><br><span class="line"><span class="number">0020</span>       <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">IsRChild</span> ( *p ) ) &#123; <span class="comment">//zag-zag</span></span><br><span class="line"><span class="number">0021</span>          <span class="built_in">attachAsRC</span> ( g, p-&gt;lc ); <span class="built_in">attachAsRC</span> ( p, v-&gt;lc );</span><br><span class="line"><span class="number">0022</span>          <span class="built_in">attachAsLC</span> ( g, p ); <span class="built_in">attachAsLC</span> ( p, v );</span><br><span class="line"><span class="number">0023</span>       &#125; <span class="keyword">else</span> &#123; <span class="comment">//zag-zig</span></span><br><span class="line"><span class="number">0024</span>          <span class="built_in">attachAsRC</span> ( p, v-&gt;lc ); <span class="built_in">attachAsLC</span> ( v-&gt;rc, g );</span><br><span class="line"><span class="number">0025</span>          <span class="built_in">attachAsRC</span> ( v, g ); <span class="built_in">attachAsLC</span> ( p, v );</span><br><span class="line"><span class="number">0026</span>       &#125;</span><br><span class="line"><span class="number">0027</span>       <span class="keyword">if</span> ( !gg ) v-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//若*v原先的曾祖父*gg不存在，则*v现在应为树根</span></span><br><span class="line"><span class="number">0028</span>       <span class="keyword">else</span> <span class="comment">//否则，*gg此后应该以*v作为左或右孩子</span></span><br><span class="line"><span class="number">0029</span>          ( g == gg-&gt;lc ) ? <span class="built_in">attachAsLC</span> ( v, gg ) : <span class="built_in">attachAsRC</span> ( gg, v );</span><br><span class="line"><span class="number">0030</span>       <span class="built_in">updateHeight</span> ( g ); <span class="built_in">updateHeight</span> ( p ); <span class="built_in">updateHeight</span> ( v );</span><br><span class="line"><span class="number">0031</span>    &#125; <span class="comment">//双层伸展结束时，必有g == NULL，但p可能非空</span></span><br><span class="line"><span class="number">0032</span>    <span class="keyword">if</span> ( p = v-&gt;parent ) &#123; <span class="comment">//若p果真非空，则额外再做一次单旋</span></span><br><span class="line"><span class="number">0033</span>       <span class="keyword">if</span> ( <span class="built_in">IsLChild</span> ( *v ) ) &#123; <span class="built_in">attachAsLC</span> ( v-&gt;rc, p ); <span class="built_in">attachAsRC</span> ( v, p ); &#125;</span><br><span class="line"><span class="number">0034</span>       <span class="keyword">else</span>                   &#123; <span class="built_in">attachAsRC</span> ( p, v-&gt;lc ); <span class="built_in">attachAsLC</span> ( p, v ); &#125;</span><br><span class="line"><span class="number">0035</span>       <span class="built_in">updateHeight</span> ( p ); <span class="built_in">updateHeight</span> ( v );</span><br><span class="line"><span class="number">0036</span>    &#125;</span><br><span class="line"><span class="number">0037</span>    v-&gt;parent = <span class="literal">NULL</span>; <span class="keyword">return</span> v;</span><br><span class="line"><span class="number">0038</span> &#125; <span class="comment">//调整之后新树根应为被伸展的节点，故返回该节点的位置以便上层函数更新树根</span></span><br></pre></td></tr></table></figure>

<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305185956698.png" alt="image-20220305185956698"></p>
<h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305190201430.png" alt="image-20220305190201430"></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; Splay&lt;T&gt;::<span class="built_in">insert</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入伸展树中</span></span><br><span class="line"><span class="number">0002</span>    <span class="keyword">if</span> ( !_root ) &#123; _size = <span class="number">1</span>; <span class="keyword">return</span> _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e ); &#125; <span class="comment">//原树为空</span></span><br><span class="line"><span class="number">0003</span>    BinNodePosi&lt;T&gt; t = <span class="built_in">search</span>( e ); <span class="keyword">if</span> ( e == t-&gt;data ) <span class="keyword">return</span> t; <span class="comment">//目标节点t若存在，伸展至根</span></span><br><span class="line"><span class="number">0004</span>    <span class="keyword">if</span> ( t-&gt;data &lt; e ) &#123; <span class="comment">//在右侧嫁接</span></span><br><span class="line"><span class="number">0005</span>       t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t, t-&gt;rc ); <span class="comment">//lc == t必非空</span></span><br><span class="line"><span class="number">0006</span>       <span class="keyword">if</span> ( t-&gt;rc ) &#123; t-&gt;rc-&gt;parent = _root; t-&gt;rc = <span class="literal">NULL</span>; &#125; <span class="comment">//rc或为空</span></span><br><span class="line"><span class="number">0007</span>    &#125; <span class="keyword">else</span> &#123; <span class="comment">//在左侧嫁接</span></span><br><span class="line"><span class="number">0008</span>       t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t-&gt;lc, t ); <span class="comment">//rc == t必非空</span></span><br><span class="line"><span class="number">0009</span>       <span class="keyword">if</span> ( t-&gt;lc ) &#123; t-&gt;lc-&gt;parent = _root; t-&gt;lc = <span class="literal">NULL</span>; &#125; <span class="comment">//lc或为空</span></span><br><span class="line"><span class="number">0010</span>    &#125;</span><br><span class="line"><span class="number">0011</span>    _size++; <span class="built_in">updateHeightAbove</span> ( t ); <span class="keyword">return</span> _root; <span class="comment">//更新规模及高度，报告插入成功</span></span><br><span class="line"><span class="number">0012</span> &#125; <span class="comment">//无论e是否存在于原树中，返回时总有_root-&gt;data == e</span></span><br></pre></td></tr></table></figure>

<h3 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305190335409.png" alt="image-20220305190335409"></p>
<p>找右子树最小来代替当树根，如果忘记了去看中序遍历迭代板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Splay&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从伸展树中删除关键码e</span></span><br><span class="line"><span class="number">0002</span>    <span class="keyword">if</span> ( !_root || ( e != <span class="built_in">search</span> ( e )-&gt;data ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若目标存在，则伸展至根</span></span><br><span class="line"><span class="number">0003</span>    BinNodePosi&lt;T&gt; L = _root-&gt;lc, R = _root-&gt;rc; <span class="built_in">release</span>(_root); <span class="comment">//记下左、右子树L、R后，释放之</span></span><br><span class="line"><span class="number">0004</span>    <span class="keyword">if</span> ( !R ) &#123; <span class="comment">//若R空，则</span></span><br><span class="line"><span class="number">0005</span>       <span class="keyword">if</span> ( L ) L-&gt;parent = <span class="literal">NULL</span>; _root = L; <span class="comment">//L即是余树</span></span><br><span class="line"><span class="number">0006</span>    &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line"><span class="number">0007</span>       _root = R; R-&gt;parent = <span class="literal">NULL</span>; <span class="built_in">search</span>( e ); <span class="comment">//在R中再次查找e：注定失败，但其中的最小节点必</span></span><br><span class="line"><span class="number">0008</span>       <span class="keyword">if</span> (L) L-&gt;parent = _root; _root-&gt;lc = L; <span class="comment">//伸展至根（且无左孩子），故可令其以L作为左子树</span></span><br><span class="line"><span class="number">0009</span>    &#125;</span><br><span class="line"><span class="number">0010</span>    <span class="keyword">if</span> ( --_size ) <span class="built_in">updateHeight</span> ( _root ); <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//更新规模及树高，报告删除成功</span></span><br><span class="line"><span class="number">0011</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305190616815.png" alt="image-20220305190616815"></p>
<p>我们仍然无法避免，必须要走n次才能找到点的最坏情况</p>
<p>效率敏感：手术室里辅助的机器</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B(-)树"></a>B(-)树</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我花了O(325+10000*4)s的时间看完了本节视频，没想到看如此大的视频竟然在渐进意义下O(1)时间完成了（bushi</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305190852650.png" alt="image-20220305190852650"></p>
<h3 id="越来越大的数据"><a href="#越来越大的数据" class="headerlink" title="越来越大的数据"></a>越来越大的数据</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305191005822.png" alt="image-20220305191005822"></p>
<h3 id="越来越小的内存"><a href="#越来越小的内存" class="headerlink" title="越来越小的内存"></a>越来越小的内存</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305191024601.png" alt="image-20220305191024601"></p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305191055641.png" alt="image-20220305191055641"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305191121708.png" alt="image-20220305191121708"></p>
<h3 id="多路平衡"><a href="#多路平衡" class="headerlink" title="多路平衡"></a>多路平衡</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305191638337.png" alt="image-20220305191638337"></p>
<p>​        我们忽略掉方框，看右上面那个，毫无疑问就是一颗二叉搜索树，现在我们两层两层的来考察每一个节点，也就是它和左右孩子，如果将每一层的父子<strong>三个节点合并成一个超级节点</strong>，整棵树就可以等价变换成下面那样</p>
<p>​        我们的确可以把他称为超级节点，因为它其中并不含有一个关键码，而是多个，就这个例子而言，每个超级节点都含有三个关键码，并且对应有四个分支，推而广之，我们可以合并三代，使得含有七个关键码和八个分支，一般的，如果每D代都进行一次合并，那么每次超级节点都具有m = 2^d分支，和m-1个关键码</p>
<p>​        与我们此前的二路搜索树并没有本质的区别，那么为什么我们还要引入二路搜索树呢？这是我们需要回答的问题</p>
<h3 id="还是I-O"><a href="#还是I-O" class="headerlink" title="还是I/O"></a>还是I/O</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305192426003.png" alt="image-20220305192426003"></p>
<p>树的高度，即为io次数，（每下降一层，一次io）</p>
<p>我们可能会想，这样的改进，不也是常数意义的提升吗，可如果常数的单位巨大，那我们就不得不斤斤计较了。</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305192508105.png" alt="image-20220305192508105"></p>
<h3 id="深度统一"><a href="#深度统一" class="headerlink" title="深度统一"></a>深度统一</h3><p>于其他树不同，B树的高度是相对于外部节点，而不是叶节点的</p>
<p>外部节点：数值为0，叶节点其实不存在的孩子….</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305192833379.png" alt="image-20220305192833379"></p>
<h3 id="阶次含义"><a href="#阶次含义" class="headerlink" title="阶次含义"></a>阶次含义</h3><p>这里定义，以n来代表所含关键码数，也就是对应了n+1个分支</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305193140056.png" alt="image-20220305193140056"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305193202144.png" alt="image-20220305193202144"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305193635748.png" alt="image-20220305193635748"></p>
<h3 id="紧凑表示"><a href="#紧凑表示" class="headerlink" title="紧凑表示"></a>紧凑表示</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305193351967.png" alt="image-20220305193351967"></p>
<p>讲授过程中将采用c的方式，节约版面，但是实际上，B树的确存在这么多外部节点，和这么多个引用，不要被误导了！</p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305200438802.png" alt="image-20220305200438802"></p>
<h2 id="M阶"><a href="#M阶" class="headerlink" title="M阶"></a>M阶</h2><p><strong>定义：</strong><br><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/20190826094017537.png" alt="在这里插入图片描述"></p>
<p>描述一颗 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=B%E6%A0%91&spm=1001.2101.3001.7020">B树</a>时，需要指定它的阶数，什么是 <strong>阶数</strong> ？</p>
<p><strong>阶数</strong> 表示 此树的节点 <strong>最多</strong> 有<strong>多少个孩子结点（子树）</strong>，一般用字母 M 表示阶数。</p>
<p>M 阶的B树 ：以【子树】讨论</p>
<ul>
<li>上限：每个节点 <strong>最多</strong> 有 M 个子树 ；</li>
<li>下限：<ul>
<li>根节点至少2个子树，</li>
<li>非根节点至少有 ⌈M /2⌉ 个子树 。<em>（M /2 向上取整，如 5/2等于3）</em></li>
</ul>
</li>
</ul>
<p>所以也称 M 阶的 B树 为 ( ⌈M /2⌉ , M ) 树 ，即超级节点（除根节点）的子树数的上下限 。</p>
<p>另外，关键字（码）的个数 = 节点子树数 - 1 。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M = <span class="number">4</span> 阶的B树，子树个数是（<span class="number">2</span>, <span class="number">4</span>）， 最多含有 <span class="number">3</span>个关键字 和 <span class="number">4</span>个子树</span><br><span class="line">M = <span class="number">5</span> 阶    ，          （<span class="number">3</span>, <span class="number">5</span>）， 最多含有 <span class="number">4</span>个关键字 和 <span class="number">5</span>个子树</span><br><span class="line">M = <span class="number">6</span> 阶    ，          （<span class="number">3</span>, <span class="number">6</span>）， 最多含有 <span class="number">5</span>个关键字 和 <span class="number">6</span>个子树</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>总结，<strong>M阶 可理解为 M树，即内含（M-1）个关键字 和 M 个子树。</strong></p>
<h2 id="ADT-1"><a href="#ADT-1" class="headerlink" title="ADT"></a>ADT</h2><h3 id="BTNode"><a href="#BTNode" class="headerlink" title="BTNode"></a>BTNode</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305193725903.png" alt="image-20220305193725903"></p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vector/vector.h&quot;</span></span></span><br><span class="line"><span class="number">0002</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>;</span></span><br><span class="line"><span class="number">0003</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> BTNodePosi = BTNode&lt;T&gt;*; <span class="comment">//B-树节点位置</span></span><br><span class="line"><span class="number">0004</span> </span><br><span class="line"><span class="number">0005</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span> <span class="comment">//B-树节点模板类</span></span><br><span class="line"><span class="number">0006</span> <span class="comment">// 成员（为简化描述起见统一开放，读者可根据需要进一步封装）</span></span><br><span class="line"><span class="number">0007</span>    BTNodePosi&lt;T&gt; parent; <span class="comment">//父节点</span></span><br><span class="line"><span class="number">0008</span>    Vector&lt;T&gt; key; <span class="comment">//关键码向量</span></span><br><span class="line"><span class="number">0009</span>    Vector&lt;BTNodePosi&lt;T&gt;&gt; child; <span class="comment">//孩子向量（总比关键码多一个）</span></span><br><span class="line"><span class="number">0010</span> <span class="comment">// 构造函数</span></span><br><span class="line"><span class="number">0011</span>    <span class="built_in">BTNode</span>() &#123; parent = <span class="literal">NULL</span>; child.<span class="built_in">insert</span> ( <span class="literal">NULL</span> ); &#125; <span class="comment">//无关键码节点</span></span><br><span class="line"><span class="number">0012</span>    <span class="built_in">BTNode</span> ( T e, BTNodePosi&lt;T&gt; lc = <span class="literal">NULL</span>, BTNodePosi&lt;T&gt; rc = <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="number">0013</span>       parent = <span class="literal">NULL</span>; key.<span class="built_in">insert</span> ( e ); <span class="comment">//作为根节点只有一个关键码，以及</span></span><br><span class="line"><span class="number">0014</span>       child.<span class="built_in">insert</span> ( lc ); <span class="keyword">if</span> ( lc ) lc-&gt;parent = <span class="keyword">this</span>; <span class="comment">//左孩子</span></span><br><span class="line"><span class="number">0015</span>       child.<span class="built_in">insert</span> ( rc ); <span class="keyword">if</span> ( rc ) rc-&gt;parent = <span class="keyword">this</span>; <span class="comment">//右孩子</span></span><br><span class="line"><span class="number">0016</span>    &#125;</span><br><span class="line"><span class="number">0017</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305193837639.png" alt="image-20220305193837639"></p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BTNode.h&quot;</span> <span class="comment">//引入B-树节点类</span></span></span><br><span class="line"><span class="number">0002</span> </span><br><span class="line"><span class="number">0003</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span> <span class="comment">//B-树模板类</span></span><br><span class="line"><span class="number">0004</span> <span class="keyword">protected</span>:</span><br><span class="line"><span class="number">0005</span>    <span class="keyword">int</span> _size; <span class="comment">//存放的关键码总数</span></span><br><span class="line"><span class="number">0006</span>    <span class="keyword">int</span> _m; <span class="comment">//B-树的阶次，至少为3——创建时指定，一般不能修改</span></span><br><span class="line"><span class="number">0007</span>    BTNodePosi&lt;T&gt; _root; <span class="comment">//根节点</span></span><br><span class="line"><span class="number">0008</span>    BTNodePosi&lt;T&gt; _hot; <span class="comment">//BTree::search()最后访问的非空（除非树空）的节点位置</span></span><br><span class="line"><span class="number">0009</span>    <span class="function"><span class="keyword">void</span> <span class="title">solveOverflow</span> <span class="params">( BTNodePosi&lt;T&gt; )</span></span>; <span class="comment">//因插入而上溢之后的分裂处理</span></span><br><span class="line"><span class="number">0010</span>    <span class="function"><span class="keyword">void</span> <span class="title">solveUnderflow</span> <span class="params">( BTNodePosi&lt;T&gt; )</span></span>; <span class="comment">//因删除而下溢之后的合并处理</span></span><br><span class="line"><span class="number">0011</span> <span class="keyword">public</span>:</span><br><span class="line"><span class="number">0012</span>    <span class="built_in">BTree</span> ( <span class="keyword">int</span> m = <span class="number">3</span> ) : _m ( m ), _size ( <span class="number">0</span> ) <span class="comment">//构造函数：默认为最低的3阶</span></span><br><span class="line"><span class="number">0013</span>    &#123; _root = <span class="keyword">new</span> BTNode&lt;T&gt;(); &#125;</span><br><span class="line"><span class="number">0014</span>    ~<span class="built_in">BTree</span>() &#123; <span class="keyword">if</span> ( _root ) <span class="built_in">release</span> ( _root ); &#125; <span class="comment">//析构函数：释放所有节点</span></span><br><span class="line"><span class="number">0015</span>    <span class="function"><span class="keyword">int</span> <span class="keyword">const</span> <span class="title">order</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _m; &#125; <span class="comment">//阶次</span></span><br><span class="line"><span class="number">0016</span>    <span class="function"><span class="keyword">int</span> <span class="keyword">const</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line"><span class="number">0017</span>    <span class="function">BTNodePosi&lt;T&gt; &amp; <span class="title">root</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _root; &#125; <span class="comment">//树根</span></span><br><span class="line"><span class="number">0018</span>    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_root; &#125; <span class="comment">//判空</span></span><br><span class="line"><span class="number">0019</span>    <span class="function">BTNodePosi&lt;T&gt; <span class="title">search</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//查找</span></span><br><span class="line"><span class="number">0020</span>    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//插入</span></span><br><span class="line"><span class="number">0021</span>    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//删除</span></span><br><span class="line"><span class="number">0022</span> &#125;; <span class="comment">//BTree</span></span><br></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>诀窍：<img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305194112323.png" alt="image-20220305194112323"></p>
<h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>一系列顺序查找，一系列IO操作，相间隔组成的搜寻</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305194207272.png" alt="image-20220305194207272"></p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305194338075.png" alt="image-20220305194338075"></p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>O处失败，代表着没有比O+1更大，也就是直接走它的Rchild里继续搜索</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305194821793.png" alt="image-20220305194821793"></p>
<h4 id="主次成本"><a href="#主次成本" class="headerlink" title="主次成本"></a>主次成本</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305195008631.png" alt="image-20220305195008631"></p>
<h4 id="最大高度"><a href="#最大高度" class="headerlink" title="最大高度"></a>最大高度</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305195227764.png" alt="image-20220305195227764"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305195237328.png" alt="image-20220305195237328"></p>
<p>​        要想树最高，则边最少，每个分支取做下限（[m/2])，关键点就取1个作为一个超级节点</p>
<p>此时树高降低<strong>1/7</strong></p>
<h4 id="最小高度"><a href="#最小高度" class="headerlink" title="最小高度"></a>最小高度</h4><p>M详情看前面M阶</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305200346210.png" alt="image-20220305200346210"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h4><p>因为这里左闭右开，所以如此定义</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305201148019.png" alt="image-20220305201148019"></p>
<h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305201438837.png" alt="image-20220305201438837"></p>
<p>为何如此游刃有余，则得益于B树定义的精妙</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305201459628.png" alt="image-20220305201459628"></p>
<p>插上去之后，下面的两部分，也不会低于m/2的上整</p>
<h4 id="再分裂"><a href="#再分裂" class="headerlink" title="再分裂"></a>再分裂</h4><p>该节点上溢之后，它上去了会有继续上溢的风险，可能会持续的发生，不过好消息是，满足单调性，充其量是遍历各层，抵达根节点，但根节点处理有所不同。</p>
<h4 id="分裂到根"><a href="#分裂到根" class="headerlink" title="分裂到根"></a>分裂到根</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305201735741.png" alt="image-20220305201735741"></p>
<p>所以说！！阶次含义中加入的那条修正案，是断乎不可省略的！！！！</p>
<p>累计不过h次，所以整个时间不会高于它的高度，这也是我们所期望的。</p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305201920680.png" alt="image-20220305201920680"></p>
<h4 id="实战代码"><a href="#实战代码" class="headerlink" title="实战代码"></a>实战代码</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305201037071.png" alt="image-20220305201037071"></p>
<h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert()"></a>Insert()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::<span class="built_in">insert</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入B树中</span></span><br><span class="line"><span class="number">0002</span>    BTNodePosi&lt;T&gt; v = <span class="built_in">search</span> ( e ); <span class="keyword">if</span> ( v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标节点不存在</span></span><br><span class="line"><span class="number">0003</span>    Rank r = _hot-&gt;key.<span class="built_in">search</span> ( e ); <span class="comment">//在节点_hot的有序关键码向量中查找合适的插入位置</span></span><br><span class="line"><span class="number">0004</span>    _hot-&gt;key.<span class="built_in">insert</span> ( r + <span class="number">1</span>, e ); <span class="comment">//将新关键码插至对应的位置</span></span><br><span class="line"><span class="number">0005</span>    _hot-&gt;child.<span class="built_in">insert</span> ( r + <span class="number">2</span>, <span class="literal">NULL</span> ); <span class="comment">//创建一个空子树指针</span></span><br><span class="line"><span class="number">0006</span>    _size++; <span class="comment">//更新全树规模</span></span><br><span class="line"><span class="number">0007</span>    <span class="built_in">solveOverflow</span> ( _hot ); <span class="comment">//如有必要，需做分裂</span></span><br><span class="line"><span class="number">0008</span>    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//插入成功</span></span><br><span class="line"><span class="number">0009</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="上溢修复"><a href="#上溢修复" class="headerlink" title="上溢修复"></a>上溢修复</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码插入后若节点上溢，则做节点分裂处理</span></span><br><span class="line"><span class="number">0002</span> <span class="keyword">void</span> BTree&lt;T&gt;::<span class="built_in">solveOverflow</span> ( BTNodePosi&lt;T&gt; v ) &#123;</span><br><span class="line"><span class="number">0003</span>    <span class="keyword">if</span> ( _m &gt; v-&gt;key.<span class="built_in">size</span>() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未上溢</span></span><br><span class="line"><span class="number">0004</span>    Rank s = _m / <span class="number">2</span>; <span class="comment">//轴点（此时应有_m = key.size() = child.size() - 1）</span></span><br><span class="line"><span class="number">0005</span>    BTNodePosi&lt;T&gt; u = <span class="keyword">new</span> BTNode&lt;T&gt;(); <span class="comment">//注意：新节点已有一个空孩子</span></span><br><span class="line"><span class="number">0006</span>    <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _m - s - <span class="number">1</span>; j++ ) &#123; <span class="comment">//v右侧_m-s-1个孩子及关键码分裂为右侧节点u</span></span><br><span class="line"><span class="number">0007</span>       u-&gt;child.<span class="built_in">insert</span> ( j, v-&gt;child.<span class="built_in">remove</span> ( s + <span class="number">1</span> ) ); <span class="comment">//逐个移动效率低</span></span><br><span class="line"><span class="number">0008</span>       u-&gt;key.<span class="built_in">insert</span> ( j, v-&gt;key.<span class="built_in">remove</span> ( s + <span class="number">1</span> ) ); <span class="comment">//此策略可改进</span></span><br><span class="line"><span class="number">0009</span>    &#125;</span><br><span class="line"><span class="number">0010</span>    u-&gt;child[_m - s - <span class="number">1</span>] = v-&gt;child.<span class="built_in">remove</span> ( s + <span class="number">1</span> ); <span class="comment">//移动v最靠右的孩子</span></span><br><span class="line"><span class="number">0011</span>    <span class="keyword">if</span> ( u-&gt;child[<span class="number">0</span>] ) <span class="comment">//若u的孩子们非空，则</span></span><br><span class="line"><span class="number">0012</span>       <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _m - s; j++ ) <span class="comment">//令它们的父节点统一</span></span><br><span class="line"><span class="number">0013</span>          u-&gt;child[j]-&gt;parent = u; <span class="comment">//指向u</span></span><br><span class="line"><span class="number">0014</span>    BTNodePosi&lt;T&gt; p = v-&gt;parent; <span class="comment">//v当前的父节点p</span></span><br><span class="line"><span class="number">0015</span>    <span class="keyword">if</span> ( !p ) &#123; _root = p = <span class="keyword">new</span> BTNode&lt;T&gt;(); p-&gt;child[<span class="number">0</span>] = v; v-&gt;parent = p; &#125; <span class="comment">//若p空则创建之</span></span><br><span class="line"><span class="number">0016</span>    Rank r = <span class="number">1</span> + p-&gt;key.<span class="built_in">search</span> ( v-&gt;key[<span class="number">0</span>] ); <span class="comment">//p中指向v的指针的秩</span></span><br><span class="line"><span class="number">0017</span>    p-&gt;key.<span class="built_in">insert</span> ( r, v-&gt;key.<span class="built_in">remove</span> ( s ) ); <span class="comment">//轴点关键码上升</span></span><br><span class="line"><span class="number">0018</span>    p-&gt;child.<span class="built_in">insert</span> ( r + <span class="number">1</span>, u );  u-&gt;parent = p; <span class="comment">//新节点u与父节点p互联</span></span><br><span class="line"><span class="number">0019</span>    <span class="built_in">solveOverflow</span> ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line"><span class="number">0020</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>结合刚刚插入所采用的分裂策略，我们可能很容易想到删除使用合并，是的，这的确是可以采用的预案之一，<strong>但优先级最高的并不是它</strong></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305202514525.png" alt="image-20220305202514525"></p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305202805010.png" alt="image-20220305202805010"></p>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305202935600.png" alt="image-20220305202935600"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305203033426.png" alt="image-20220305203033426"></p>
<p>这也是我们预期的好结果！</p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305203054798.png" alt="image-20220305203054798"></p>
<h4 id="实战代码-1"><a href="#实战代码-1" class="headerlink" title="实战代码"></a>实战代码</h4><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305202341543.png" alt="image-20220305202341543"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从BTree树中删除关键码e</span></span><br><span class="line"><span class="number">0002</span>    BTNodePosi&lt;T&gt; v = <span class="built_in">search</span> ( e ); <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标关键码存在</span></span><br><span class="line"><span class="number">0003</span>    Rank r = v-&gt;key.<span class="built_in">search</span> ( e ); <span class="comment">//确定目标关键码在节点v中的秩（由上，肯定合法）</span></span><br><span class="line"><span class="number">0004</span>    <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) &#123; <span class="comment">//若v非叶子，则e的后继必属于某叶节点</span></span><br><span class="line"><span class="number">0005</span>       BTNodePosi&lt;T&gt; u = v-&gt;child[r+<span class="number">1</span>]; <span class="comment">//在右子树中一直向左，即可</span></span><br><span class="line"><span class="number">0006</span>       <span class="keyword">while</span> ( u-&gt;child[<span class="number">0</span>] ) u = u-&gt;child[<span class="number">0</span>]; <span class="comment">//找出e的后继</span></span><br><span class="line"><span class="number">0007</span>       v-&gt;key[r] = u-&gt;key[<span class="number">0</span>]; v = u; r = <span class="number">0</span>; <span class="comment">//并与之交换位置</span></span><br><span class="line"><span class="number">0008</span>    &#125; <span class="comment">//至此，v必然位于最底层，且其中第r个关键码就是待删除者</span></span><br><span class="line"><span class="number">0009</span>    v-&gt;key.<span class="built_in">remove</span> ( r ); v-&gt;child.<span class="built_in">remove</span> ( r + <span class="number">1</span> ); _size--; <span class="comment">//删除e，以及其下两个外部节点之一</span></span><br><span class="line"><span class="number">0010</span>    <span class="built_in">solveUnderflow</span> ( v ); <span class="comment">//如有必要，需做旋转或合并</span></span><br><span class="line"><span class="number">0011</span>    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="number">0012</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="下溢修复"><a href="#下溢修复" class="headerlink" title="下溢修复"></a>下溢修复</h5><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305203230556.png" alt="image-20220305203230556"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码删除后若节点下溢，则做节点旋转或合并处理</span></span><br><span class="line"><span class="number">0002</span> <span class="keyword">void</span> BTree&lt;T&gt;::<span class="built_in">solveUnderflow</span> ( BTNodePosi&lt;T&gt; v ) &#123;</span><br><span class="line"><span class="number">0003</span>    <span class="keyword">if</span> ( ( _m + <span class="number">1</span> ) / <span class="number">2</span> &lt;= v-&gt;child.<span class="built_in">size</span>() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未下溢</span></span><br><span class="line"><span class="number">0004</span>    BTNodePosi&lt;T&gt; p = v-&gt;parent;</span><br><span class="line"><span class="number">0005</span>    <span class="keyword">if</span> ( !p ) &#123; <span class="comment">//递归基：已到根节点，没有孩子的下限</span></span><br><span class="line"><span class="number">0006</span>       <span class="keyword">if</span> ( !v-&gt;key.<span class="built_in">size</span>() &amp;&amp; v-&gt;child[<span class="number">0</span>] ) &#123;</span><br><span class="line"><span class="number">0007</span>          <span class="comment">//但倘若作为树根的v已不含关键码，却有（唯一的）非空孩子，则</span></span><br><span class="line"><span class="number">0008</span>          _root = v-&gt;child[<span class="number">0</span>]; _root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//这个节点可被跳过</span></span><br><span class="line"><span class="number">0009</span>          v-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>; <span class="built_in">release</span> ( v ); <span class="comment">//并因不再有用而被销毁</span></span><br><span class="line"><span class="number">0010</span>       &#125; <span class="comment">//整树高度降低一层</span></span><br><span class="line"><span class="number">0011</span>       <span class="keyword">return</span>;</span><br><span class="line"><span class="number">0012</span>    &#125;</span><br><span class="line"><span class="number">0013</span>    Rank r = <span class="number">0</span>; <span class="keyword">while</span> ( p-&gt;child[r] != v ) r++;</span><br><span class="line"><span class="number">0014</span>    <span class="comment">//确定v是p的第r个孩子——此时v可能不含关键码，故不能通过关键码查找</span></span><br><span class="line"><span class="number">0015</span>    <span class="comment">//另外，在实现了孩子指针的判等器之后，也可直接调用Vector::find()定位</span></span><br><span class="line"><span class="number">0016</span> <span class="comment">// 情况1：向左兄弟借关键码</span></span><br><span class="line"><span class="number">0017</span>    <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//若v不是p的第一个孩子，则</span></span><br><span class="line"><span class="number">0018</span>       BTNodePosi&lt;T&gt; ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line"><span class="number">0019</span>       <span class="keyword">if</span> ( ( _m + <span class="number">1</span> ) / <span class="number">2</span> &lt; ls-&gt;child.<span class="built_in">size</span>() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line"><span class="number">0020</span>          v-&gt;key.<span class="built_in">insert</span> ( <span class="number">0</span>, p-&gt;key[r - <span class="number">1</span>] ); <span class="comment">//p借出一个关键码给v（作为最小关键码）</span></span><br><span class="line"><span class="number">0021</span>          p-&gt;key[r - <span class="number">1</span>] = ls-&gt;key.<span class="built_in">remove</span> ( ls-&gt;key.<span class="built_in">size</span>() - <span class="number">1</span> ); <span class="comment">//ls的最大关键码转入p</span></span><br><span class="line"><span class="number">0022</span>          v-&gt;child.<span class="built_in">insert</span> ( <span class="number">0</span>, ls-&gt;child.<span class="built_in">remove</span> ( ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line"><span class="number">0023</span>          <span class="comment">//同时ls的最右侧孩子过继给v</span></span><br><span class="line"><span class="number">0024</span>          <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) v-&gt;child[<span class="number">0</span>]-&gt;parent = v; <span class="comment">//作为v的最左侧孩子</span></span><br><span class="line"><span class="number">0025</span>          <span class="keyword">return</span>; <span class="comment">//至此，通过右旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line"><span class="number">0026</span>       &#125;</span><br><span class="line"><span class="number">0027</span>    &#125; <span class="comment">//至此，左兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="number">0028</span> <span class="comment">// 情况2：向右兄弟借关键码</span></span><br><span class="line"><span class="number">0029</span>    <span class="keyword">if</span> ( p-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> &gt; r ) &#123; <span class="comment">//若v不是p的最后一个孩子，则</span></span><br><span class="line"><span class="number">0030</span>       BTNodePosi&lt;T&gt; rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄弟必存在</span></span><br><span class="line"><span class="number">0031</span>       <span class="keyword">if</span> ( ( _m + <span class="number">1</span> ) / <span class="number">2</span> &lt; rs-&gt;child.<span class="built_in">size</span>() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line"><span class="number">0032</span>          v-&gt;key.<span class="built_in">insert</span> ( v-&gt;key.<span class="built_in">size</span>(), p-&gt;key[r] ); <span class="comment">//p借出一个关键码给v（作为最大关键码）</span></span><br><span class="line"><span class="number">0033</span>          p-&gt;key[r] = rs-&gt;key.<span class="built_in">remove</span> ( <span class="number">0</span> ); <span class="comment">//rs的最小关键码转入p</span></span><br><span class="line"><span class="number">0034</span>          v-&gt;child.<span class="built_in">insert</span> ( v-&gt;child.<span class="built_in">size</span>(), rs-&gt;child.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line"><span class="number">0035</span>          <span class="comment">//同时rs的最左侧孩子过继给v</span></span><br><span class="line"><span class="number">0036</span>          <span class="keyword">if</span> ( v-&gt;child[v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>] ) <span class="comment">//作为v的最右侧孩子</span></span><br><span class="line"><span class="number">0037</span>             v-&gt;child[v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = v;</span><br><span class="line"><span class="number">0038</span>          <span class="keyword">return</span>; <span class="comment">//至此，通过左旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line"><span class="number">0039</span>       &#125;</span><br><span class="line"><span class="number">0040</span>    &#125; <span class="comment">//至此，右兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="number">0041</span> <span class="comment">// 情况3：左、右兄弟要么为空（但不可能同时），要么都太“瘦”——合并</span></span><br><span class="line"><span class="number">0042</span>    <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//与左兄弟合并</span></span><br><span class="line"><span class="number">0043</span>       BTNodePosi&lt;T&gt; ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line"><span class="number">0044</span>       ls-&gt;key.<span class="built_in">insert</span> ( ls-&gt;key.<span class="built_in">size</span>(), p-&gt;key.<span class="built_in">remove</span> ( r - <span class="number">1</span> ) ); p-&gt;child.<span class="built_in">remove</span> ( r );</span><br><span class="line"><span class="number">0045</span>       <span class="comment">//p的第r - 1个关键码转入ls，v不再是p的第r个孩子</span></span><br><span class="line"><span class="number">0046</span>       ls-&gt;child.<span class="built_in">insert</span> ( ls-&gt;child.<span class="built_in">size</span>(), v-&gt;child.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line"><span class="number">0047</span>       <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>] ) <span class="comment">//v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line"><span class="number">0048</span>          ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line"><span class="number">0049</span>       <span class="keyword">while</span> ( !v-&gt;key.<span class="built_in">empty</span>() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入ls</span></span><br><span class="line"><span class="number">0050</span>          ls-&gt;key.<span class="built_in">insert</span> ( ls-&gt;key.<span class="built_in">size</span>(), v-&gt;key.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line"><span class="number">0051</span>          ls-&gt;child.<span class="built_in">insert</span> ( ls-&gt;child.<span class="built_in">size</span>(), v-&gt;child.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line"><span class="number">0052</span>          <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>] ) ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line"><span class="number">0053</span>       &#125;</span><br><span class="line"><span class="number">0054</span>       <span class="built_in">release</span> ( v ); <span class="comment">//释放v</span></span><br><span class="line"><span class="number">0055</span>    &#125; <span class="keyword">else</span> &#123; <span class="comment">//与右兄弟合并</span></span><br><span class="line"><span class="number">0056</span>       BTNodePosi&lt;T&gt; rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄弟必存在</span></span><br><span class="line"><span class="number">0057</span>       rs-&gt;key.<span class="built_in">insert</span> ( <span class="number">0</span>, p-&gt;key.<span class="built_in">remove</span> ( r ) ); p-&gt;child.<span class="built_in">remove</span> ( r );</span><br><span class="line"><span class="number">0058</span>       <span class="comment">//p的第r个关键码转入rs，v不再是p的第r个孩子</span></span><br><span class="line"><span class="number">0059</span>       rs-&gt;child.<span class="built_in">insert</span> ( <span class="number">0</span>, v-&gt;child.<span class="built_in">remove</span> ( v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line"><span class="number">0060</span>       <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs; <span class="comment">//v的最右侧孩子过继给rs做最左侧孩子</span></span><br><span class="line"><span class="number">0061</span>       <span class="keyword">while</span> ( !v-&gt;key.<span class="built_in">empty</span>() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入rs</span></span><br><span class="line"><span class="number">0062</span>          rs-&gt;key.<span class="built_in">insert</span> ( <span class="number">0</span>, v-&gt;key.<span class="built_in">remove</span> ( v-&gt;key.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line"><span class="number">0063</span>          rs-&gt;child.<span class="built_in">insert</span> ( <span class="number">0</span>, v-&gt;child.<span class="built_in">remove</span> ( v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line"><span class="number">0064</span>          <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs;</span><br><span class="line"><span class="number">0065</span>       &#125;</span><br><span class="line"><span class="number">0066</span>       <span class="built_in">release</span> ( v ); <span class="comment">//释放v</span></span><br><span class="line"><span class="number">0067</span>    &#125;</span><br><span class="line"><span class="number">0068</span>    <span class="built_in">solveUnderflow</span> ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line"><span class="number">0069</span>    <span class="keyword">return</span>;</span><br><span class="line"><span class="number">0070</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220305203336809.png" alt="image-20220305203336809"></p>
<p>通过自然界的光透射原理，来得到，B树为了满足实际需要，而适当调整自己的形态，变得又宽又矮也就再自然不过的了！</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="为何需要引入？"><a href="#为何需要引入？" class="headerlink" title="为何需要引入？"></a>为何需要引入？</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306090726060.png" alt="image-20220306090726060"></p>
<p>​        回顾我们之前学习过的结构，每一个状态都是动态变化，往往只存在于朝生暮死的瞬间，我们或许会对它的历史档案感兴趣，如果一个数据结构能支持这种需求，那我们可以把他称为持久性结构<img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306091113521.png" alt="image-20220306091113521"></p>
<p>蛮力实现也可以做到，存每一个版本号与一个位置，并且组装成search接口</p>
<p>可是空间消耗是断乎不可接受的。</p>
<p>​        为此，新的挑战出现了</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306091422704.png" alt="image-20220306091422704"></p>
<p>为了做到这一点，（大量共享少量更新），我们需要一种数据结构</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306091702083.png" alt="image-20220306091702083"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306092002457.png" alt="image-20220306092002457"></p>
<h3 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306092107344.png" alt="image-20220306092107344"></p>
<p>第二条乍一看不满足，其实事实上我们已经对有需要的节点都增加了外部节点</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306092254339.png" alt="image-20220306092254339"></p>
<h3 id="提升变换"><a href="#提升变换" class="headerlink" title="提升变换"></a>提升变换</h3><p>变换之前</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306092939849.png" alt="image-20220306092939849"></p>
<p>变换之后</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306092957472.png" alt="image-20220306092957472"></p>
<h3 id="Red-Black-B"><a href="#Red-Black-B" class="headerlink" title="Red-Black = B-"></a>Red-Black = B-</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306093304889.png" alt="image-20220306093304889"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306094709574.png" alt="image-20220306094709574"></p>
<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306094852938.png" alt="image-20220306094852938"></p>
<h3 id="以曲为直"><a href="#以曲为直" class="headerlink" title="以曲为直"></a>以曲为直</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306095116851.png" alt="image-20220306095116851"></p>
<p>我们做每一颗红黑树的时候，心里都要有对应的一颗B树，通过B树得到最终结果，再返还为红黑树，这样表面上看有点迂回，其实效率反而是最高的。</p>
<h3 id="双红缺陷"><a href="#双红缺陷" class="headerlink" title="双红缺陷"></a>双红缺陷</h3><p>我们不妨约定，圆形为红色结点，方型为黑色结点，八边形为待定颜色结点，每一个指向红色结点的边都用虚线表示，每一个指向黑色都实线表示，这样对我们理解有更多的好处。</p>
<p>​        因为红色结点都要向上提升</p>
<p>染红结点是因为，为了不改变黑色结点的数量</p>
<p>虚线是因为，这类虚线对黑高度是没有影响的</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306100221510.png" alt="image-20220306100221510"></p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h3><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306100405986.png" alt="image-20220306100405986"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; RedBlack&lt;T&gt;::<span class="built_in">insert</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将e插入红黑树</span></span><br><span class="line"><span class="number">0002</span>    BinNodePosi&lt;T&gt; &amp; x = <span class="built_in">search</span> ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line"><span class="number">0003</span>    x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span> ); _size++; <span class="comment">//创建红节点x：以_hot为父，黑高度0</span></span><br><span class="line"><span class="number">0004</span>    BinNodePosi&lt;T&gt; xOld = x; <span class="built_in">solveDoubleRed</span> ( x ); <span class="keyword">return</span> xOld; <span class="comment">//经双红修正后，即可返回</span></span><br><span class="line"><span class="number">0005</span> &#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br></pre></td></tr></table></figure>

<h3 id="RR-1"><a href="#RR-1" class="headerlink" title="RR-1"></a>RR-1</h3><p>若叔父是黑结点，则从b树的角度无需改变拓扑结构，只需要将超级结点中间的红色与祖父的黑色交换即可</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306101203217.png" alt="image-20220306101203217"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306101417298.png" alt="image-20220306101417298"></p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306101455804.png" alt="image-20220306101455804"></p>
<h3 id="RR-2"><a href="#RR-2" class="headerlink" title="RR-2"></a>RR-2</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306101626698.png" alt="image-20220306101626698"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306101745070.png" alt="image-20220306101745070"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306101920133.png" alt="image-20220306101920133"></p>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306102037345.png" alt="image-20220306102037345"></p>
<h3 id="实战代码-2"><a href="#实战代码-2" class="headerlink" title="实战代码"></a>实战代码</h3><h4 id="解决双红缺陷"><a href="#解决双红缺陷" class="headerlink" title="解决双红缺陷"></a>解决双红缺陷</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment">0002  * RedBlack双红调整算法：解决节点x与其父均为红色的问题。分为两大类情况：</span></span><br><span class="line"><span class="comment">0003  *    RR-1：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归</span></span><br><span class="line"><span class="comment">0004  *    RR-2：3次颜色翻转，3次黑高度更新，0次旋转，需要递归</span></span><br><span class="line"><span class="comment">0005  ******************************************************************************************/</span></span><br><span class="line"><span class="number">0006</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::<span class="built_in">solveDoubleRed</span> ( BinNodePosi&lt;T&gt; x ) &#123; <span class="comment">//x当前必为红</span></span><br><span class="line"><span class="number">0007</span>    <span class="keyword">if</span> ( <span class="built_in">IsRoot</span> ( *x ) ) <span class="comment">//若已（递归）转至树根，则将其转黑，整树黑高度也随之递增</span></span><br><span class="line"><span class="number">0008</span>       &#123;  _root-&gt;color = RB_BLACK; _root-&gt;height++; <span class="keyword">return</span>;  &#125; <span class="comment">//否则，x的父亲p必存在</span></span><br><span class="line"><span class="number">0009</span>    BinNodePosi&lt;T&gt; p = x-&gt;parent; <span class="keyword">if</span> ( <span class="built_in">IsBlack</span> ( p ) ) <span class="keyword">return</span>; <span class="comment">//若p为黑，则可终止调整。否则</span></span><br><span class="line"><span class="number">0010</span>    BinNodePosi&lt;T&gt; g = p-&gt;parent; <span class="comment">//既然p为红，则x的祖父必存在，且必为黑色</span></span><br><span class="line"><span class="number">0011</span>    BinNodePosi&lt;T&gt; u = <span class="built_in">uncle</span> ( x ); <span class="comment">//以下，视x叔父u的颜色分别处理</span></span><br><span class="line"><span class="number">0012</span>    <span class="keyword">if</span> ( <span class="built_in">IsBlack</span> ( u ) ) &#123; <span class="comment">//u为黑色（含NULL）时</span></span><br><span class="line"><span class="number">0013</span>       <span class="keyword">if</span> ( <span class="built_in">IsLChild</span> ( *x ) == <span class="built_in">IsLChild</span> ( *p ) ) <span class="comment">//若x与p同侧（即zIg-zIg或zAg-zAg），则</span></span><br><span class="line"><span class="number">0014</span>          p-&gt;color = RB_BLACK; <span class="comment">//p由红转黑，x保持红</span></span><br><span class="line"><span class="number">0015</span>       <span class="keyword">else</span> <span class="comment">//若x与p异侧（即zIg-zAg或zAg-zIg），则</span></span><br><span class="line"><span class="number">0016</span>          x-&gt;color = RB_BLACK; <span class="comment">//x由红转黑，p保持红</span></span><br><span class="line"><span class="number">0017</span>       g-&gt;color = RB_RED; <span class="comment">//g必定由黑转红</span></span><br><span class="line"><span class="number">0018</span> <span class="comment">///// 以上虽保证总共两次染色，但因增加了判断而得不偿失</span></span><br><span class="line"><span class="number">0019</span> <span class="comment">///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高</span></span><br><span class="line"><span class="number">0020</span>       BinNodePosi&lt;T&gt; gg = g-&gt;parent; <span class="comment">//曾祖父（great-grand parent）</span></span><br><span class="line"><span class="number">0021</span>       BinNodePosi&lt;T&gt; r = <span class="built_in">FromParentTo</span> ( *g ) = <span class="built_in">rotateAt</span> ( x ); <span class="comment">//调整后的子树根节点</span></span><br><span class="line"><span class="number">0022</span>       r-&gt;parent = gg; <span class="comment">//与原曾祖父联接</span></span><br><span class="line"><span class="number">0023</span>    &#125; <span class="keyword">else</span> &#123; <span class="comment">//若u为红色</span></span><br><span class="line"><span class="number">0024</span>       p-&gt;color = RB_BLACK; p-&gt;height++; <span class="comment">//p由红转黑</span></span><br><span class="line"><span class="number">0025</span>       u-&gt;color = RB_BLACK; u-&gt;height++; <span class="comment">//u由红转黑</span></span><br><span class="line"><span class="number">0026</span>       <span class="keyword">if</span> ( !<span class="built_in">IsRoot</span> ( *g ) ) g-&gt;color = RB_RED; <span class="comment">//g若非根，则转红</span></span><br><span class="line"><span class="number">0027</span>       <span class="built_in">solveDoubleRed</span> ( g ); <span class="comment">//继续调整g（类似于尾递归，可优化为迭代形式）</span></span><br><span class="line"><span class="number">0028</span>    &#125;</span><br><span class="line"><span class="number">0029</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="isBlack"><a href="#isBlack" class="headerlink" title="isBlack()"></a>isBlack()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IsBlack(p) ( ! (p) || ( RB_BLACK == (p)-&gt;color ) ) <span class="comment">//外部节点也视作黑节点</span></span></span><br><span class="line"><span class="number">0002</span> <span class="meta">#<span class="meta-keyword">define</span> IsRed(p) ( ! IsBlack(p) ) <span class="comment">//非黑即红</span></span></span><br><span class="line"><span class="number">0003</span> <span class="meta">#<span class="meta-keyword">define</span> BlackHeightUpdated(x) ( <span class="comment">/*RedBlack高度更新条件*/</span> \</span></span><br><span class="line"><span class="meta">0004    ( stature( (x).lc ) == stature( (x).rc ) ) &amp;&amp; \</span></span><br><span class="line"><span class="meta">0005    ( (x).height == ( IsRed(&amp; x) ? stature( (x).lc ) : stature( (x).lc ) + 1 ) ) \</span></span><br><span class="line"><span class="meta">0006 )</span></span><br></pre></td></tr></table></figure>



<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306102408677.png" alt="image-20220306102408677"></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306102457624.png" alt="image-20220306102457624"></p>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306103402410.png" alt="image-20220306103402410"></p>
<h3 id="双黑缺陷"><a href="#双黑缺陷" class="headerlink" title="双黑缺陷"></a>双黑缺陷</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306103528810.png" alt="image-20220306103528810"></p>
<p>考察父亲—兄弟</p>
<h4 id="BB-1"><a href="#BB-1" class="headerlink" title="BB-1"></a>BB-1</h4><p>如果将双黑称作BB，那么第一种情况称为BB-1，这种情况特点是<strong>r或者x的兄弟s是黑</strong>的，同时<strong>至少有一个红色</strong>的孩子，记作t</p>
<p>​        注意，<u>x为删除的结点哈</u></p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306103921400.png" alt="image-20220306103921400"></p>
<h4 id="反观回味"><a href="#反观回味" class="headerlink" title="反观回味"></a>反观回味</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306104329920.png" alt="image-20220306104329920"></p>
<p>我们说，这种情况还是相对算简单的，这种简单在于，我们至少还有旋转调整的余地，也就是说，兄弟节点还足够富有，或者说，兄弟节点至少有一个虚边</p>
<p>​        如果兄弟的两个孩子都是黑，此时我们又应该如何应对呢？</p>
<h4 id="BB-2R"><a href="#BB-2R" class="headerlink" title="BB-2R"></a>BB-2R</h4><p><strong>(BB-2)R</strong></p>
<p>对应于兄弟的两个孩子都是黑的，此时，父节点开始扑朔迷离，影响全局，我们首先讨论父节点为红的情况</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306105015498.png" alt="image-20220306105015498"></p>
<p>选择的策略就是，父节点借出+与子节点合并</p>
<h4 id="BB-2B"><a href="#BB-2B" class="headerlink" title="BB-2B"></a>BB-2B</h4><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306105359186.png" alt="image-20220306105359186"></p>
<p>​        S转为红色，p下来借出，使得性质在局部一直得以恢复</p>
<p>换言之，我们最多执行logN次染色调整，这时，我们可能会关心，红黑树的拓扑结构难道需要logN次变动吗？？？</p>
<p>​        为此，我们说，是不必的，看从a—-&gt;b的过程，其实红黑树的拓扑结构并没有发生任何的变化。</p>
<p>​        也就是说，整个拓扑结构的调整不超过常数依然有可能落实。</p>
<h4 id="BB-3"><a href="#BB-3" class="headerlink" title="BB-3"></a>BB-3</h4><p>S的三个（父亲，儿子，都是黑）他为红</p>
<p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306110003708.png" alt="image-20220306110003708"></p>
<p>虽然黑高度问题仍然未能解决，但是我们说这样做并非没有意义。</p>
<p>​        因此r在无形中，增添了一个黑兄弟，以至于，他在下一时刻，必定脱离当前情况</p>
<p>​    更好的消息是，只会转入BB-1,BB-2R，绝不会是情况BB-2B，BB-2B的要点是父节点P必须是黑的，然而父节点p已经悄然变成了黑色，而我们应该能想到，从复杂度的角度来看，BB-1,BB-2R无疑是更简单的，因为他们不会像BB-2B一样不断向上蔓延，因此我们可以断定，再经过一轮调整，整个红黑树必定修复</p>
<h4 id="实现汇总"><a href="#实现汇总" class="headerlink" title="实现汇总"></a>实现汇总</h4><h5 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> RedBlack&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从红黑树中删除关键码e</span></span><br><span class="line"><span class="number">0002</span>    BinNodePosi&lt;T&gt; &amp; x = <span class="built_in">search</span> ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line"><span class="number">0003</span>    BinNodePosi&lt;T&gt; r = <span class="built_in">removeAt</span> ( x, _hot ); <span class="keyword">if</span> ( ! ( --_size ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//实施删除</span></span><br><span class="line"><span class="number">0004</span> <span class="comment">// assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整</span></span><br><span class="line"><span class="number">0005</span>    <span class="keyword">if</span> ( ! _hot ) <span class="comment">//若刚被删除的是根节点，则将其置黑，并更新黑高度</span></span><br><span class="line"><span class="number">0006</span>       &#123; _root-&gt;color = RB_BLACK; <span class="built_in">updateHeight</span> ( _root ); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="number">0007</span> <span class="comment">// assert: 以下，原x（现r）必非根，_hot必非空</span></span><br><span class="line"><span class="number">0008</span>    <span class="keyword">if</span> ( <span class="built_in">BlackHeightUpdated</span> ( *_hot ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//若所有祖先的黑深度依然平衡，则无需调整</span></span><br><span class="line"><span class="number">0009</span>    <span class="keyword">if</span> ( <span class="built_in">IsRed</span> ( r ) ) <span class="comment">//否则，若r为红，则只需令其转黑</span></span><br><span class="line"><span class="number">0010</span>       &#123; r-&gt;color = RB_BLACK; r-&gt;height++; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="number">0011</span> <span class="comment">// assert: 以下，原x（现r）均为黑色</span></span><br><span class="line"><span class="number">0012</span>    <span class="built_in">solveDoubleBlack</span> ( r ); <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//经双黑调整后返回</span></span><br><span class="line"><span class="number">0013</span> &#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure>

<h5 id="双黑缺陷-1"><a href="#双黑缺陷-1" class="headerlink" title="双黑缺陷"></a>双黑缺陷</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment">0002  * RedBlack双黑调整算法：解决节点x与被其替代的节点均为黑色的问题</span></span><br><span class="line"><span class="comment">0003  * 分为三大类共四种情况：</span></span><br><span class="line"><span class="comment">0004  *    BB-1 ：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归</span></span><br><span class="line"><span class="comment">0005  *    BB-2R：2次颜色翻转，2次黑高度更新，0次旋转，不再递归</span></span><br><span class="line"><span class="comment">0006  *    BB-2B：1次颜色翻转，1次黑高度更新，0次旋转，需要递归</span></span><br><span class="line"><span class="comment">0007  *    BB-3 ：2次颜色翻转，2次黑高度更新，1次旋转，转为BB-1或BB2R</span></span><br><span class="line"><span class="comment">0008  ******************************************************************************************/</span></span><br><span class="line"><span class="number">0009</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::<span class="built_in">solveDoubleBlack</span> ( BinNodePosi&lt;T&gt; r ) &#123;</span><br><span class="line"><span class="number">0010</span>    BinNodePosi&lt;T&gt; p = r ? r-&gt;parent : _hot; <span class="keyword">if</span> ( !p ) <span class="keyword">return</span>; <span class="comment">//r的父亲</span></span><br><span class="line"><span class="number">0011</span>    BinNodePosi&lt;T&gt; s = ( r == p-&gt;lc ) ? p-&gt;rc : p-&gt;lc; <span class="comment">//r的兄弟</span></span><br><span class="line"><span class="number">0012</span>    <span class="keyword">if</span> ( <span class="built_in">IsBlack</span> ( s ) ) &#123; <span class="comment">//兄弟s为黑</span></span><br><span class="line"><span class="number">0013</span>       BinNodePosi&lt;T&gt; t = <span class="literal">NULL</span>; <span class="comment">//s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）</span></span><br><span class="line"><span class="number">0014</span>       <span class="keyword">if</span> ( <span class="built_in">IsRed</span> ( s-&gt;rc ) ) t = s-&gt;rc; <span class="comment">//右子</span></span><br><span class="line"><span class="number">0015</span>       <span class="keyword">if</span> ( <span class="built_in">IsRed</span> ( s-&gt;lc ) ) t = s-&gt;lc; <span class="comment">//左子</span></span><br><span class="line"><span class="number">0016</span>       <span class="keyword">if</span> ( t ) &#123; <span class="comment">//黑s有红孩子：BB-1</span></span><br><span class="line"><span class="number">0017</span>          RBColor oldColor = p-&gt;color; <span class="comment">//备份原子树根节点p颜色，并对t及其父亲、祖父</span></span><br><span class="line"><span class="number">0018</span>       <span class="comment">// 以下，通过旋转重平衡，并将新子树的左、右孩子染黑</span></span><br><span class="line"><span class="number">0019</span>          BinNodePosi&lt;T&gt; b = <span class="built_in">FromParentTo</span> ( *p ) = <span class="built_in">rotateAt</span> ( t ); <span class="comment">//旋转</span></span><br><span class="line"><span class="number">0020</span>          <span class="keyword">if</span> ( <span class="built_in">HasLChild</span> ( *b ) ) &#123; b-&gt;lc-&gt;color = RB_BLACK; <span class="built_in">updateHeight</span> ( b-&gt;lc ); &#125; <span class="comment">//左子</span></span><br><span class="line"><span class="number">0021</span>          <span class="keyword">if</span> ( <span class="built_in">HasRChild</span> ( *b ) ) &#123; b-&gt;rc-&gt;color = RB_BLACK; <span class="built_in">updateHeight</span> ( b-&gt;rc ); &#125; <span class="comment">//右子</span></span><br><span class="line"><span class="number">0022</span>          b-&gt;color = oldColor; <span class="built_in">updateHeight</span> ( b ); <span class="comment">//新子树根节点继承原根节点的颜色</span></span><br><span class="line"><span class="number">0023</span>       &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑s无红孩子</span></span><br><span class="line"><span class="number">0024</span>          s-&gt;color = RB_RED; s-&gt;height--; <span class="comment">//s转红</span></span><br><span class="line"><span class="number">0025</span>          <span class="keyword">if</span> ( <span class="built_in">IsRed</span> ( p ) ) &#123; <span class="comment">//BB-2R</span></span><br><span class="line"><span class="number">0026</span>             p-&gt;color = RB_BLACK; <span class="comment">//p转黑，但黑高度不变</span></span><br><span class="line"><span class="number">0027</span>          &#125; <span class="keyword">else</span> &#123; <span class="comment">//BB-2B</span></span><br><span class="line"><span class="number">0028</span>             p-&gt;height--; <span class="comment">//p保持黑，但黑高度下降</span></span><br><span class="line"><span class="number">0029</span>             <span class="built_in">solveDoubleBlack</span> ( p ); <span class="comment">//递归上溯</span></span><br><span class="line"><span class="number">0030</span>          &#125;</span><br><span class="line"><span class="number">0031</span>       &#125;</span><br><span class="line"><span class="number">0032</span>    &#125; <span class="keyword">else</span> &#123; <span class="comment">//兄弟s为红：BB-3</span></span><br><span class="line"><span class="number">0033</span>       s-&gt;color = RB_BLACK; p-&gt;color = RB_RED; <span class="comment">//s转黑，p转红</span></span><br><span class="line"><span class="number">0034</span>       BinNodePosi&lt;T&gt; t = <span class="built_in">IsLChild</span> ( *s ) ? s-&gt;lc : s-&gt;rc; <span class="comment">//取t与其父s同侧</span></span><br><span class="line"><span class="number">0035</span>       _hot = p; <span class="built_in">FromParentTo</span> ( *p ) = <span class="built_in">rotateAt</span> ( t ); <span class="comment">//对t及其父亲、祖父做平衡调整</span></span><br><span class="line"><span class="number">0036</span>       <span class="built_in">solveDoubleBlack</span> ( r ); <span class="comment">//继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R</span></span><br><span class="line"><span class="number">0037</span>    &#125;</span><br><span class="line"><span class="number">0038</span> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><img src="/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/image-20220306110607566.png" alt="image-20220306110607566"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:jjyaoao@126.com">jjyaoao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jjyaoao.space/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/">http://jjyaoao.space/2022/03/05/DSA-08%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jjyaoao.space" target="_blank">jjyaoao's Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%80%9D%E7%BB%B4%E8%BF%87%E7%A8%8B/">思维过程</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81/">实战代码</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-61dbf69078ce19aa" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/01/09/HMjygFAKr2nPWdJ.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/01/09/HMjygFAKr2nPWdJ.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/01/09/JL43sbhxUEOuVeM.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/01/09/JL43sbhxUEOuVeM.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/06/DSA-09%E8%AF%8D%E5%85%B8/"><img class="prev-cover" src="https://s2.loli.net/2022/03/06/FKE7IBwksCfNQj3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">词典</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/05/DSA-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E6%89%A9%E5%85%85/"><img class="next-cover" src="https://s2.loli.net/2022/01/31/V1HZuxtlJs964nC.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/26/DSA-01%E5%BA%8F%E7%AB%A0/" title="序章"><img class="cover" src="https://s2.loli.net/2022/02/26/Xx9n2IU5fhKa1GN.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">序章</div></div></a></div><div><a href="/2022/02/26/DSA-03%E5%88%97%E8%A1%A8/" title="列表"><img class="cover" src="https://s2.loli.net/2022/03/05/Zuh5ICpjBMno2NW.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">列表</div></div></a></div><div><a href="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img class="cover" src="https://s2.loli.net/2022/02/27/kLgRpw2FjGySiKv.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-27</div><div class="title">二叉树</div></div></a></div><div><a href="/2022/02/26/DSA-02%E5%90%91%E9%87%8F/" title="向量"><img class="cover" src="https://s2.loli.net/2022/03/05/KiD5c4Qw1fgrM8u.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">向量</div></div></a></div><div><a href="/2022/02/27/DSA-04%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" title="栈与队列"><img class="cover" src="https://s2.loli.net/2022/02/27/DkHVYhA8ajxUglo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-27</div><div class="title">栈与队列</div></div></a></div><div><a href="/2022/03/06/DSA-09%E8%AF%8D%E5%85%B8/" title="词典"><img class="cover" src="https://s2.loli.net/2022/03/06/FKE7IBwksCfNQj3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-06</div><div class="title">词典</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTM1OC8zMTgyNQ=="></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%B8%E5%B1%95%E6%A0%91-Splay-Tree"><span class="toc-number">1.</span> <span class="toc-text">伸展树(Splay Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%90%E5%B1%82%E4%BC%B8%E5%B1%95"><span class="toc-number">1.1.</span> <span class="toc-text">逐层伸展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">局部性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E6%95%B4"><span class="toc-number">1.1.2.</span> <span class="toc-text">自适应调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%B1%82%E4%BC%B8%E5%B1%95-1"><span class="toc-number">1.1.3.</span> <span class="toc-text">逐层伸展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5"><span class="toc-number">1.1.5.</span> <span class="toc-text">最坏情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%B1%95"><span class="toc-number">1.2.</span> <span class="toc-text">双层伸展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%AD%99%E5%BC%82%E4%BE%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">子孙异侧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%AD%99%E5%90%8C%E4%BE%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">子孙同侧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E7%9D%9B%E4%B9%8B%E7%AC%94"><span class="toc-number">1.2.3.</span> <span class="toc-text">点睛之笔</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5"><span class="toc-number">1.4.</span> <span class="toc-text">最后一步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADT"><span class="toc-number">1.5.</span> <span class="toc-text">ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B8%E5%B1%95%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">伸展算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zIg-zIg%E7%A4%BA%E8%8C%83"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">zIg-zIg示范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">插入算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">删除算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7"><span class="toc-number">1.6.</span> <span class="toc-text">评价</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">B(-)树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.1.</span> <span class="toc-text">越来越大的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%B0%8F%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">越来越小的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">高速缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1"><span class="toc-number">2.1.4.</span> <span class="toc-text">多路平衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%98%E6%98%AFI-O"><span class="toc-number">2.1.5.</span> <span class="toc-text">还是I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BB%9F%E4%B8%80"><span class="toc-number">2.1.6.</span> <span class="toc-text">深度统一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AC%A1%E5%90%AB%E4%B9%89"><span class="toc-number">2.1.7.</span> <span class="toc-text">阶次含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A7%E5%87%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.8.</span> <span class="toc-text">紧凑表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">2.1.9.</span> <span class="toc-text">意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#M%E9%98%B6"><span class="toc-number">2.2.</span> <span class="toc-text">M阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADT-1"><span class="toc-number">2.3.</span> <span class="toc-text">ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BTNode"><span class="toc-number">2.3.1.</span> <span class="toc-text">BTNode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTree"><span class="toc-number">2.3.2.</span> <span class="toc-text">BTree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">2.3.3.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">算法过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%AC%A1%E6%88%90%E6%9C%AC"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">主次成本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">最大高度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6"><span class="toc-number">2.3.3.6.</span> <span class="toc-text">最小高度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">2.3.4.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A3%82"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">分裂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E5%88%86%E8%A3%82"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">再分裂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A3%82%E5%88%B0%E6%A0%B9"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">分裂到根</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">2.3.4.5.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.4.6.</span> <span class="toc-text">实战代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Insert"><span class="toc-number">2.3.4.6.1.</span> <span class="toc-text">Insert()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E6%BA%A2%E4%BF%AE%E5%A4%8D"><span class="toc-number">2.3.4.6.2.</span> <span class="toc-text">上溢修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">2.3.5.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">实战代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#remove"><span class="toc-number">2.3.5.4.1.</span> <span class="toc-text">remove</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E6%BA%A2%E4%BF%AE%E5%A4%8D"><span class="toc-number">2.3.5.4.2.</span> <span class="toc-text">下溢修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.3.6.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">为何需要引入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.3.</span> <span class="toc-text">实例验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8D%87%E5%8F%98%E6%8D%A2"><span class="toc-number">3.1.4.</span> <span class="toc-text">提升变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Red-Black-B"><span class="toc-number">3.1.5.</span> <span class="toc-text">Red-Black &#x3D; B-</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-number">3.2.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%9B%B2%E4%B8%BA%E7%9B%B4"><span class="toc-number">3.2.1.</span> <span class="toc-text">以曲为直</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7"><span class="toc-number">3.2.2.</span> <span class="toc-text">双红缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert"><span class="toc-number">3.2.3.</span> <span class="toc-text">insert()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RR-1"><span class="toc-number">3.2.4.</span> <span class="toc-text">RR-1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RR-2"><span class="toc-number">3.2.5.</span> <span class="toc-text">RR-2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81-2"><span class="toc-number">3.2.6.</span> <span class="toc-text">实战代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">解决双红缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isBlack"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">isBlack()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">3.2.7.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-number">3.3.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">算法框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B7"><span class="toc-number">3.3.2.</span> <span class="toc-text">双黑缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BB-1"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">BB-1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%A7%82%E5%9B%9E%E5%91%B3"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">反观回味</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BB-2R"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">BB-2R</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BB-2B"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">BB-2B</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BB-3"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">BB-3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B1%87%E6%80%BB"><span class="toc-number">3.3.2.6.</span> <span class="toc-text">实现汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-1"><span class="toc-number">3.3.2.6.1.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B7-1"><span class="toc-number">3.3.2.6.2.</span> <span class="toc-text">双黑缺陷</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.3.3.</span> <span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/03/05/TOfhyZxuDSe6BkR.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By jjyaoao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'cFvw1zyA64uttBS5jbYY7pwH-gzGzoHsz',
      appKey: '14rOjAUNzRyJSQt983q6gdza',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Livere' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善,感谢" data-fontsize="15px" data-random="false" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = 'zgYNWkNCSATLRhpg4';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>