<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++项目实战 | jjyaoao's Home</title><meta name="keywords" content="项目一"><meta name="author" content="jjyaoao,jjyaoao@126.com"><meta name="copyright" content="jjyaoao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本人第一个项目实战">
<meta property="og:type" content="article">
<meta property="og:title" content="C++项目实战">
<meta property="og:url" content="http://jjyaoao.space/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="jjyaoao&#39;s Home">
<meta property="og:description" content="本人第一个项目实战">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png">
<meta property="article:published_time" content="2022-04-15T14:22:51.000Z">
<meta property="article:modified_time" content="2023-03-15T03:31:16.843Z">
<meta property="article:author" content="jjyaoao">
<meta property="article:tag" content="遗忘指南">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="项目实战">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/01/09/le6jcmPKuJihDdU.jpg"><link rel="canonical" href="http://jjyaoao.space/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?06fb7a80772d98cbf9e7beeb76e262e4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JOZPQM4N5F","apiKey":"42451c032f2166ed9800520810e2d223","indexName":"jjyaoao-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++项目实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-15 11:31:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/01/09/le6jcmPKuJihDdU.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">jjyaoao's Home</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++项目实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-15T14:22:51.000Z" title="发表于 2022-04-15 22:22:51">2022-04-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-15T03:31:16.843Z" title="更新于 2023-03-15 11:31:16">2023-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE/">项目</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE/%E7%AC%AC%E4%B8%80%E4%B8%AA/">第一个</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">95.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>352分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++项目实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本笔记用作个人学习和查漏补缺使用，欢迎借鉴学习，期间部分函数介绍，一些知识科普使用网上各位大佬的文章，若未标明引用，请提醒我，如果不能使用，则删除，转载需标注出处<a target="_blank" rel="noopener" href="http://www.jjyaoao.space/">www.jjyaoao.space</a> </p>
</blockquote>
<p>项目总览</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220406133535462.png" alt="image-20220406133535462"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220406133733000.png" alt="image-20220406133733000"></p>
<h1 id="第一板块-如何开发永不停机的服务程序"><a href="#第一板块-如何开发永不停机的服务程序" class="headerlink" title="第一板块-如何开发永不停机的服务程序"></a>第一板块-如何开发永不停机的服务程序</h1><h2 id="章节内容"><a href="#章节内容" class="headerlink" title="章节内容"></a>章节内容</h2><h3 id="后台开发的重点"><a href="#后台开发的重点" class="headerlink" title="后台开发的重点"></a>后台开发的重点</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409183458798.png" alt="image-20220409183458798"></p>
<h3 id="程序的异常"><a href="#程序的异常" class="headerlink" title="程序的异常"></a>程序的异常</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409183552694.png" alt="image-20220409183552694"></p>
<h3 id="永不停机的服务程序"><a href="#永不停机的服务程序" class="headerlink" title="永不停机的服务程序"></a>永不停机的服务程序</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409183614902.png" alt="image-20220409183614902"></p>
<h2 id="章节任务"><a href="#章节任务" class="headerlink" title="章节任务"></a>章节任务</h2><h3 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据"></a>生成测试数据</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409183711887.png" alt="image-20220409183711887"></p>
<h3 id="服务程序的调度"><a href="#服务程序的调度" class="headerlink" title="服务程序的调度"></a>服务程序的调度</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409183743193.png" alt="image-20220409183743193"></p>
<h3 id="守护进程的实现"><a href="#守护进程的实现" class="headerlink" title="守护进程的实现"></a>守护进程的实现</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409183810221.png" alt="image-20220409183810221"></p>
<h3 id="两个常见小工具"><a href="#两个常见小工具" class="headerlink" title="两个常见小工具"></a>两个常见小工具</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409183833529.png" alt="image-20220409183833529"></p>
<h2 id="一：生成测试数据"><a href="#一：生成测试数据" class="headerlink" title="一：生成测试数据"></a>一：生成测试数据</h2><h3 id="小结任务"><a href="#小结任务" class="headerlink" title="小结任务"></a>小结任务</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409185021079.png" alt="image-20220409185021079"></p>
<h3 id="全国气象站点参数"><a href="#全国气象站点参数" class="headerlink" title="全国气象站点参数"></a>全国气象站点参数</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409184416146.png" alt="image-20220409184416146"></p>
<h3 id="全国气象分钟观测数"><a href="#全国气象分钟观测数" class="headerlink" title="全国气象分钟观测数"></a>全国气象分钟观测数</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409184543891.png" alt="image-20220409184543891"></p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220409184619225.png" alt="image-20220409184619225"></p>
<h3 id="①：搭建程序框架"><a href="#①：搭建程序框架" class="headerlink" title="①：搭建程序框架"></a>①：搭建程序框架</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	project name: crtsurfdata1.cpp 用于生成全国气象站点观测的分钟数据</span></span><br><span class="line"><span class="comment">*	author: jjyaoao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>运行的参数、说明文档、运行日志</p>
<p>/tmp/idc/surfdata/SURF_ZH_20220514021227_4976.xml</p>
<p>/tmp/idc/surfdata/SURF_ZH_20220416123000_4973.xml</p>
<p>/tmp/idc/surfdata/SURF_ZH_20220514075211_11385.xml</p>
<h3 id="②：加载站点参数"><a href="#②：加载站点参数" class="headerlink" title="②：加载站点参数"></a>②：加载站点参数</h3><ol>
<li>st_stcode结构体，存放站点</li>
<li>创建st_stcode向量实例vstcode</li>
<li>LoadSTCode方法来加入</li>
<li>使用CFile类–自行封装–进行文件读入读出</li>
<li>m_vCmdstr–自行封装–拆分字段</li>
</ol>
<h3 id="③：模拟观测数据"><a href="#③：模拟观测数据" class="headerlink" title="③：模拟观测数据"></a>③：模拟观测数据</h3><ol>
<li>st_surfdata结构体，实现每个站点的分钟观测</li>
<li>创造st_surfdata向量实例vsurfdata</li>
<li>CrtSurfData函数，实现分钟观测<ol>
<li>播随机数种子</li>
<li>获取当前时间，作为观测时间</li>
<li>遍历站点容器–vstcode</li>
<li>随机数填充分钟观测数据的结构体</li>
<li>将结构体放入容器vsurfdata</li>
</ol>
</li>
</ol>
<h3 id="④：把站点观测数据写入文件"><a href="#④：把站点观测数据写入文件" class="headerlink" title="④：把站点观测数据写入文件"></a>④：把站点观测数据写入文件</h3><ol>
<li><p>CruSurfFile函数实现写入每分钟的观测数据</p>
<ol>
<li><p>生成临时文件名–以<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412105853014.png" alt="image-20220412105853014"></p>
<p>这里outpath是绝对路径，strddatetime是当前时间，getpid是进程号，datafmt是文件格式，进程号主要是为了保证临时文件名不重复(getpid())，这里不加也可以</p>
<ol start="2">
<li> 打开文件</li>
<li>写入第一行标题//csv才需要</li>
<li>遍历存放观测数据的容器vsurfdata，并且，对临时文件进行写入操作</li>
<li>关闭文件</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>支持csv、xml、json</p>
<h4 id="有漏洞"><a href="#有漏洞" class="headerlink" title="有漏洞"></a>有漏洞</h4><p>文件在写入过程中，需要时间，如果其他程序，在这个时候读取了这个文件，就会读取到不完整的内容</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412092024212.png" alt="image-20220412092024212"></p>
<h4 id="正确的"><a href="#正确的" class="headerlink" title="正确的"></a>正确的</h4><p>我们用临时副本文件来写入，保证了别的程序目前如果要读取文件，仍然是读取的之前的文件，待临时文件准备好以后，</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412092159907.png" alt="image-20220412092159907"></p>
<h3 id="csv-xml-json"><a href="#csv-xml-json" class="headerlink" title="csv,xml,json"></a>csv,xml,json</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412091959130.png" alt="image-20220412091959130"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412094053735.png" alt="image-20220412094053735"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412095559156.png" alt="image-20220412095559156"></p>
<h4 id="再度超级女生"><a href="#再度超级女生" class="headerlink" title="再度超级女生"></a>再度超级女生</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412093529860.png" alt="image-20220412093529860"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412093610944.png" alt="image-20220412093610944"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412093713969.png" alt="image-20220412093713969"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412093756785.png" alt="image-20220412093756785"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412093910860.png" alt="image-20220412093910860"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412093939852.png" alt="image-20220412093939852"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412094201744.png" alt="image-20220412094201744"></p>
<h4 id="xml与json比较"><a href="#xml与json比较" class="headerlink" title="xml与json比较"></a>xml与json比较</h4><h5 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h5><p>JSON和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/XML">XML</a>的可读性可谓不相上下，一边是简易的语法，一边是规范的标签形式，很难分出胜负。</p>
<h5 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h5><p>XML天生有很好的扩展性，JSON当然也有，没有什么是XML可以扩展而JSON却不能扩展的。不过JSON在Javascript主场作战，可以存储Javascript复合对象，有着xml不可比拟的优势。</p>
<h5 id="编码难度"><a href="#编码难度" class="headerlink" title="编码难度"></a>编码难度</h5><p>XML有丰富的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7">编码工具</a>，比如Dom4j、Dom、SAX等，JSON也有提供的工具。无工具的情况下，相信熟练的开发人员一样能很快的写出想要的xml文档和JSON<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6">字符</a>串，不过，xml文档要多很多结构上的字符。</p>
<h5 id="实例比较"><a href="#实例比较" class="headerlink" title="实例比较"></a>实例比较</h5><p>XML和JSON都使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%B9%E6%B3%95">结构化方法</a>来标记数据，下面来做一个简单的比较。</p>
<p>用XML表示中国部分省市数据如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">province</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>黑龙江<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cities</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>哈尔滨<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>大庆<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">cities</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">province</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cities</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>珠海<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">cities</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">province</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>台湾<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cities</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>台北<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>高雄<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">cities</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">province</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>新疆<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cities</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>乌鲁木齐<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">cities</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用JSON表示如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;province&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cities&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;city&quot;</span>: [<span class="string">&quot;哈尔滨&quot;</span>, <span class="string">&quot;大庆&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;广东&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cities&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;city&quot;</span>: [<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>, <span class="string">&quot;珠海&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;台湾&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cities&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;city&quot;</span>: [<span class="string">&quot;台北&quot;</span>, <span class="string">&quot;高雄&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;新疆&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cities&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;city&quot;</span>: [<span class="string">&quot;乌鲁木齐&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，JSON 简单的语法格式和清晰的层次结构明显要比 XML 容易阅读，并且在数据交换方面，由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用的带宽。</p>
<h2 id="二、服务程序的调度"><a href="#二、服务程序的调度" class="headerlink" title="二、服务程序的调度"></a>二、服务程序的调度</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412110420183.png" alt="image-20220412110420183"></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="实例引入信号量"><a href="#实例引入信号量" class="headerlink" title="实例引入信号量"></a>实例引入信号量</h4><p>像这样的代码</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412142627337.png" alt="image-20220412142627337"></p>
<p>ctrl + c 和 killall 和 kill + 进程号都可以终止</p>
<p>用ctrl + c 或者 killall命令终止程序的本质，是向正在运行的book程序发出一个信号</p>
<p>如果在book程序中没有处理信号，就会按缺省来处理</p>
<p>linux的信号有64种，大部分的信号缺省处理方法是终止程序运行</p>
<p>可是这令人无法接受=-=，因此我们可以在程序里增加捕获信号的代码，不执行系统缺省的动作，而是调用一个函数</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412111139360.png" alt="image-20220412111139360"></p>
<h5 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h5><p>我们引入signal函数 传参的第一个ii，为信号量的具体数值，func代表接收到这个信号后应该采用func函数的方式处理</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412142904610.png" alt="image-20220412142904610"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412143121308.png" alt="image-20220412143121308"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412143058537.png" alt="image-20220412143058537"></p>
<p>同时……………….</p>
<p>9的信号是不能被忽略，也不能被屏蔽（不能被signal捕获），是一定会执行的强制杀死程序的信号</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412143221306.png" alt="image-20220412143221306"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412143239273.png" alt="image-20220412143239273"></p>
<p>将15忽略 / 将15缺省，也就是先后</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412143355908.png" alt="image-20220412143355908"></p>
<h4 id="1、信号基本概念"><a href="#1、信号基本概念" class="headerlink" title="1、信号基本概念"></a>1、信号基本概念</h4><p>​        信号（signal）是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是，不能给进程传递任何数据。</p>
<p>​        信号产生的原因有很多，在Linux下，可以用kill和killall命令发送信号。</p>
<p>SIG_DFL,SIG_IGN 分别表示无返回值的函数指针，指针值分别是0和1，这两个指针值逻辑上讲是实际程序中不可能出现的函数地址值。<br><strong>SIG_DFL</strong>：默认信号<strong>处理</strong>程序<br><strong>SIG_IGN</strong>：<strong>忽略</strong>信号的处理程序</p>
<h4 id="2、信号的类型"><a href="#2、信号的类型" class="headerlink" title="2、信号的类型"></a>2、信号的类型</h4><table>
<thead>
<tr>
<th>信号名</th>
<th>信号值</th>
<th>默认处理动作</th>
<th>发出信号的原因</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP</td>
<td>1</td>
<td>A</td>
<td>终端挂起或者控制进程终止</td>
</tr>
<tr>
<td><strong>SIGINT</strong></td>
<td><strong>2</strong></td>
<td><strong>A</strong></td>
<td><strong>键盘中断Ctrl+c</strong></td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>C</td>
<td>键盘的退出键被按下</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>C</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>C</td>
<td>由abort(3)发出的退出指令</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>C</td>
<td>浮点异常</td>
</tr>
<tr>
<td><strong>SIGKILL</strong></td>
<td><strong>9</strong></td>
<td><strong>AEF</strong></td>
<td><strong>采用kill  -9 进程编号 强制杀死程序。</strong></td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>C</td>
<td>无效的内存引用</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>A</td>
<td>管道破裂，写一个没有读端口的管道。</td>
</tr>
<tr>
<td><strong>SIGALRM</strong></td>
<td><strong>14</strong></td>
<td><strong>A</strong></td>
<td><strong>由alarm(2)发出的信号</strong></td>
</tr>
<tr>
<td><strong>SIGTERM</strong></td>
<td><strong>15</strong></td>
<td><strong>A</strong></td>
<td><strong>采用“kill  进程编号”或“killall 程序名”通知程序。</strong></td>
</tr>
<tr>
<td><strong>SIGUSR1</strong></td>
<td><strong>10</strong></td>
<td><strong>A</strong></td>
<td><strong>用户自定义信号1</strong></td>
</tr>
<tr>
<td><strong>SIGUSR2</strong></td>
<td><strong>12</strong></td>
<td><strong>A</strong></td>
<td><strong>用户自定义信号2</strong></td>
</tr>
<tr>
<td><strong>SIGCHLD</strong></td>
<td><strong>17</strong></td>
<td><strong>B</strong></td>
<td><strong>子进程结束信号</strong></td>
</tr>
<tr>
<td>SIGCONT</td>
<td>18</td>
<td></td>
<td>进程继续（曾被停止的进程）</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>19</td>
<td>DEF</td>
<td>终止进程</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>20</td>
<td>D</td>
<td>控制终端（tty）上按下停止键</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21</td>
<td>D</td>
<td>后台进程企图从控制终端读</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22</td>
<td>D</td>
<td>后台进程企图从控制终端写</td>
</tr>
</tbody></table>
<p>处理动作一项中的字母含义如下</p>
<p>A 缺省的动作是终止进程。</p>
<p>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。</p>
<p>C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</p>
<p>D 缺省的动作是停止进程，进入停止状态的程序还能重新继续，一般是在调试的过程中。</p>
<p>E 信号不能被捕获。</p>
<p>F 信号不能被忽略。</p>
<h4 id="3、信号的处理"><a href="#3、信号的处理" class="headerlink" title="3、信号的处理"></a>3、信号的处理</h4><p>进程对信号的处理方法有三种：</p>
<p>1）对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。</p>
<p>2）设置中断的处理函数，收到信号后，由该函数来处理。</p>
<p>3）忽略某个信号，对该信号不做任何处理，就像未发生过一样。</p>
<p>signal函数可以设置程序对信号的处理方式。</p>
<p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数signum表示信号的编号。</p>
<p>参数handler表示信号的处理方式，有三种情况：</p>
<p>1）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。 </p>
<p>2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。</p>
<p>3）SIG_IGN：忽略参数signum所指的信号。</p>
<h4 id="4、信号有什么用"><a href="#4、信号有什么用" class="headerlink" title="4、信号有什么用"></a>4、信号有什么用</h4><p>服务程序运行在后台，如果想让中止它，杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有安排善后工作。</p>
<p>如果向服务程序发送一个信号，服务程序收到这个信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。</p>
<p>向服务程序发送0的信号，可以检测程序是否存活。</p>
<h4 id="5、信号应用示例"><a href="#5、信号应用示例" class="headerlink" title="5、信号应用示例"></a>5、信号应用示例</h4><p>在实际开发中，在main函数开始的位置，程序员会先屏蔽掉全部的信号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">64</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN);</span><br></pre></td></tr></table></figure>

<p>这么做的目的是不希望程序被干扰。然后，再设置程序员关心的信号的处理函数。</p>
<p>程序在运行的进程中，如果按Ctrl+c，将向程序发出SIGINT信号，编号是2。</p>
<p>采用“kill 进程编号”或“killall 程序名”向程序发出的是SIGTERM信号，编号是15。</p>
<p>采用“kill -9 进程编号”向程序发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p>
<p>设置SIGINT和SIGTERM两个信号的处理函数，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* 本程序演示信号的用法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;收到了信号%d，程序退出。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 在这里添加释放资源的代码</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 程序退出。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">64</span>;ii++) <span class="built_in">signal</span>(ii,SIG_IGN); <span class="comment">// 屏蔽全部的信号</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="built_in">signal</span>(SIGINT,EXIT); <span class="built_in">signal</span>(SIGTERM,EXIT); <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// 每隔一秒执行一次任务。</span></span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;执行了一次任务。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong>                               </p>
<p>不管是用Ctrl+c还是kill，程序都能体面的退出。</p>
<h4 id="6、发送信号"><a href="#6、发送信号" class="headerlink" title="6、发送信号"></a>6、发送信号</h4><p>Linux操作系统提供了kill和killall命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。</p>
<p>函数声明：</p>
<p>int kill(pid_t pid, int sig);</p>
<p>kill函数将参数sig指定的信号给参数pid 指定的进程。</p>
<p>参数pid 有几种情况：</p>
<p>1）pid&gt;0 将信号传给进程号为pid 的进程。</p>
<p>2）pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。</p>
<p>3）pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。</p>
<p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。</p>
<p>返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。</p>
<p>EINVAL：指定的信号码无效（参数 sig 不合法）。</p>
<p>EPERM：权限不够无法传送信号给指定进程。</p>
<p>ESRCH：参数 pid 所指定的进程或进程组不存在。</p>
<h3 id="Linux多进程"><a href="#Linux多进程" class="headerlink" title="Linux多进程"></a>Linux多进程</h3><h4 id="0-1-2号进程"><a href="#0-1-2号进程" class="headerlink" title="0-1-2号进程"></a>0-1-2号进程</h4><p>0号进程加载完系统后演变成1号和2号进程</p>
<p>1号负责启动系统服务，例如网络服务，防火墙，SSH，ftp服务，早期的系统中也叫init进程</p>
<p>2号线程负责所有内核的调度和管理</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412145008695.png" alt="image-20220412145008695"></p>
<h4 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h4><h5 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h5><p>ps -ef可以查看全部的进程信息 加 | 表示管道 再+more的话表示分页，用空格来跳转下一页</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412145253714.png" alt="image-20220412145253714"></p>
<p>UID：启动进程的用户 PID：进程编号 PPID：父进程编号 C：CPU占用率 STIME：进程的开始时间</p>
<p>TTY：启动进程的终端设备（现在不关心了 TIME：进程运行的总时间 CMD：启动进程时执行的命令</p>
<p>1号2号进程他们的父进程是0号，其他的进程的父进程不是一号就是二号</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412145508411.png" alt="image-20220412145508411"></p>
<p>证明：我们用上节课的book来看</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412150103623.png" alt="image-20220412150103623"></p>
<h5 id="获取进程"><a href="#获取进程" class="headerlink" title="获取进程"></a>获取进程</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412145929869.png" alt="image-20220412145929869"></p>
<h4 id="程序中创建进程"><a href="#程序中创建进程" class="headerlink" title="程序中创建进程"></a>程序中创建进程</h4><p>​        fork是分叉的意思</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412150521817.png" alt="image-20220412150521817"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412150718741.png" alt="image-20220412150718741"></p>
<h5 id="验证1、2句"><a href="#验证1、2句" class="headerlink" title="验证1、2句"></a>验证1、2句</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412151142099.png" alt="image-20220412151142099"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412151247485.png" alt="image-20220412151247485"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412151308072.png" alt="image-20220412151308072"></p>
<h5 id="验证3、4句"><a href="#验证3、4句" class="headerlink" title="验证3、4句"></a>验证3、4句</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412151340172.png" alt="image-20220412151340172"></p>
<p>接受了返回值，子进程的返回值是0，父进程的返回值是子进程ID，<strong>调用失败返回 -1</strong></p>
<p>返回-1一般是因为：进程太多、内存不足、系统没有资源</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412151404376.png" alt="image-20220412151404376"></p>
<p>我们可以通过返回值不同的这一特性，来使得后续子进程和父进程单独执行他们自己的代码 </p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412151615031.png" alt="image-20220412151615031"></p>
<h5 id="验证5、6句"><a href="#验证5、6句" class="headerlink" title="验证5、6句"></a>验证5、6句</h5><p>我们可以看到，在子进程中ii不断增大，父进程中明明是同一个进程的变量，却不发生改变</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412151948690.png" alt="image-20220412151948690"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412152018803.png" alt="image-20220412152018803"></p>
<h5 id="第七句"><a href="#第七句" class="headerlink" title="第七句"></a>第七句<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412152844126.png" alt="image-20220412152844126"></h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412152906426.png" alt="image-20220412152906426"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412152924093.png" alt="image-20220412152924093"></p>
<p>​        这里引出了<strong>一个疑问</strong>，为什么，我要成为优秀的程序员。这句话执行了两次呢？按照程序的连续性，应该从fork之后，才会分出两个子进程</p>
<p><strong>分析</strong><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412153058511.png" alt="image-20220412153058511"></p>
<p>​        这一行代码，并没有在打开文件时就写入缓冲区，缓冲区说白了就是<strong>内存</strong>，也就是说fork之前，这一行内容还在内存里，并没有写到文件中去</p>
<p>​        接下来，父进程的数据空间被复制了一份给子进程，数据空间包括了文件缓冲区，所以fork之后，在父进程的数据空间里面有这行代码的内容，而子进程的文件缓冲区也有这个内容，目前，他们还是把内容放在各自的缓冲区里面。当程序fclose关闭时，再把各自缓冲区的内容写入文件</p>
<p>​        现在我们来改一下程序</p>
<p>增加了一句flush的意思为刷新—这里刷新缓冲区，这样处理的话，最终生成的文件只会有一行这个输出</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412153454712.png" alt="image-20220412153454712"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412154220533.png" alt="image-20220412154220533"></p>
<p>现在就是我们预计的结果了</p>
<p>​        这里我们需要强调一点，父进程和子进程的<strong>执行</strong>顺序是不确定的，取决于操作系统的调度算法！</p>
<p>一般来说我们不关心那个跑得更快</p>
<p>​        另外一点强调，虽然进程之间互称子父进程，但其实互不影响，两个进程之间是独立存在的，没有联系</p>
<p>验证结果</p>
<p>​        如果互相影响，父进程就算跑得快也最多执行一行，因为sleep1s</p>
<p>​        另外，最下面那个fclose应该放在pid&gt;0的判断语句里，因为，比如子进程已经fclose了，那么再fclose一次的话可能会导致内存错误（找不到那个进程），我这里太懒了，不再截图了</p>
<p>​        还有就是，我们也看到了pid == 0哪里最下面的aaa 我要xxx未能执行，因为已经关闭了文件</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412154522646.png" alt="image-20220412154522646"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412154856408.png" alt="image-20220412154856408"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412154908093.png" alt="image-20220412154908093"></p>
<h6 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf"></a>fprintf</h6><p>只是对这个函数补充，以前用的少噢</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE * fp;</span><br><span class="line"></span><br><span class="line">  fp = <span class="built_in">fopen</span> (<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s %s %s %d&quot;</span>, <span class="string">&quot;We&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="number">2014</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We are in 2014</span><br></pre></td></tr></table></figure>

<p>现在让我们使用下面的程序查看上面文件的内容：</p>
<p><em>实例</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  fp = <span class="built_in">fopen</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   c = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">   <span class="keyword">if</span>( <span class="built_in">feof</span>(fp) )</span><br><span class="line">   &#123;</span><br><span class="line">     **<span class="keyword">break</span>** ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">  <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>我们让子进程先退出</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412155145290.png" alt="image-20220412155145290"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412155215485.png" alt="image-20220412155215485"></p>
<p>我们看，也就是说2816是父进程，2817是子进程，当子进程先退出，它的标识就变了，但是并没有直接结束进程，要等到父进程也退出了，它才一起走</p>
<h5 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h5><p>简而言之，就是子进程死了，它的进程号还被占用，被存入一个数据结构里面，如果父进程不及时处理，进程号就一直被占用，但系统进程号有限，可能之后会因为没有进程号而不能产生新的进程，这就是僵尸进程的危害</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412155402988.png" alt="image-20220412155402988"></p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ol>
<li><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412155912884.png" alt="image-20220412155912884">忽略SIGCHLD信号，因为子进程退出，内核向父进程发送这个信号，等待处理，如果没收到，自然就没人管咯，父进程不认儿子咯</li>
<li>在父进程中增加等待子进程的代码<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412160144262.png" alt="image-20220412160144262">wait需要包含的头文件<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412160211294.png" alt="image-20220412160211294">wait产生的问题：wait会阻塞父进程，迫使父进程必须接收到子进程结束的信号才能进行下一步的操作，这段时间，父进程就干不了其他事情了</li>
<li><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412165937760.png" alt="image-20220412165937760">在子进程执行结束后，内核给父进程发出这个信号，然后，此时父进程收到了信号（且父进程还在执行sleep10s)就进入func函数，并且sleep的过程被信号软中断强行打断，在函数内定义了int变量sts，后在用sts的地址保存子进程如何退出（地址的每一位，用来保存对应数据啥啥啥的？)，由于得到了sig信号，所以能顺利执行wait，并且退出函数，这个时候，由于父进程在sleep10s之后也没有其他的语句了，因此也退出，如果我们要看到效果，可以再sleep10s之后再加入一句sleep10s，父子两就不会同时退出了</li>
</ol>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h5><p>    对 wait() 的调用会阻止调用进程，直到它的一个子进程退出或收到信号为止。子进程终止后，父进程在wait系统调用指令后继续执行。<br>    子进程可能由于以下原因而终止：</p>
<ul>
<li>调用exit()；</li>
<li>接收到main进程的return值；</li>
<li>接收一个信号（来自操作系统或另一个进程），该信号的默认操作是终止。<br><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzeDA3Mjg=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="comment">// 获取子进程退出状态并返回死掉的子进程ID </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *stat_loc)</span></span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>    如果任何进程有多个子进程，则在调用 wait() 之后，如果没有子进程终止，则父进程必须处于wait状态。<br>    如果只有一个子进程被终止，那么 wait() 返回被终止的子进程的进程ID。<br>    如果多个子进程被终止，那么 wait() 将获取任意子进程并返回该子进程的进程ID。<br>    wait的目的之一是通知父进程子进程结束运行了，它的第二个目的是告诉父进程子进程是如何结束的。wait返回结束的子进程的PID给父进程。父进程<strong>如何知道</strong>子进程是以<strong>何种方式退出</strong>的呢？<br>    答案在传给wait的参数之中。父进程调用wait时<strong>传一个整型变量地址</strong>给函数。内核将子进程的退出状态<strong>保存在这个变量</strong>中。如果子进程调用exit退出，那么内核把exit的返回值存放到这个整数变量中；如果进程是被杀死的，那么内核将信号序号存放在这个变量中。这个整数由<strong>3部分</strong>组成，<strong>8个bit</strong>记录子进程exit值，<strong>7个bit</strong>记录信号序号，<strong>另一个bit</strong>用来指明发生错误并产生了内核映像（core dump）。<br>    如果进程<strong>没有子进程</strong>，那么 wait() 返回“**-1**”。</p>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412170406542.png" alt="image-20220412170406542"></p>
<p>其实孤儿并不孤儿</p>
<p>当父进程走后，子进程会自动挂到1号进程旗下</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220412170519169.png" alt="image-20220412170519169"></p>
<h3 id="服务程序的调度-1"><a href="#服务程序的调度-1" class="headerlink" title="服务程序的调度"></a>服务程序的调度</h3><p>服务程序一般需要把信号关掉（后台程序，只是执行单一的命令的）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413104143053.png" alt="image-20220413104143053"></p>
<h4 id="execl"><a href="#execl" class="headerlink" title="execl()"></a>execl()</h4><p>相关函数：fork, execle, execlp, execv, execve, execvp</p>
<p>头文件：#include &lt;unistd.h&gt;</p>
<p>定义函数：int execl(const char * path, const char * arg, …);</p>
<p>函数说明：execl()用来<strong>执行</strong>参数path 字符串所代表的<strong>文件路径</strong>, 接下来的参数代表<strong>执行该文件时</strong>传递过去的argv(0), argv[1], …, 最后一个参数必须用空指针(NULL)作结束.</p>
<p>返回值：如果执行成功则函数不会返回, 执行失败则直接返回-1, 失败原因存于errno 中.</p>
<p>范例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="string">&quot;/etc/passwd&quot;</span>, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*执行/bin/ls -al /etc/passwd */</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">705</span> Sep <span class="number">3</span> <span class="number">13</span> :<span class="number">52</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<p>execl函数，在执行的过程中，等于是把这个程序终止了，用第一个参数的程序来替代现在正在运行的程序</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413113917507.png" alt="image-20220413113917507"></p>
<p>也就是如下，执行完了aaa以后就停止了，之后从ls里面执行tmp目录下project.tgz</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413114043047.png" alt="image-20220413114043047"></p>
<p>当然，如果我们故意把目录写错，就会继续执行后面的语句，并且execl函数执行错误返回值为**-1**<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413114307585.png" alt="image-20220413114307585"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413114338545.png" alt="image-20220413114338545"></p>
<h4 id="execl-wait"><a href="#execl-wait" class="headerlink" title="execl()+wait()"></a>execl()+wait()</h4><p>exec开头的函数，功能大同小异</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413114723044.png" alt="image-20220413114723044"></p>
<p>每经过fork() == 0时，就执行一次，分支<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413134515767.png" alt="image-20220413134515767"></p>
<p>这里就使得他每间隔10s执行一次ls，对project.tgz 执行-it指令<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413134231961.png" alt="image-20220413134231961"></p>
<p>这样是非常好的，不过也出现了一个问题，我们到底需要兼容多少个参数？难不成一直写判断语句吗</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413134358772.png" alt="image-20220413134358772"></p>
<p>因此，我们引入了<strong>execv()</strong></p>
<h4 id="execv"><a href="#execv" class="headerlink" title="execv()"></a>execv()</h4><p>​        如果说execl必须明确传参列表，那么execv就可以不用明确，但它底层采用的方式却不是分割字符串这个简单，不过最好空格隔开</p>
<p>​        同样，也是用第一个参数，开始来代替这个程序接着走下去</p>
<h5 id="main函数传参"><a href="#main函数传参" class="headerlink" title="main函数传参"></a>main函数传参</h5><p>argc其实无需传入,它自动显示，是你传的加上该程序本身的个数之和，传入的所有都从argv[1]开始存放，argv[0]为当前程序名字</p>
<h6 id="解释一"><a href="#解释一" class="headerlink" title="解释一"></a>解释一</h6><p>这里主要说明带参数的main函数如何使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: %s\r\n&quot;</span>, i+<span class="number">1</span>, argv[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong><br>argc : main函数参数个数，当参数为void的时，argc=1，默认参数为可执行文件名<br>argv : 指针数组，分别指向个参数字符串首地址，其中argv[0]指向默认参数</p>
<p><strong>代码输出结果</strong><br>没有参数默认输出./hello<br>有参数按照参数顺序输出参数<br><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/70.png" alt="在这里插入图片描述"></p>
<h6 id="解释二"><a href="#解释二" class="headerlink" title="解释二"></a>解释二</h6><p>main函数的两个传入参数即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br></pre></td></tr></table></figure>

<p>其中argc为一个整数，表示程序传入参数的个数，其英文全称也即是argument_count,简称为了argc。</p>
<p>而argv为一个存放参数值的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>数组，其英文全称argument_value,它会根据传入的数据，将传入的数据存入该指针数组。如果有空格隔开，则表示传入多个参数。</p>
<p>比如我们允许main时传入了参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main（<span class="string">&quot;TrainData_2015.1.1_2015.2.19.txt&quot;</span>  <span class="string">&quot;input_5flavors_cpu_7days.txt&quot;</span>）</span><br></pre></td></tr></table></figure>

<p>那么传入进到程序中的argc参数则为3了，因为程序会把自己的名字作为第一个参数，示例如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">       argc = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;filename&quot;</span>;<span class="comment">//该主程序所在文件名字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;TrainData_2015.1.1_2015.2.19.txt&quot;</span>;<span class="comment">//是一个字符串指向第一个字母的指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;input_5flavors_cpu_7days.txt&quot;</span>;<span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<p>传入文件名后，我们便可以对文件进行读写操作了。</p>
<h4 id="调度服务代码"><a href="#调度服务代码" class="headerlink" title="调度服务代码"></a>调度服务代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (argc&lt;<span class="number">3</span>) &#123;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Using:./procctl timetvl program argv ...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Example:/project/tools1/bin/procctl 5 /usr/bin/tar zcvf /tmp/tmp.tgz /usr/include\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本程序是服务程序的调度程序，周期性启动服务程序或shell脚本。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timetvl 运行周期，单位：秒。被调度的程序运行结束后，在timetvl秒后会被procctl重新启动。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;program 被调度的程序名，必须使用全路径。\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argvs   被调度的程序的参数。\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;注意，本程序不会被kill杀死，但可以用kill -9强行杀死。\n\n\n&quot;</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//注意，这里不返回，到时候会继续往下执行 </span></span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 关闭信号和IO，本程序不希望被打扰。 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)&#123; </span><br><span class="line">          <span class="built_in">signal</span>(i, SIG_IGN); </span><br><span class="line">          <span class="built_in">close</span>(i); </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管。 </span></span><br><span class="line">  <span class="keyword">if</span>(fork() != <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用SIGCHLD信号，让父进程可以wait子进程退出的状态。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGCHLD, SIG_DFL);<span class="comment">//DFL为默认执行信号</span></span><br><span class="line">  <span class="keyword">char</span> *pargv[argc];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; argc; i++)</span><br><span class="line">          pargv[i<span class="number">-2</span>] = argv[i];</span><br><span class="line"></span><br><span class="line">  pargv[argc<span class="number">-2</span>] = <span class="literal">NULL</span>;<span class="comment">//这两步是将argv[2]之后的命令存入pargv;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;<span class="comment">//再度生成子进程？</span></span><br><span class="line">                  <span class="built_in">execv</span>(argv[<span class="number">2</span>], pargv);<span class="comment">//以第三个参数为路径 PS:仔细看main函数传参就懂得了</span></span><br><span class="line">                  <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//execv成功找到路径，就不执行，不然就退出进程了</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">int</span> status;</span><br><span class="line">                  <span class="built_in">wait</span>(&amp;status);<span class="comment">//第二个参数就是睡眠时间</span></span><br><span class="line">                  <span class="built_in">sleep</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));<span class="comment">//睡眠，atoi为转化为整数</span></span><br><span class="line">                &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、守护进程的实现"><a href="#三、守护进程的实现" class="headerlink" title="三、守护进程的实现"></a>三、守护进程的实现</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413204018998.png" alt="image-20220413204018998"></p>
<h3 id="Linux共享内存"><a href="#Linux共享内存" class="headerlink" title="Linux共享内存"></a>Linux共享内存</h3><p>​        1.查看共享内存，使用命令：<strong>ipcs -m</strong> </p>
<p>​        2.删除共享内存，使用命令：<strong>ipcrm -m [shmid]</strong></p>
<p>​        Linux中，每个内存的内存空间是独立的，互相不能访问，共享内存允许多个内存访问同一块内存，是进程之间共享和传递数据<strong>最高效</strong>的方式</p>
<h4 id="共享内存的操作"><a href="#共享内存的操作" class="headerlink" title="共享内存的操作"></a>共享内存的操作</h4><p>删除的情况是，除非整个项目的服务程序都要停止运行</p>
<p>每个函数失败都是返回**-1**啦</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413204337535.png" alt="image-20220413204337535"></p>
<h5 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h5><p>第一个参数，key，和共享内存的key是一样的意思，第二个参数是信号量的个数，一般取值为1，第三个参数是创建信号量的权限和他的一些标志</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413210642166.png" alt="image-20220413210642166"></p>
<p>0640是八进制表示，0不能少（看项目情况，这个是<strong>权限</strong>，你需要什么，就写什么），后面那部分(IPC_CREAT)表示<strong>共享内存存在</strong>，就获得他的ID，如果不存在，就创建他（这个基本不能改）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413211132748.png" alt="image-20220413211132748"></p>
<p><strong>ipcs -m查看内存段</strong>     nattch指的是被多少个进程链接了</p>
<p>我们也可以解释为什么key要填16进制，因为如果你填十进制，但是他显示默认是16进制，这样不好区分段，无疑增加了工作量</p>
<p>ipcrm -m  xxxshmid   <strong>删除内存段</strong></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413211439677.png" alt="image-20220413211439677"></p>
<h5 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h5><p>第一个参数：共享内存的ID，第二个第三个都可以填0 返回值：共享内存的地址，程序中用指针来指<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413212339485.png" alt="image-20220413212339485">创建一个共享内存结构体，然后来了把当前进程写入共享内存<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413212947240.png" alt="image-20220413212947240"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413213342326.png" alt="image-20220413213342326"></p>
<p>这个过程就证明了，这个内存空间一直存在，因为最后一步已经剥离了进程（创建好以后（0x5005号），所以后面进来执行都是往5005这个内存块写入东西</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413212115327.png" alt="image-20220413212115327"></p>
<h5 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h5><p>一般来说，这个指令不止删除一个功能，但我们通常使用中，只会使用到他的删除功能</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413214028723.png" alt="image-20220413214028723"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413215822771.png" alt="image-20220413215822771"></p>
<p>至少在这个程序里我们不能用，因为我们刚刚创建好，写入，又把它删除没啥意思<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413215732348.png" alt="image-20220413215732348"></p>
<h3 id="Linux信号量"><a href="#Linux信号量" class="headerlink" title="Linux信号量"></a>Linux信号量</h3><p>ipcs -s    <strong>查看</strong>信号量</p>
<p>ipcrm sem xxxxsemid    <strong>删除</strong>信号量</p>
<p>泪目，操作系统的pv操作，居然学到了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413220917736.png" alt="image-20220413220917736"></p>
<h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413221034539.png" alt="image-20220413221034539"></h4><h4 id="信号量形式"><a href="#信号量形式" class="headerlink" title="信号量形式"></a>信号量形式<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413221131344.png" alt="image-20220413221131344"></h4><h4 id="CSEM类"><a href="#CSEM类" class="headerlink" title="CSEM类"></a>CSEM类</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413221332918.png" alt="image-20220413221332918"></p>
<h4 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h4><p>共享内存为什么需要PV？，因为在共享内存正在写入的过程中，是不应该允许别的进程访问他的，这样会导致残缺的数据访问，我们说，这不是我们想要看到的</p>
<p>加锁状态<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413225324848.png" alt="image-20220413225324848"></p>
<p>10s以后<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413225344613.png" alt="image-20220413225344613"></p>
<h4 id="查-删信号量"><a href="#查-删信号量" class="headerlink" title="查/删信号量"></a>查/删信号量</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220413225956431.png" alt="image-20220413225956431"></p>
<h4 id="多个进程同时抢共享内存"><a href="#多个进程同时抢共享内存" class="headerlink" title="多个进程同时抢共享内存"></a>多个进程同时抢共享内存</h4><p>我们先顺序运行 aaa bbb ccc ddd</p>
<p>最开始496s时<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414153322776.png" alt="image-20220414153322776">接着我们会发现，ddd的时候，他已经执行了v操作，此时val不是之前演示的1，而是0，是由于bbb此时已经被唤醒，并且得到了这个信号量<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414153511864.png" alt="image-20220414153511864"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414153557332.png" alt="image-20220414153557332">可以看到，ddd后面<strong>已无等待进程</strong>，所以执行v操作以后，信号量+1，恢复为默认的1<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414153702443.png" alt="image-20220414153702443"></p>
<h4 id="信号量初始化"><a href="#信号量初始化" class="headerlink" title="信号量初始化"></a>信号量初始化</h4><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414154206957.png" alt="image-20220414154206957"></h5><p>初始值为0的话，会使得P操作永远处于等待状态，不过我们可能会想到，先初始化1一个为0的信号量，再把这个信号量的第二个参数设置为1不就好了吗？</p>
<p>​        但如果此时正在有人执行p操作，你这样赋值，不就把锁给解开了吗<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414155355461.png" alt="image-20220414155355461"></p>
<h5 id="创造具体过程"><a href="#创造具体过程" class="headerlink" title="创造具体过程"></a>创造具体过程</h5><p>IPC_EXCL标志写入后，如果信号量已存在，semget这个函数调用后，会调用失败，多进程的程序，一定要考虑他们之间的竞争关系<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414155817992.png" alt="image-20220414155817992"></p>
<p>​        我们假设有两个进程同时获取，那么他们就会同时往后面走（因为此时信号量不存在，两个都能进入第二个if，如果没有这个IPC_EXCl标记，就会导致，他们都能创建信号量，并且都能设置信号量初始值为1，这看上去，就像<strong>各自都持有一把锁</strong>，所以他们的p操作都能够成功<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414160554924.png" alt="image-20220414160554924"></p>
<p><em><strong>两个小细节</strong></em></p>
<ol>
<li>semget的第二个参数是信号量个数，看需要取     semctl的第二个参数是信号量编号，编号是从0开始，也就是说，如果只有一个信号了，他应该填0</li>
<li>信号量的初始值(value)：二值信号量填1，其他信号量看你实际开发中的需求来填</li>
</ol>
<h6 id="PV操作再深入"><a href="#PV操作再深入" class="headerlink" title="PV操作再深入"></a>PV操作再深入</h6><p>我们可以看到，P和V的含义是不同的，但是他们的函数<strong>代码完全相同</strong></p>
<p>​        但是，信号量的值不能够直接加减运算，要用OP函数，OP函数第一个参数是信号量的ID，如果操作的是单个信号量，第二个参数填一个结构体的地址，第三个参数填1，如果操作的是一组信号量，第二个参数填结构体数组的地址，第三个参数填信号量个数</p>
<p>​        我们再来看结构体，第一个参数num是 信号量编号，第二个是op信号量，第三个见下面sem_flg<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414160945688.png" alt="image-20220414160945688">        在实际使用的过程中，<strong>P缺省把信号量的值减一</strong>，<strong>V</strong>缺省把信号量的值<strong>加一</strong>（也就是sem_op = -1 / 1)，当然也可以不用缺省值</p>
<p>sem_flg看情况用<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414161550665.png" alt="image-20220414161550665"></p>
<h6 id="sem-flg用法解析"><a href="#sem-flg用法解析" class="headerlink" title="sem_flg用法解析"></a>sem_flg用法解析<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414162214224.png" alt="image-20220414162214224"></h6><p>​        如果sem_flg设置为SEM_UNDO，例如对同一个信号量，不同进程操控，在进程未全部终止的时候，进程之间使用该信号量，仍然是上一个进程使用之后的结果，换句话说，也就是不会初始化为init的第三个参数=-=。当所有进程结束的时候，操作系统帮我们执行初始化，这种情况，就适用于IO设备，也就是说，适用于<strong>资源有限、不变</strong>的模型</p>
<p>​        另外，再补充一个<strong>UNDO</strong>的细节，在某些情况下<strong>可以避免死锁</strong>，例如，aaa进程，还没用完锁就被杀死了，这个时候有bbb在等着，如果没有UNDO恢复信号量为初始值，那么bbb就死等到生命的结尾，我们说，这也不是我们想要看到的</p>
<p>​        如果sem_fig为0的话就是另外一个情况，也就是 从0开始嘛，不会初始化，该信号量是多少就是多少，不会去管他，随便你们几个进程兄弟伙咋过整，管我求事，这种感觉。适用于<strong>生产者-消费者</strong>模型，动态供给关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CSEM sem; <span class="comment">// 用于给共享内存加锁的信号量 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span>&#123;</span> </span><br><span class="line">        <span class="keyword">int</span> pid;        <span class="comment">// 进程编号 </span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">51</span>];  <span class="comment">// 进程名称 </span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Using:./book1 procname\n&quot;</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125; </span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 共享内存的标志 </span></span><br><span class="line">        <span class="keyword">int</span> shmid; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取或者创建共享内存，键值为0x5005 </span></span><br><span class="line">        <span class="keyword">if</span>((shmid = <span class="built_in">shmget</span>(<span class="number">0x5005</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pid), <span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">			   <span class="built_in">printf</span>(<span class="string">&quot;shmget(0x5005) failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value </span></span><br><span class="line">        <span class="keyword">if</span>(sem.<span class="built_in">init</span>(<span class="number">0x5005</span>) == <span class="literal">false</span>)&#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;sem.init(0x5005) failed\n&quot;</span>);  </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//用于指向共享内存的结构体变量 </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span>* <span class="title">stpid</span> =</span> <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">  	    <span class="comment">//把共享内存连接到当前进程的地址空间 </span></span><br><span class="line">        <span class="comment">//并且处理了未找到情况，需要强转成同一类型才能比对 </span></span><br><span class="line">        <span class="keyword">if</span>((stpid = (struct st_pid *)<span class="built_in">shmat</span>(shmid,<span class="number">0</span>,<span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;shmat failed\n&quot;</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aaa time = %d, val = %d\n&quot;</span>, <span class="built_in">time</span>(<span class="number">0</span>), sem.<span class="built_in">value</span>()); </span><br><span class="line">        sem.<span class="built_in">P</span>();        <span class="comment">//加锁 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bbb time = %d, val = %d\n&quot;</span>, <span class="built_in">time</span>(<span class="number">0</span>), sem.<span class="built_in">value</span>());       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid=%d,name=%s\n&quot;</span>, stpid -&gt; pid, stpid -&gt; name); </span><br><span class="line">        stpid -&gt; pid = <span class="built_in">getpid</span>();        <span class="comment">//进程编号 </span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>); </span><br><span class="line">        <span class="built_in">strcpy</span>(stpid -&gt; name, argv[<span class="number">1</span>]); <span class="comment">//进程名称 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid=%d,name=%s\n&quot;</span>, stpid -&gt; pid, stpid -&gt; name);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ccc time = %d, val = %d\n&quot;</span>, <span class="built_in">time</span>(<span class="number">0</span>), sem.<span class="built_in">value</span>());       </span><br><span class="line">        sem.<span class="built_in">V</span>();        <span class="comment">//解锁 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ddd time = %d, val = %d\n&quot;</span>, <span class="built_in">time</span>(<span class="number">0</span>), sem.<span class="built_in">value</span>()); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//把共享内存从当前进程中分离 </span></span><br><span class="line">        <span class="built_in">shmdt</span>(stpid); </span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h3 id="守护进程实现"><a href="#守护进程实现" class="headerlink" title="守护进程实现"></a>守护进程实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o book1 book1.cpp -I/project/<span class="keyword">public</span> /project/<span class="keyword">public</span>/_public.cpp</span><br></pre></td></tr></table></figure>



<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414163918672.png" alt="image-20220414163918672"></p>
<h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>​        创建一块共享内存，用于存放服务程序心跳信息的结构体数组，每个服务程序启动的时候，会查找共享内存，在共享内存中空白位置把自己的心跳信息写进去，并且程序在运行的过程中，还会不断的把自己的心跳信息写进去，更新到心跳数组中，表示自己是活着，守护进程每隔若干秒，遍历一次共享内存，检查每个服务程序的心跳信息，如果<strong>当前时间 - 最后一次心跳时间 &gt; 超时时间</strong>表示该服务程序没有心跳了，死掉了，终止他，死掉的服务程序被终止后，调度程序将重新启动它<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414164425619.png" alt="image-20220414164425619"></p>
<h5 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414164504510.png" alt="image-20220414164504510"></h5><h6 id="STRCPY"><a href="#STRCPY" class="headerlink" title="STRCPY()"></a>STRCPY()</h6><p>安全的copy封装<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414171445829.png" alt="image-20220414171445829"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414171553599.png" alt="image-20220414171553599"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414171614172.png" alt="image-20220414171614172"></p>
<h5 id="心跳实现"><a href="#心跳实现" class="headerlink" title="心跳实现"></a>心跳实现</h5><ol>
<li>创建/获取共享内存，大小为n * sizeof(struct st_pinfo)</li>
<li>将共享内存连接到当前进程的地址空间<ol>
<li>细节1:这样指到共享内存，我们就可以把它当作结构体数组来用，也可以用地址的运算</li>
<li>共享内存创建后,系统对其初始化，不会有垃圾值,我们可以用for遍历,找到没有用的共享内存，如果有pid为0的，表示为空位置</li>
</ol>
</li>
<li>创建当前进程心跳信息结构体变量，把本进程的信息填进去</li>
<li>更新共享内存中当前进程的心跳时间</li>
<li>把当前进程从共享内存中移去</li>
<li>把共享内存从当前进程中分离</li>
</ol>
<p>更多细节请欣赏下面打了一天的代码=-=</p>
<p>加入了一些异常处理，封装成了类，使之可以被调用，如果需要报告自己的心跳信息，会造对象，会调add方法和uptatime方法足以<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414214832312.png"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414214855707.png" alt="image-20220414214855707"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414214912044.png" alt="image-20220414214912044"></p>
<p>代码里还处理了锁(竞争)的问题，没有空位的问题，id重复的问题……</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUMP_	1000	<span class="comment">// 最大的进程数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHMKEYP_	0x5095	<span class="comment">// 共享内存的key</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEMKEYP_	0x5095 	<span class="comment">// 信号量的key</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程心跳信息的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pid;	<span class="comment">// 进程id</span></span><br><span class="line">	<span class="keyword">char</span> pname[<span class="number">51</span>];	<span class="comment">// 进程名称，可以为空</span></span><br><span class="line">	<span class="keyword">int</span> timeout;	<span class="comment">// 超时时间，单位：秒</span></span><br><span class="line">	<span class="keyword">time_t</span> atime;	<span class="comment">// 最后一次心跳的时间，用整数表示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PActive</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CSEM m_sem;	<span class="comment">// 用于给共享内存枷锁的信号量id</span></span><br><span class="line">	<span class="keyword">int</span> m_shmid;	<span class="comment">// 共享内存的id</span></span><br><span class="line">	<span class="keyword">int</span> m_pos;	<span class="comment">// 当前进程在共享内存进程组中的位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span> *<span class="title">m_shm</span>;</span>	<span class="comment">// 指向共享内存的地址空间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">PActive</span>()&#123;</span><br><span class="line">		m_shmid = <span class="number">-1</span>;	<span class="comment">//共享内存的id</span></span><br><span class="line">		m_pos = <span class="number">-1</span>;	<span class="comment">// 当前进程在共享内存进程组中的位置</span></span><br><span class="line">		m_shm = <span class="number">0</span>;	<span class="comment">//指向共享内存的地址空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">AddPInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> timeout, <span class="keyword">const</span> <span class="keyword">char</span>* pname)</span></span>;	<span class="comment">// 把当前进程的心跳信息加入共享内存中</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">UptATime</span><span class="params">()</span></span>;	<span class="comment">// 更新共享内存中当前进程的心跳时间</span></span><br><span class="line">	~<span class="built_in">PActive</span>();		<span class="comment">// 从共享内存中删除当前进程的心跳记录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Using:./book procname\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建/获取共享内存，大小为n * sizeof(struct st_pinfo)</span></span><br><span class="line">	<span class="keyword">int</span> m_shmid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((m_shmid = <span class="built_in">shmget</span>(SHMKEYP_*<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo), MAXNUMP_, <span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;shmget(%x) failed\n&quot;</span>, MAXNUMP_);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CSEM m_sem;</span><br><span class="line">	<span class="keyword">if</span>(m_sem.<span class="built_in">init</span>(SEMKEYP_) == <span class="literal">false</span>)&#123;<span class="comment">//创建失败，提示信息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;m_sem.init(%x) failed\n&quot;</span>, SEMKEYP_);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span>* <span class="title">m_shm</span>;</span><span class="comment">//细节1:这样指到共享内存，我们就可以把它当作结构体数组来用，也可以用地址的运算</span></span><br><span class="line">	m_shm = (struct st_pinfo*)<span class="built_in">shmat</span>(m_shmid, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//细节2:共享内存创建后,系统对其初始化，不会有垃圾值,我们可以用for遍历,</span></span><br><span class="line">							<span class="comment">//找到没有用的共享内存，如果有pid为0的，表示为空位置</span></span><br><span class="line">	<span class="comment">// 创建当前进程心跳信息结构体变量，把本进程的信息填进去</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span> <span class="title">stpinfo</span>;</span><span class="comment">//创建了结构体变量，所以下面&amp;获取地址</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;stpinfo, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct  st_pinfo));</span><br><span class="line">	stpinfo.pid = <span class="built_in">getpid</span>();		<span class="comment">//进程id</span></span><br><span class="line">	<span class="built_in">STRNCPY</span>(stpinfo.pname, <span class="built_in"><span class="keyword">sizeof</span></span>(stpinfo.pname), argv[<span class="number">1</span>], <span class="number">50</span>);	<span class="comment">// 进程名称</span></span><br><span class="line">	stpinfo.timeout = <span class="number">30</span>;		<span class="comment">// 超时时间，单位：秒</span></span><br><span class="line">	stpinfo.atime = <span class="built_in">time</span>(<span class="number">0</span>);	<span class="comment">// 最后一次心跳的时间/当前时间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">// 进程的id是循环使用的，如果曾经一个进程异常退出，没有清理自己的心跳信息</span></span><br><span class="line">	<span class="comment">// 他的进程信息将残存在共享内存中，不巧的是，当前进程重用了上述进程的id</span></span><br><span class="line">	<span class="comment">// 这样同一个共享内存会存在两个相同的id记录，守护进程检查到残留进程的</span></span><br><span class="line">	<span class="comment">// 心跳时(死了挺久了)，会向进程id发送退出信号，这个信号将误杀当前进程</span></span><br><span class="line">	<span class="comment">// 在共享内存中查找一个空位置，把当前进程的心跳信息存入共享内存中</span></span><br><span class="line">	<span class="comment">// 我们在基于上面文字，做出以下改进，增加下面这个for循环，再用if把下下面的for循环嵌套</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果共享内存中存在当前进程编号，一定是其他进程残留，当前进程重用该位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SHMKEYP_; i++)</span><br><span class="line">		<span class="keyword">if</span>(m_shm[i].pid == stpinfo.pid)&#123;</span><br><span class="line">			m_pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	m_sem.<span class="built_in">P</span>();</span><br><span class="line">	<span class="comment">//一般来说，锁越短越好，我们对有竞争位置的地方加锁就好。</span></span><br><span class="line">	<span class="keyword">if</span>(m_pos == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SHMKEYP_; i++)&#123;</span><br><span class="line">		<span class="comment">//if((m_shm+i)-&gt;pid==0)//找到了一个空位置</span></span><br><span class="line">		<span class="keyword">if</span>(m_shm[i].pid == <span class="number">0</span>)&#123;</span><br><span class="line">			m_pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m_pos == <span class="number">-1</span>)&#123;<span class="comment">//如果没有空位，必然是-1 </span></span><br><span class="line">		<span class="comment">//如果没有空间了，这里也要退出，所以也要解锁，细节！</span></span><br><span class="line">		m_sem.<span class="built_in">V</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;共享内存空间已用完\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把当前进程的心跳信息存入共享内存的进程组中</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_shm+m_pos, &amp;stpinfo, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo));</span><br><span class="line">	<span class="comment">// 写入之后解锁</span></span><br><span class="line">	m_sem.<span class="built_in">V</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="comment">// 更新共享内存中本进程的心跳时间</span></span><br><span class="line">		m_shm[m_pos].atime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把当前进程从共享内存中移去</span></span><br><span class="line">	<span class="comment">//m_shm[m_pos].pid = 0;</span></span><br><span class="line">	<span class="built_in">memset</span>(m_shm + m_pos, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo));</span><br><span class="line">	<span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">	<span class="built_in">shmdt</span>(m_shm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PActive::AddPInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> timeout, <span class="keyword">const</span> <span class="keyword">char</span>* pname)</span></span>&#123;    <span class="comment">// 把当前进程的心跳信息加入共享内存中</span></span><br><span class="line">	<span class="keyword">if</span>(m_pos != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//已经找到位置了不需要再找</span></span><br><span class="line">	<span class="comment">// 创建/获取共享内存，大小为n * sizeof(struct st_pinfo)</span></span><br><span class="line">	<span class="keyword">if</span>((m_shmid = <span class="built_in">shmget</span>(SHMKEYP_*<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo), MAXNUMP_, <span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;shmget(%x) failed\n&quot;</span>, MAXNUMP_);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_sem.<span class="built_in">init</span>(SEMKEYP_) == <span class="literal">false</span>)&#123;<span class="comment">//创建失败，提示信息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;m_sem.init(%x) failed\n&quot;</span>, SEMKEYP_);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">						       <span class="comment">//细节1:这样指到共享内存，我们就可以把它当作结构体数组来用，也可以用地址的运算</span></span><br><span class="line">	m_shm = (struct st_pinfo*)<span class="built_in">shmat</span>(m_shmid, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//细节2:共享内存创建后,系统对其初始化，不会有垃圾值,我们可以用for遍历,</span></span><br><span class="line">							<span class="comment">//找到没有用的共享内存，如果有pid为0的，表示为空位置</span></span><br><span class="line">	<span class="comment">// 创建当前进程心跳信息结构体变量，把本进程的信息填进去</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">st_pinfo</span> <span class="title">stpinfo</span>;</span><span class="comment">//创建了结构体变量，所以下面&amp;获取地址</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;stpinfo, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct  st_pinfo));</span><br><span class="line">	stpinfo.pid = <span class="built_in">getpid</span>();		<span class="comment">//进程id</span></span><br><span class="line">	<span class="built_in">STRNCPY</span>(stpinfo.pname, <span class="built_in"><span class="keyword">sizeof</span></span>(stpinfo.pname), pname, <span class="number">50</span>);	<span class="comment">// 进程名称</span></span><br><span class="line">	stpinfo.timeout = timeout;		<span class="comment">// 超时时间，单位：秒</span></span><br><span class="line">	stpinfo.atime = <span class="built_in">time</span>(<span class="number">0</span>);	<span class="comment">// 最后一次心跳的时间/当前时间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进程的id是循环使用的，如果曾经一个进程异常退出，没有清理自己的心跳信息</span></span><br><span class="line">	<span class="comment">// 他的进程信息将残存在共享内存中，不巧的是，当前进程重用了上述进程的id</span></span><br><span class="line">	<span class="comment">// 这样同一个共享内存会存在两个相同的id记录，守护进程检查到残留进程的</span></span><br><span class="line">	<span class="comment">// 心跳时(死了挺久了)，会向进程id发送退出信号，这个信号将误杀当前进程</span></span><br><span class="line">	<span class="comment">// 在共享内存中查找一个空位置，把当前进程的心跳信息存入共享内存中</span></span><br><span class="line">	<span class="comment">// 我们在基于上面文字，做出以下改进，增加下面这个for循环，再用if把下下面的for循环嵌套</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果共享内存中存在当前进程编号，一定是其他进程残留，当前进程重用该位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SHMKEYP_; i++)</span><br><span class="line">		<span class="keyword">if</span>(m_shm[i].pid == stpinfo.pid)&#123;</span><br><span class="line">			m_pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	m_sem.<span class="built_in">P</span>();</span><br><span class="line">	<span class="comment">//一般来说，锁越短越好，我们对有竞争位置的地方加锁就好。</span></span><br><span class="line">	<span class="keyword">if</span>(m_pos == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SHMKEYP_; i++)&#123;</span><br><span class="line">		<span class="comment">//if((m_shm+i)-&gt;pid==0)//找到了一个空位置</span></span><br><span class="line">		<span class="keyword">if</span>(m_shm[i].pid == <span class="number">0</span>)&#123;</span><br><span class="line">			m_pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m_pos == <span class="number">-1</span>)&#123;<span class="comment">//如果没有空位，必然是-1 </span></span><br><span class="line">		<span class="comment">//如果没有空间了，这里也要退出，所以也要解锁，细节！</span></span><br><span class="line">		m_sem.<span class="built_in">V</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;共享内存空间已用完\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把当前进程的心跳信息存入共享内存的进程组中</span></span><br><span class="line">	<span class="built_in">memcpy</span>(m_shm+m_pos, &amp;stpinfo, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo));</span><br><span class="line">	<span class="comment">// 写入之后解锁</span></span><br><span class="line">	m_sem.<span class="built_in">V</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PActive::UptATime</span><span class="params">()</span></span>&#123;        <span class="comment">// 更新共享内存中当前进程的心跳时间</span></span><br><span class="line">	<span class="keyword">if</span>(m_pos !=<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	m_shm[m_pos].atime = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PActive::~<span class="built_in">PActive</span>()&#123;             <span class="comment">// 从共享内存中删除当前进程的心跳记录</span></span><br><span class="line">		<span class="comment">// 把当前进程从共享内存中移去</span></span><br><span class="line">	<span class="comment">//m_shm[m_pos].pid = 0;</span></span><br><span class="line">	<span class="keyword">if</span>(m_pos !=<span class="number">-1</span>) <span class="built_in">memset</span>(m_shm + m_pos, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_pinfo));</span><br><span class="line">	<span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">	<span class="keyword">if</span>(m_shm != <span class="number">0</span>) <span class="built_in">shmdt</span>(m_shm);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="守护程序实现"><a href="#守护程序实现" class="headerlink" title="守护程序实现"></a>守护程序实现<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220414221543732.png" alt="image-20220414221543732"></h4><h5 id="总体框架呈现"><a href="#总体框架呈现" class="headerlink" title="总体框架呈现"></a>总体框架呈现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序运行日志</span></span><br><span class="line">CLogFile logfile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="comment">// 程序的帮助</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打开日志文件	</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创造/获取共享内存</span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">// 遍历共享内存中全部的进程心跳记录</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXNUMP; i++)&#123;</span><br><span class="line">		<span class="comment">// 如果记录的pid == 0， 表示空记录， continue;</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 如果记录的pid != 0，表示是服务程序的心跳记录</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 向进程发送信号0(不管是否超时)，判断它是否还存在，如果不存在，从共享内存中删除该记录，continue; </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果已经超时</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 发送信号15，尝试正常终止进程</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果进程仍存在，发送信号9，强行终止它</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 从共享内存中删除已超时进程的心跳记录</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序运行日志</span></span><br><span class="line">CLogFile logfile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="comment">// 程序的帮助。</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:./checkproc logfilename\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Example:/project/tools1/bin/procctl 10 /project/tools1/bin/checkproc /tmp/log/checkproc.log\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本程序用于检查后台服务程序是否超时，如果已超时，就终止它。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;注意：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  1）本程序由procctl启动，运行周期建议为10秒。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  2）为了避免被普通用户误杀，本程序应该用root用户启动。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  3）如果要停止本程序，只能用killall -9 终止。\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 忽略全部的信号和IO，不希望程序被干扰。</span></span><br><span class="line">   <span class="comment">// for(int i = 1; i &lt;= 64; i++) signal(i, SIG_IGN);</span></span><br><span class="line">   <span class="built_in">CloseIOAndSignal</span>(<span class="literal">true</span>);<span class="comment">//该函数，缺省false（只关信号不关IO，用true就可以全关</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 打开日志文件	</span></span><br><span class="line">	<span class="keyword">if</span>(logfile.<span class="built_in">Open</span>(argv[<span class="number">1</span>],<span class="string">&quot;a+&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;logfile.Open(%S) failed.\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小、我们自己实现的代码是profo(吴哥的是procinfo)</span></span><br><span class="line">	<span class="comment">// 从心跳机制抄过来的(删改了一些)，用的是用一个共享内存</span></span><br><span class="line">	<span class="keyword">int</span> m_shmid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((m_shmid = <span class="built_in">shmget</span>((<span class="keyword">key_t</span>)SHMKEYP, MAXNUMP*<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_procinfo), <span class="number">0666</span>|IPC_CREAT)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;创建/获取共享内存(%x)失败。\n&quot;</span>, SHMKEYP);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 将共享内存连接到当前进程的地址空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">st_procinfo</span> *<span class="title">shm</span> =</span> (struct st_procinfo *)<span class="built_in">shmat</span>(m_shmid, <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历共享内存中全部的进程心跳记录</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXNUMP; i++)&#123;</span><br><span class="line">		<span class="comment">// 如果记录的pid == 0， 表示空记录， continue;</span></span><br><span class="line">		<span class="keyword">if</span>(shm[i].pid == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果记录的pid != 0，表示是服务程序的心跳记录,程序稳定了就不需要写了，是用于调试</span></span><br><span class="line">		<span class="comment">//logfile.Write(&quot;i = %d, pid = %d, pname = %s, timeout = %d, atime = %d\n&quot;,\</span></span><br><span class="line"><span class="comment">		//	       	i, shm[i].pid, shm[i].pname, shm[i].timeout, shm[i].atime);</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 向进程发送信号0(不管是否超时)，判断它是否还存在，如果不存在，从共享内存中删除该记录，continue; </span></span><br><span class="line">		<span class="keyword">int</span> iret = <span class="built_in">kill</span>(shm[i].pid, <span class="number">0</span>);<span class="comment">//kill，进程不存在会返回-1,进程存在，返回0。</span></span><br><span class="line">		<span class="keyword">if</span>(iret == <span class="number">-1</span>)&#123;</span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;进程pid = %d(%S)已经不存在.\n&quot;</span>, (shm+i) -&gt; pid, (shm + i) -&gt; pname);</span><br><span class="line">			<span class="built_in">memset</span>(shm+i, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_procinfo));<span class="comment">//把结构体清零，细节</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);	<span class="comment">//取当前时间</span></span><br><span class="line">		<span class="comment">// 如果未超时</span></span><br><span class="line">		<span class="keyword">if</span>(now - shm[i].atime &lt; shm[i].timeout) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果已经超时</span></span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;进程pid = %d(%S)已经超时.\n&quot;</span>, (shm+i) -&gt; pid, (shm + i) -&gt; pname);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送信号15，尝试正常终止进程</span></span><br><span class="line">		<span class="built_in">kill</span>(shm[i].pid, <span class="number">15</span>);	<span class="comment">// 发送信号15，尝试正常终止进程</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 每隔1秒判断一次进程是否存在，累计5秒，一般来说，5秒的时间足够让进程退出</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">			iret = <span class="built_in">kill</span>(shm[i].pid, <span class="number">0</span>);	<span class="comment">//向进程发送信号0，判断它是否还存在</span></span><br><span class="line">			<span class="keyword">if</span>(iret == <span class="number">-1</span>) <span class="keyword">break</span>;		<span class="comment">//进程已经退出</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果进程仍存在，发送信号9，强行终止它</span></span><br><span class="line">		<span class="keyword">if</span>(iret == <span class="number">-1</span>)&#123;</span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;进程pid = %d(%S)已经正常终止.\n&quot;</span>, (shm+i) -&gt; pid, (shm + i) -&gt; pname);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">kill</span>(shm[i].pid, <span class="number">9</span>);	<span class="comment">//如果进程仍然存在，就发送信号9，强行终止它</span></span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;进程pid = %d(%s)已经强制终止。\n&quot;</span>, (shm+i)-&gt;pid, (shm+i)-&gt;pname);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从共享内存中删除已超时进程的心跳记录</span></span><br><span class="line">		<span class="built_in">memset</span>(shm+i, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_procinfo));	<span class="comment">// 从共享内存中删除该记录</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把共享内存从当前进程中分离</span></span><br><span class="line">	<span class="built_in">shmdt</span>(shm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="kill-pid-0"><a href="#kill-pid-0" class="headerlink" title="kill(pid, 0)"></a>kill(pid, 0)</h6><p>答案就是</p>
<blockquote>
<p>kill -0 pid 不发送任何信号，但是系统会进行错误检查。</p>
<p>我们可以用来检查一个进程是否存在，存在则 <code>echo $?</code> 返回 <code>0</code> , 不存在返回 <code>1</code></p>
</blockquote>
<p>当然了，各个系统有自己的稍微差异，比如苹果电脑的</p>
<p>存在则什么都不返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -0 536</span><br></pre></td></tr></table></figure>

<p>不存在则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -0 99222</span><br><span class="line">-bash: kill: (99222) - No such process</span><br></pre></td></tr></table></figure>

<h6 id="exit与析构的关系"><a href="#exit与析构的关系" class="headerlink" title="exit与析构的关系"></a>exit与析构的关系</h6><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416132807274.png" alt="image-20220416132807274"></p>
<p>CPactive 对象，如果<strong>放在main</strong>函数中，按下ctrl+c，bbb显示正常退出，但是共享内存(心跳记录)并没有被删除，而把该对象<strong>开成全局</strong>变量，按下ctrl+c，终止ddd，ddd就真的被终止了，这是为什么呢？</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416112229797.png" alt="image-20220416112229797"></p>
<h2 id="四、完善生成测试数据程序"><a href="#四、完善生成测试数据程序" class="headerlink" title="四、完善生成测试数据程序"></a>四、完善生成测试数据程序</h2><ol>
<li>增加生成历史数据文件的功能，为压缩文件和清理文件模块准备历史数据文件。 </li>
<li> 增加信号处理函数，处理2和15的信号 </li>
<li> 解决调用exit函数退出时局部对象没有调用析构函数的问题 </li>
<li> 把心跳信息写入共享内存,（虽然说运行很短，根本不需要使用心跳，但我们现在手里只有他，所以就拿他来玩呗)</li>
</ol>
<h3 id="生成历史数据文件"><a href="#生成历史数据文件" class="headerlink" title="生成历史数据文件"></a>生成历史数据文件</h3><p>首先，我们将crtsurfdata5.cpp里面的，再main函数外面的获取当前时间，移植到main里，并且用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间，当作观测时间。 </span></span><br><span class="line"><span class="built_in">memset</span>(strddatetime,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strddatetime)); </span><br><span class="line"><span class="keyword">if</span>(argc == <span class="number">5</span>) </span><br><span class="line">        <span class="built_in">LocalTime</span>(strddatetime,<span class="string">&quot;yyyymmddhh24miss&quot;</span>); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">STRCPY</span>(strddatetime, <span class="built_in"><span class="keyword">sizeof</span></span>(strddatetime), argv[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>来进行保存历史时间的功能，这样，数据的时间属性就会根据这个来变化，但是文件的时间属性还没有处理好，在这里，我们的开发框架有一个UTime<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416135928671.png" alt="image-20220416135928671"></p>
<p>我们在关闭文件后，用这个包处理文件的时间就OK了</p>
<p>CrtSurFile（分钟观测写入文件）方法里<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416140245388.png" alt="image-20220416140245388"></p>
<h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h3><p>先关闭所有的信号（放在main函数开头）<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416142307615.png" alt="image-20220416142307615"></p>
<p><em><strong>有一个细节</strong></em></p>
<p>​        这里关闭io一定不能放在打开文件的后面，在前面随便哪个位置都可以，道理很简单，如果把代码放在打开以后，他会把日志文件的文件描述符也给关掉<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416142551367.png" alt="image-20220416142551367"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>用了sleep10秒延迟，在关闭写入文件的上面，得以看到结果<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416142937451.png" alt="image-20220416142937451"></p>
<p>运行过程中按ctrl + c </p>
<h3 id="exit未调用析构"><a href="#exit未调用析构" class="headerlink" title="exit未调用析构"></a>exit未调用析构</h3><p>我们来分析一下，回顾我们存文件的过程，是先创造一个临时文件，然后往里面写数据，数据写完，再改名为正式的数据文件，在过程中，如果程序被终止，应该把这些文件都清理掉，清理的工作在析构函数中会执行，但如果析构函数没有调用，就会在磁盘上留下这些临时文件<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416143427332.png" alt="image-20220416143427332"></p>
<p>要解决这个问题很简单，把CFile类的 File变成全局对象<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416144720612.png" alt="image-20220416144720612"></p>
<p>我们可以看出，在最初ctrl + c终止后，会存留tmp临时文件，但是将CFile类开到全局，会自动调用析构函数，所以就把tmp删咯</p>
<h4 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011068702/article/details/52094818">(20条消息) linux之tmp文件夹_码莎拉蒂 .的博客-CSDN博客_linux tmp</a></p>
<p>一个小细节，我注意到了ls /tmp/….   于是乎，我就去搜索了tmp，好家伙</p>
<p>​        查了些资料，/tmp文件夹是存放linux<strong>临时文件</strong>的地方，在Linux系统中/tmp文件夹<strong>里面的文件会被清空</strong>，至于多长时间被清空，如何清空的，可能就不清楚了。</p>
<p>Linux系统中/tmp文件夹里面的文件会被清空，至于多长时间被清空，如何清空的？<br>  今天我们就来剖析一个这两个问题。</p>
<p>在RHEL\CentOS\Fedora\系统中(本次实验是在RHEL6中进行的)</p>
<p>  先来看看tmpwatch这个命令，他的作用就是删除一段时间内不使用的文件（removes files which haven’t been acces<a target="_blank" rel="noopener" href="http://www.jbxue.com/article/1141.html">sed</a> for a period of time）。具体的用法就不多说了，有兴趣的自行研究。我们主要看看和这个命令相关的计划任务文件。<br>  它就是/etc/cron.daily/tmpwatch，我们可以看一下这个文件里面的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">flags=-umc</span><br><span class="line">/usr/sbin/tmpwatch <span class="string">&quot;<span class="variable">$flags</span>&quot;</span> -x /tmp/.X11-unix -x /tmp/.XIM-unix \</span><br><span class="line">        -x /tmp/.font-unix -x /tmp/.ICE-unix -x /tmp/.Test-unix \</span><br><span class="line">        -X <span class="string">&#x27;/tmp/hsperfdata_*&#x27;</span> 10d /tmp</span><br><span class="line">/usr/sbin/tmpwatch <span class="string">&quot;<span class="variable">$flags</span>&quot;</span> 30d /var/tmp</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> /var/&#123;cache/man,catman&#125;/&#123;cat?,X11R6/cat?,<span class="built_in">local</span>/cat?&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$d</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        /usr/sbin/tmpwatch <span class="string">&quot;<span class="variable">$flags</span>&quot;</span> -f 30d <span class="string">&quot;<span class="variable">$d</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 第一行相当于一个标记（参数），第二行就是针对/tmp目录里面排除的目录，第三行，这是对这个/tmp目录的清理，下面的是针对其他目录的清理，就不说了。</p>
<p>  我们就来看/usr/sbin/tmpwatch “$flags” 30d /var/tmp这一行，关键的是这个30d，就是30天的意思，这个就决定了30天清理/tmp下不访问的文件。如果说，你想一天一清理的话，就把这个30d改成1d。</p>
<p>  但有个问题需要注意，如果你设置更短的时间来清理的话，比如说是30分钟、10秒等等，你可以在这个文件中设置，但你会发现重新<a target="_blank" rel="noopener" href="http://www.jbxue.com/diannao/">电脑</a>，他不清理/tmp文件夹里面的内容，这是为什么呢？这就是tmpwatch他所在的位置决定的，他的上层目录是/etc/cron.daily/，而这个目录是第天执行一次计划任务，所以说，你设置了比一天更短的时间，他就不起作用了。这下明白了吧。<br>  所以结论是：<strong>在RHEL6中，系统自动清理/tmp文件夹的默认时限是30天</strong>。</p>
<p>在Debian\Ubuntu系统中（Ubuntu10.10为实验环境）</p>
<p>  在Ubuntu系统中，在/tmp文件夹里面的内容，每次开机都会被清空，如果不想让他自动清理的话，只需要更改rcS文件中的TMPTIME的值。<br>我们看如何来修改<br>sudo vi /etc/default/rcS<br>把<br>TMPTIME=0<br>修改成<br>TMPTIME=-1或者是无限大<br>改成这样的话，系统在重新启动的时候就不会清理你的/tmp目录了。<br>依此类推，如果说要限制多少时间来更改的话，就可以改成相应的数字（本人没有测试，我是这么理解的）。</p>
<h3 id="进程的心跳"><a href="#进程的心跳" class="headerlink" title="进程的心跳"></a>进程的心跳</h3><p>声明一个CPActive PAcitve；</p>
<p>打开文件，每开始写入一次，记录一条心跳<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416145623375.png" alt="image-20220416145623375"></p>
<p>由于每次时间太短了，虽然20s，但肯定用不完，所以心跳的时间就不用更新了</p>
<h3 id="最终数据程序"><a href="#最终数据程序" class="headerlink" title="最终数据程序"></a>最终数据程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	project name: crtsurfdata.cpp 用于生成全国气象站点观测的分钟数据</span></span><br><span class="line"><span class="comment">*	author: jjyaoao</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line">CPActive PActive;	<span class="comment">//进程心跳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全国气象站点参数结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_stcode</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> provname[<span class="number">31</span>]; <span class="comment">//省</span></span><br><span class="line">	<span class="keyword">char</span> obtid[<span class="number">11</span>];	<span class="comment">//站号</span></span><br><span class="line">	<span class="keyword">char</span> obtname[<span class="number">31</span>]; <span class="comment">//站名</span></span><br><span class="line">	<span class="keyword">double</span> lat; <span class="comment">//维度</span></span><br><span class="line">	<span class="keyword">double</span> lon; <span class="comment">//经度</span></span><br><span class="line">	<span class="keyword">double</span> height; <span class="comment">//海拔高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 存放全国气象站点参数的容器。 </span></span><br><span class="line">vector&lt;struct st_stcode&gt; vstcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把站点参数文件加载到vstcode容器中。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LoadSTCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *inifile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全国气象站点分钟观测数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_surfdata</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> obtid[<span class="number">11</span>];      <span class="comment">// 站点代码。</span></span><br><span class="line">  <span class="keyword">char</span> ddatetime[<span class="number">21</span>];  <span class="comment">// 数据时间：格式yyyymmddhh24miss</span></span><br><span class="line">  <span class="keyword">int</span>  t;              <span class="comment">// 气温：单位，0.1摄氏度。</span></span><br><span class="line">  <span class="keyword">int</span>  p;              <span class="comment">// 气压：0.1百帕。</span></span><br><span class="line">  <span class="keyword">int</span>  u;              <span class="comment">// 相对湿度，0-100之间的值。</span></span><br><span class="line">  <span class="keyword">int</span>  wd;             <span class="comment">// 风向，0-360之间的值。</span></span><br><span class="line">  <span class="keyword">int</span>  wf;             <span class="comment">// 风速：单位0.1m/s</span></span><br><span class="line">  <span class="keyword">int</span>  r;              <span class="comment">// 降雨量：0.1mm。</span></span><br><span class="line">  <span class="keyword">int</span>  vis;            <span class="comment">// 能见度：0.1米。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放全国气象站点分钟观测数据的容器</span></span><br><span class="line">vector&lt;struct st_surfdata&gt; vsurfdata;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观测数据的时间</span></span><br><span class="line"><span class="keyword">char</span> strddatetime[<span class="number">21</span>];</span><br><span class="line"><span class="comment">// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CrtsurfData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">CFile File;<span class="comment">//各种文件操作，封装为CFile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CrtSurFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *outpath, <span class="keyword">const</span> <span class="keyword">char</span> *datafmt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CLogFile logfile(10);// 指定日志文件大小为10兆</span></span><br><span class="line">CLogFile logfile;	<span class="comment">// 日志类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;	<span class="comment">// 程序退出和信号2、15的处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((argc != <span class="number">5</span>) &amp;&amp; (argc != <span class="number">6</span>))&#123;<span class="comment">//若传入argc为6，则为指定历史时间,不指定即为当前时间</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Using:./crtsurfdata inifile outpath logfile datafmt [datetime]\n&quot;</span>);<span class="comment">//[]意思即为你可以填，你也可以不填</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Example:/project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\n\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Example:/project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv 20220416123000\n\n&quot;</span>);	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Example:/project/tools1/bin/procctl 60 /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;inifile 全国气象站点参数文件名。\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;outpath 全国气象战点数据文件存放的目录。\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;logfile 本程序运行的日志文件名。\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;datafmt 生成数据文件的格式，支持xml、json和csv三种格式，中间用逗号分隔。\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;datetime 这是一个可选参数，表示生成指定时间的数据和文件\n\n\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 关闭全部的信号和输入输出</span></span><br><span class="line">	<span class="comment">// 设置信号，在shell状态下可用&quot;kill + 进程号&quot; 正常终止进程</span></span><br><span class="line">	<span class="comment">// 但别用&quot;kill -9 + 进程号&quot;强制终止</span></span><br><span class="line">	<span class="built_in">CloseIOAndSignal</span>(<span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">signal</span>(SIGINT, EXIT); <span class="built_in">signal</span>(SIGTERM, EXIT);<span class="comment">//可用数字也可以名称，为了标准这里使用名称（2, 15）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logfile.<span class="built_in">Open</span>(argv[<span class="number">3</span>], <span class="string">&quot;a+&quot;</span>, <span class="literal">false</span>) == <span class="literal">false</span>) &#123;<span class="comment">//打开日志文件失败，程序 退出，没必要继续</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;logfile.Open(%s) failed.\n&quot;</span>, argv[<span class="number">3</span>]); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	logfile.<span class="built_in">Write</span>(<span class="string">&quot;crtsurfdata 开始运行. \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	PActive.<span class="built_in">AddPInfo</span>(<span class="number">20</span>, <span class="string">&quot;crtsurfdata&quot;</span>);<span class="comment">//20秒写入一次，因为太短了，程序，所以心跳的时间就不用更新了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把站点参数文件加载到vstcode容器中</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">LoadSTCode</span>(argv[<span class="number">1</span>]) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 获取当前时间，当作观测时间。</span></span><br><span class="line">  	<span class="built_in">memset</span>(strddatetime,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strddatetime));</span><br><span class="line">	<span class="keyword">if</span>(argc == <span class="number">5</span>)</span><br><span class="line">  		<span class="built_in">LocalTime</span>(strddatetime,<span class="string">&quot;yyyymmddhh24miss&quot;</span>);</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">STRCPY</span>(strddatetime, <span class="built_in"><span class="keyword">sizeof</span></span>(strddatetime), argv[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中 </span></span><br><span class="line">	<span class="built_in">CrtsurfData</span>();</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strstr</span>(argv[<span class="number">4</span>], <span class="string">&quot;xml&quot;</span>)!=<span class="number">0</span>) <span class="built_in">CrtSurFile</span>(argv[<span class="number">2</span>], <span class="string">&quot;xml&quot;</span>);	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strstr</span>(argv[<span class="number">4</span>], <span class="string">&quot;json&quot;</span>)!=<span class="number">0</span>) <span class="built_in">CrtSurFile</span>(argv[<span class="number">2</span>], <span class="string">&quot;json&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strstr</span>(argv[<span class="number">4</span>], <span class="string">&quot;csv&quot;</span>)!=<span class="number">0</span>) <span class="built_in">CrtSurFile</span>(argv[<span class="number">2</span>], <span class="string">&quot;csv&quot;</span>);</span><br><span class="line"></span><br><span class="line">	logfile.<span class="built_in">Write</span>(<span class="string">&quot;crtsurfdata 运行结束。 \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把站点参数文件加载到vstcode容器中。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LoadSTCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *inifile)</span></span>&#123;</span><br><span class="line">	<span class="comment">//打开站点参数文件。</span></span><br><span class="line">	<span class="keyword">if</span>(File.<span class="built_in">Open</span>(inifile, <span class="string">&quot;r&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.Open(%s) failed.\n&quot;</span>, inifile);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> strBuffer[<span class="number">301</span>];</span><br><span class="line">	CCmdStr CmdStr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">st_stcode</span> <span class="title">stcode</span>;</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="comment">//从站点参数文件中读取一行，如果读取完，跳出循环</span></span><br><span class="line">		<span class="comment">//通常情况我们需要初始化字符串，不然可能会有bug，memset strBuffer已经再Fgets里面做了</span></span><br><span class="line">		<span class="keyword">if</span>(File.<span class="built_in">Fgets</span>(strBuffer, <span class="number">300</span>, <span class="literal">true</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 把读到的一行拆分,第三个参数为选择是否删除多余空格</span></span><br><span class="line">		CmdStr.<span class="built_in">SplitToCmd</span>(strBuffer, <span class="string">&quot;,&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">		<span class="comment">//扔掉无效行</span></span><br><span class="line">		<span class="keyword">if</span>(CmdStr.<span class="built_in">CmdCount</span>() != <span class="number">6</span>) <span class="keyword">continue</span>; </span><br><span class="line">		<span class="comment">// 把站点参数的每个数据项保存到站点参数结构体中</span></span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(<span class="number">0</span>, stcode.provname, <span class="number">30</span>); <span class="comment">// 省</span></span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(<span class="number">1</span>, stcode.obtid, <span class="number">10</span>);	 <span class="comment">// 站号</span></span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(<span class="number">2</span>, stcode.obtname, <span class="number">30</span>);  <span class="comment">// 站名</span></span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(<span class="number">3</span>, &amp;stcode.lat);	 <span class="comment">// 纬度</span></span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(<span class="number">4</span>, &amp;stcode.lon);	 <span class="comment">// 经度	</span></span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(<span class="number">5</span>, &amp;stcode.height);	 <span class="comment">// 海拔高度</span></span><br><span class="line">		<span class="comment">// 把站点参数结构体放入站点参数容器</span></span><br><span class="line">		vstcode.<span class="built_in">push_back</span>(stcode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; vstcode.size(); i++)&#123;</span></span><br><span class="line"><span class="comment">		logfile.Write(&quot;provnmae=%s, obtid=%s, obtname=%s\n&quot;,\</span></span><br><span class="line"><span class="comment">				vstcode[i].provname, vstcode[i].obtid, vstcode[i].obtname);</span></span><br><span class="line"><span class="comment">	&#125;        测试程序</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 关闭文件,在析构函数里面已经自动关闭了（makefile）</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CrtsurfData</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 播随机数种子。</span></span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_surfdata</span> <span class="title">stsurfdata</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历气象站点参数的vstcode容器。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vstcode.<span class="built_in">size</span>();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stsurfdata,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_surfdata));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用随机数填充分钟观测数据的结构体。i</span></span><br><span class="line">    <span class="comment">// 随机函数，例如下面第一个rand()%351,就是取0-350的随机函数</span></span><br><span class="line">    <span class="built_in">strncpy</span>(stsurfdata.obtid,vstcode[i].obtid,<span class="number">10</span>); <span class="comment">// 站点代码。</span></span><br><span class="line">    <span class="built_in">strncpy</span>(stsurfdata.ddatetime,strddatetime,<span class="number">14</span>);  <span class="comment">// 数据时间：格式yyyymmddhh24miss</span></span><br><span class="line">    stsurfdata.t=<span class="built_in">rand</span>()%<span class="number">351</span>;       <span class="comment">// 气温：单位，0.1摄氏度</span></span><br><span class="line">    stsurfdata.p=<span class="built_in">rand</span>()%<span class="number">265</span>+<span class="number">10000</span>; <span class="comment">// 气压：0.1百帕</span></span><br><span class="line">    stsurfdata.u=<span class="built_in">rand</span>()%<span class="number">100</span>+<span class="number">1</span>;     <span class="comment">// 相对湿度，0-100之间的值。</span></span><br><span class="line">    stsurfdata.wd=<span class="built_in">rand</span>()%<span class="number">360</span>;      <span class="comment">// 风向，0-360之间的值。</span></span><br><span class="line">    stsurfdata.wf=<span class="built_in">rand</span>()%<span class="number">150</span>;      <span class="comment">// 风速：单位0.1m/s</span></span><br><span class="line">    stsurfdata.r=<span class="built_in">rand</span>()%<span class="number">16</span>;        <span class="comment">// 降雨量：0.1mm</span></span><br><span class="line">    stsurfdata.vis=<span class="built_in">rand</span>()%<span class="number">5001</span>+<span class="number">100000</span>;  <span class="comment">// 能见度：0.1米</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把观测数据的结构体放入vsurfdata容器。</span></span><br><span class="line">    vsurfdata.<span class="built_in">push_back</span>(stsurfdata);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CrtSurFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *outpath, <span class="keyword">const</span> <span class="keyword">char</span> *datafmt)</span></span>&#123;</span><br><span class="line">	CFile File;</span><br><span class="line">	<span class="comment">// 拼接生成数据的文件名，例如：/tmp/idc/surfdata/SURF_ZH_20210629092200_2254.csv</span></span><br><span class="line">	<span class="keyword">char</span> strFileName[<span class="number">301</span>];</span><br><span class="line">	<span class="comment">// 在文件名中加入进程编号，这是为了保证临时文件名不重复(getpid())，这里不加也可以</span></span><br><span class="line">	<span class="built_in">sprintf</span>(strFileName, <span class="string">&quot;%s/SURF_ZH_%s_%d.%s&quot;</span>, outpath, strddatetime, <span class="built_in">getpid</span>(), datafmt);</span><br><span class="line">	<span class="comment">// 打开文件。</span></span><br><span class="line">	<span class="keyword">if</span>(File.<span class="built_in">OpenForRename</span>(strFileName, <span class="string">&quot;w&quot;</span>) == <span class="literal">false</span>)&#123;<span class="comment">//一般是没有磁盘空间或者权限不足</span></span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.OpenForRename(%s) failed.\n&quot;</span>, strFileName);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入第一行标题</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(datafmt, <span class="string">&quot;csv&quot;</span>) == <span class="number">0</span>) File.<span class="built_in">Fprintf</span>(<span class="string">&quot;站点代, 数据时间, 气温, 气压, 相对湿度, 风向, 风速, 降雨量, 能见度\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 遍历存放观测数据的vsurfdata容器。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vsurfdata.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="comment">// 写入一条记录</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(datafmt, <span class="string">&quot;csv&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">			File.<span class="built_in">Fprintf</span>(<span class="string">&quot;%s, %s, %.1f, %.1f, %d, %d, %.1f, %.1f, %.1f\n&quot;</span>,\</span><br><span class="line">				       	vsurfdata[i].obtid, vsurfdata[i].ddatetime, vsurfdata[i].t / <span class="number">10.0</span>, vsurfdata[i].p / <span class="number">10.0</span>, \</span><br><span class="line">					vsurfdata[i].u, vsurfdata[i].wd, vsurfdata[i].wf / <span class="number">10.0</span>, vsurfdata[i].r / <span class="number">10.0</span>, vsurfdata[i].vis / <span class="number">10.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(datafmt, <span class="string">&quot;xml&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	      File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;obtid&gt;%s&lt;/obtid&gt;&lt;ddatetime&gt;%s&lt;/ddatetime&gt;&lt;t&gt;%.1f&lt;/t&gt;&lt;p&gt;%.1f&lt;/p&gt;&quot;</span>\</span><br><span class="line">		           <span class="string">&quot;&lt;u&gt;%d&lt;/u&gt;&lt;wd&gt;%d&lt;/wd&gt;&lt;wf&gt;%.1f&lt;/wf&gt;&lt;r&gt;%.1f&lt;/r&gt;&lt;vis&gt;%.1f&lt;/vis&gt;&lt;endl/&gt;\n&quot;</span>,\</span><br><span class="line">		 vsurfdata[i].obtid,vsurfdata[i].ddatetime,vsurfdata[i].t/<span class="number">10.0</span>,vsurfdata[i].p/<span class="number">10.0</span>,\</span><br><span class="line">		 vsurfdata[i].u,vsurfdata[i].wd,vsurfdata[i].wf/<span class="number">10.0</span>,vsurfdata[i].r/<span class="number">10.0</span>,vsurfdata[i].vis/<span class="number">10.0</span>);</span><br><span class="line">		 </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(datafmt, <span class="string">&quot;json&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&#123;\&quot;obtid\&quot;:\&quot;%s\&quot;,\&quot;ddatetime\&quot;:\&quot;%s\&quot;,\&quot;t\&quot;:\&quot;%.1f\&quot;,\&quot;p\&quot;:\&quot;%.1f\&quot;,&quot;</span>\</span><br><span class="line">				   <span class="string">&quot;\&quot;u\&quot;:\&quot;%d\&quot;,\&quot;wd\&quot;:\&quot;%d\&quot;,\&quot;wf\&quot;:\&quot;%.1f\&quot;,\&quot;r\&quot;:\&quot;%.1f\&quot;,\&quot;vis\&quot;:\&quot;%.1f\&quot;&#125;&quot;</span>,\</span><br><span class="line">			 vsurfdata[i].obtid,vsurfdata[i].ddatetime,vsurfdata[i].t/<span class="number">10.0</span>,vsurfdata[i].p/<span class="number">10.0</span>,\</span><br><span class="line">			 vsurfdata[i].u,vsurfdata[i].wd,vsurfdata[i].wf/<span class="number">10.0</span>,vsurfdata[i].r/<span class="number">10.0</span>,vsurfdata[i].vis/<span class="number">10.0</span>);</span><br><span class="line">		      <span class="keyword">if</span> (i&lt;vsurfdata.<span class="built_in">size</span>()<span class="number">-1</span>) File.<span class="built_in">Fprintf</span>(<span class="string">&quot;,\n&quot;</span>);</span><br><span class="line">		      <span class="keyword">else</span>   File.<span class="built_in">Fprintf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		    &#125;</span><br><span class="line">    </span><br><span class="line">	  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(datafmt,<span class="string">&quot;xml&quot;</span>)==<span class="number">0</span>) File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line">	  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(datafmt,<span class="string">&quot;json&quot;</span>)==<span class="number">0</span>) File.<span class="built_in">Fprintf</span>(<span class="string">&quot;]&#125;\n&quot;</span>);</span><br><span class="line">   &#125;    </span><br><span class="line">	<span class="comment">//sleep(10); //单元测试</span></span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	File.<span class="built_in">CloseAndRename</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UTime</span>(strFileName, strddatetime); <span class="comment">// 修改文件的时间属性</span></span><br><span class="line"></span><br><span class="line">	logfile.<span class="built_in">Write</span>(<span class="string">&quot;生成数据文件%s成功，数据时间%s，记录数%d.\n&quot;</span>, strFileName, strddatetime, vsurfdata.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序退出和信号2、15的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;	</span><br><span class="line">	logfile.<span class="built_in">Write</span>(<span class="string">&quot;程序退出，sig = %d\n\n&quot;</span>, sig);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、开发常用小工具"><a href="#五、开发常用小工具" class="headerlink" title="五、开发常用小工具"></a>五、开发常用小工具</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416153720602.png" alt="image-20220416153720602"></p>
<h3 id="压缩文件模块"><a href="#压缩文件模块" class="headerlink" title="压缩文件模块"></a>压缩文件模块</h3><h4 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序退出和信号2、15的处理函数。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;  </span><br><span class="line">      <span class="comment">// 程序的帮助 </span></span><br><span class="line">      <span class="comment">// 关闭全部的信号和输入输出 </span></span><br><span class="line">      <span class="comment">// 获取文件超时的时间点（人为定义）  </span></span><br><span class="line">      <span class="comment">// 打开目录，CDir.OpenDir() </span></span><br><span class="line">      <span class="comment">// 遍历目录中的文件名 </span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123; </span><br><span class="line">              <span class="comment">// 得到一个文件的信息，CDir.ReadDir() </span></span><br><span class="line">              <span class="comment">// 与超时的时间点比较，如果更早，就需要压缩 </span></span><br><span class="line">              <span class="comment">// 压缩文件，调用操作系统的gzip命令 </span></span><br><span class="line">      &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;程序退出，sig=%d\n\n&quot;</span>, sig); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;                        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关闭信号和IO"><a href="#关闭信号和IO" class="headerlink" title="关闭信号和IO"></a>关闭信号和IO</h4><p>我们通常写代码时需要<strong>先打开</strong>，调试完毕再关，因为我们的printf这些东西，都必须要打开IO才能显示给我们自己</p>
<h4 id="与超时时间点比较"><a href="#与超时时间点比较" class="headerlink" title="与超时时间点比较"></a>与超时时间点比较</h4><p>一个细节，除了判断文件的时间，还要判断文件名，如果文件已经被压缩了，就不需要再压缩了</p>
<h4 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h4><p>1&gt;/dev/null 2&gt;/dev/null是我们常用的写法，也就是，把标准输出(1)和标准错误(2)都定位到空里面去,也就是说，不要输出任何东西</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strCmd[<span class="number">1024</span>];        <span class="comment">// 存放gzip压缩文件的命令 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 得到一个文件的信息，CDir.ReadDir() </span></span><br><span class="line">        <span class="keyword">if</span>(Dir.<span class="built_in">ReadDir</span>() == <span class="literal">false</span>) <span class="keyword">break</span>; </span><br><span class="line">        <span class="comment">// 与超时的时间点比较，如果更早，就需要压缩 </span></span><br><span class="line">        <span class="comment">// matchstr 用于判断一个字符串和另外一个字符串是否匹配，为自己封装 </span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">strcmp</span>(Dir.m_ModifyTime, strTimeOut) &lt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">MatchStr</span>(Dir.m_FileName, <span class="string">&quot;*.gz&quot;</span>) == <span class="literal">false</span>))&#123; </span><br><span class="line">        <span class="comment">// 压缩文件，调用操作系统的gzip命令 </span></span><br><span class="line">        <span class="comment">// 可以使用execl execv 这里我们介绍新的命令system </span></span><br><span class="line">        <span class="comment">// 大写的SNPRINTF函数和小写的sprintf功能是一样的，这样是封装成安全的 </span></span><br><span class="line">        <span class="built_in">SNPRINTF</span>(strCmd, <span class="built_in"><span class="keyword">sizeof</span></span>(strCmd), <span class="number">1000</span>, <span class="string">&quot;/usr/bin/gzip -f %s 1&gt;/dev/null 2&gt;/dev/null&quot;</span>, Dir.m_FullFileName); </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">system</span>(strCmd) == <span class="number">0</span>) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;gzip %s ok.\n&quot;</span>, Dir.m_FullFileName); </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;gzip %s failed.\n&quot;</span>, Dir.m_FullFileName); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<h5 id="CDir"><a href="#CDir" class="headerlink" title="CDir"></a>CDir<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416164036570.png" alt="image-20220416164036570"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416164202724.png" alt="image-20220416164202724"></h5><h6 id="OpenDir"><a href="#OpenDir" class="headerlink" title="OpenDir()"></a>OpenDir()</h6><p>打开目录的指令</p>
<p>​        第一个参数，目录名，第二个参数，文件名匹配的规则(调用了matchstr)，第三个参数，获取文件的最大数量，为什么需要这个参数呢？</p>
<p>​        是因为OpenDir将获取的文件名统一存放在一个容器里(m_vFileName)，如果容器过大,业务处理的时候，可能并不需要一次将全部文件都读取出来，他可以一批一批的处理，一次处理1w个….这样的话就不会对内存造成很大的压力</p>
<p>​        第四个参数，是否打开各级子目录，第五个参数，是否对文件排序（能不排就不排吧）</p>
<h6 id="SetDateFMT"><a href="#SetDateFMT" class="headerlink" title="SetDateFMT()"></a>SetDateFMT()</h6><p>设置时间格式</p>
<p>控制那容器属性那几个的输出格式<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416170202625.png" alt="image-20220416170202625"></p>
<h5 id="MatchStr"><a href="#MatchStr" class="headerlink" title="MatchStr()"></a>MatchStr()<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416170841687.png" alt="image-20220416170841687"></h5><h5 id="system"><a href="#system" class="headerlink" title="system()"></a>system()<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416171122646.png" alt="image-20220416171122646"></h5><p>很简单，就一个参数—-你需要的命令</p>
<p>细节一：system（）也可以调用其它函数，那么他与exec的其它函数有啥区别呢？</p>
<p>​        本质上其实是没有区别的，是否可以取代呢？</p>
<p>​        也不是，exec哪些会更加强大，有更多的功能</p>
<p>细节二：是否需要为压缩文件写心跳信息呢？</p>
<p>​        一般是不用的，原因如下</p>
<ol>
<li>这种程序一般是不会死机的，容易卡死的才需要调度</li>
<li>并不好写，因为有的文件很大，压缩的时间很长，有的短，没有一个合理的超时时间标准</li>
</ol>
<h5 id="压缩文件实现"><a href="#压缩文件实现" class="headerlink" title="压缩文件实现"></a>压缩文件实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序退出和信号2、15的处理函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123; </span><br><span class="line">      <span class="comment">// 程序的帮助</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">4</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//pathname:扫描的目录 matchstr:需要处理这个目录下的什么文件 timeout:时间点，在此之前的会被压缩</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:/project/tools1/bin/gzipfiles pathname matchstr timeout\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Example:/project/tools1/bin/gzipfiles /log/idc \&quot;*.log.20*\&quot; 0.02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        /project/tools1/bin/gzipfiles /tmp/idc/surfdata \&quot;*.xml,*.json\&quot; 0.01\n&quot;</span>);<span class="comment">//下面两行表示需要由调度程序启动</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /log/idc \&quot;*.log.20*\&quot; 0.02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /tmp/idc/surfdata \&quot;*.xml,*.json\&quot; 0.01\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是一个工具程序，用于压缩历史的数据文件或日志文件。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部压缩，timeout可以是小数。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本程序不写日志文件，也不会在控制台输出任何信息。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本程序调用/usr/bin/gzip命令压缩文件。\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">// 关闭全部的信号和输入输出</span></span><br><span class="line">      <span class="comment">// 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span></span><br><span class="line">      <span class="comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span></span><br><span class="line">     <span class="comment">//  CloseIOAndSignal(true); //一般来说开发阶段把这行注释掉，为了方便调试</span></span><br><span class="line">	<span class="built_in">signal</span>(SIGINT, EXIT);  <span class="built_in">signal</span>(SIGTERM, EXIT);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取文件超时的时间点（人为定义） </span></span><br><span class="line">      <span class="keyword">char</span> strTimeOut[<span class="number">21</span>];<span class="comment">// 0-用来转化为负数</span></span><br><span class="line">      <span class="built_in">LocalTime</span>(strTimeOut, <span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>, <span class="number">0</span>-(<span class="keyword">int</span>)(<span class="built_in">atof</span>(argv[<span class="number">3</span>])*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">      <span class="comment">//这里一定要是这种格式的时间（一共就封装了两种缺省，要改自己加源文件）</span></span><br><span class="line"></span><br><span class="line">      CDir Dir;</span><br><span class="line">      <span class="comment">// 打开目录，CDir.OpenDir()</span></span><br><span class="line">  	<span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">10000</span>, <span class="literal">true</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;Dir.OpenDir(%s) failed.\n&quot;</span>, argv[<span class="number">1</span>]); </span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">      <span class="comment">// 遍历目录中的文件名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> strCmd[<span class="number">1024</span>];	<span class="comment">// 存放gzip压缩文件的命令 </span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      		</span><br><span class="line">	      <span class="comment">// 得到一个文件的信息，CDir.ReadDir()</span></span><br><span class="line">	      <span class="keyword">if</span>(Dir.<span class="built_in">ReadDir</span>() == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">	      <span class="comment">// 与超时的时间点比较，如果更早，就需要压缩</span></span><br><span class="line">	      <span class="comment">// matchstr 用于判断一个字符串和另外一个字符串是否匹配，为自己封装</span></span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span>((<span class="built_in">strcmp</span>(Dir.m_ModifyTime, strTimeOut) &lt; <span class="number">0</span>) &amp;&amp; (<span class="built_in">MatchStr</span>(Dir.m_FileName, <span class="string">&quot;*.gz&quot;</span>) == <span class="literal">false</span>))&#123;</span><br><span class="line">	      <span class="comment">// 压缩文件，调用操作系统的gzip命令</span></span><br><span class="line">	      <span class="comment">// 可以使用execl execv 这里我们介绍新的命令system</span></span><br><span class="line">	      <span class="comment">// 大写的SNPRINTF函数和小写的sprintf功能是一样的，这样是封装成安全的</span></span><br><span class="line"></span><br><span class="line">      	<span class="built_in">SNPRINTF</span>(strCmd, <span class="built_in"><span class="keyword">sizeof</span></span>(strCmd),<span class="number">1000</span>, <span class="string">&quot;/usr/bin/gzip -f %s 1&gt;/dev/null 2&gt;/dev/null&quot;</span>, Dir.m_FullFileName);</span><br><span class="line">     	 	<span class="keyword">if</span> (<span class="built_in">system</span>(strCmd) == <span class="number">0</span>) </span><br><span class="line">       			<span class="built_in">printf</span>(<span class="string">&quot;gzip %s ok.\n&quot;</span>, Dir.m_FullFileName);</span><br><span class="line">     	 	<span class="keyword">else</span></span><br><span class="line">       	 		<span class="built_in">printf</span>(<span class="string">&quot;gzip %s failed.\n&quot;</span>, Dir.m_FullFileName);</span><br><span class="line">     		 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;程序退出，sig=%d\n\n&quot;</span>, sig);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清理历史数据文件"><a href="#清理历史数据文件" class="headerlink" title="清理历史数据文件"></a>清理历史数据文件</h3><p>与压缩文件的实现流程，说白了完全相同，只有最后一步不同</p>
<ul>
<li>压缩文件是调用system执行一个操作系统命令</li>
<li>删除文件是调用c语言的一个函数来删除</li>
</ul>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416200255908.png" alt="image-20220416200255908"></h4><h4 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE()"></a>REMOVE()</h4><p>删除不掉，会重复执行一两次删除命令（通常不超过三次，自己定义次数）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416200404662.png" alt="image-20220416200404662"></p>
<h4 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME()"></a>RENAME()<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416200907915.png" alt="image-20220416200907915"></h4><p>优势：</p>
<ol>
<li>如果不存在该文件名，会重复执行一两次改名命令（通常不超过三次，自己定义次数）</li>
<li>在以前不存在，rename就会失败，现在这个，失败了就用MKDIR创建文件，因此减少了很多麻烦</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>仅与压缩在最后核心步骤，以及注解之类的存在差异</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序退出和信号2、15的处理函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123; </span><br><span class="line">      <span class="comment">// 程序的帮助</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">4</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//pathname:扫描的目录 matchstr:需要处理这个目录下的什么文件 timeout:时间点，在此之前的会被压缩</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:/project/tools1/bin/deletefiles /gpathname matchstr timeout\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Example:/project/tools1/bin/deletefiles /log/idc \&quot;*.log.20*\&quot; 0.02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        /project/tools1/bin/deletefiles /tmp/idc/surfdata \&quot;*.xml,*.json\&quot; 0.01\n&quot;</span>);<span class="comment">//下面两行表示需要由调度程序启动</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /log/idc \&quot;*.log.20*\&quot; 0.02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /tmp/idc/surfdata \&quot;*.xml,*.json\&quot; 0.01\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是一个工具程序，用于删除历史的数据文件或日志文件。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部删除，timeout可以是小数。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本程序不写日志文件，也不会在控制台输出任何信息。\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">// 关闭全部的信号和输入输出</span></span><br><span class="line">      <span class="comment">// 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span></span><br><span class="line">      <span class="comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span></span><br><span class="line">       <span class="built_in">CloseIOAndSignal</span>(<span class="literal">true</span>); <span class="comment">//一般来说开发阶段把这行注释掉，为了方便调试</span></span><br><span class="line">	<span class="built_in">signal</span>(SIGINT, EXIT);  <span class="built_in">signal</span>(SIGTERM, EXIT);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取文件超时的时间点（人为定义） </span></span><br><span class="line">      <span class="keyword">char</span> strTimeOut[<span class="number">21</span>];<span class="comment">// 0-用来转化为负数</span></span><br><span class="line">      <span class="built_in">LocalTime</span>(strTimeOut, <span class="string">&quot;yyyy-mm-dd hh24:mi:ss&quot;</span>, <span class="number">0</span>-(<span class="keyword">int</span>)(<span class="built_in">atof</span>(argv[<span class="number">3</span>])*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">      <span class="comment">//这里一定要是这种格式的时间（一共就封装了两种缺省，要改自己加源文件）</span></span><br><span class="line"></span><br><span class="line">      CDir Dir;</span><br><span class="line">      <span class="comment">// 打开目录，CDir.OpenDir()</span></span><br><span class="line">  	<span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">10000</span>, <span class="literal">true</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;Dir.OpenDir(%s) failed.\n&quot;</span>, argv[<span class="number">1</span>]); </span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">      <span class="comment">// 遍历目录中的文件名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> strCmd[<span class="number">1024</span>];	<span class="comment">// 存放gzip压缩文件的命令 </span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      		</span><br><span class="line">	      <span class="comment">// 得到一个文件的信息，CDir.ReadDir()</span></span><br><span class="line">	      <span class="keyword">if</span>(Dir.<span class="built_in">ReadDir</span>() == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">	      <span class="comment">// 与超时的时间点比较，如果更早，就需要删除</span></span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(Dir.m_ModifyTime, strTimeOut) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">     	 	<span class="keyword">if</span> (<span class="built_in">REMOVE</span>(Dir.m_FullFileName) == <span class="literal">true</span>) </span><br><span class="line">       			<span class="built_in">printf</span>(<span class="string">&quot;REMOVE %s ok.\n&quot;</span>, Dir.m_FullFileName);</span><br><span class="line">     	 	<span class="keyword">else</span></span><br><span class="line">       	 		<span class="built_in">printf</span>(<span class="string">&quot;REMOVE %s failed.\n&quot;</span>, Dir.m_FullFileName);</span><br><span class="line">     		 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;程序退出，sig=%d\n\n&quot;</span>, sig);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、服务程序的运行策略"><a href="#六、服务程序的运行策略" class="headerlink" title="六、服务程序的运行策略"></a>六、服务程序的运行策略</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动数据中心后台服务程序的脚本。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################################################</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查服务程序是否超时，配置在/etc/rc.local中由root用户执行。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/project/tools1/bin/procctl 30 /project/tools1/bin/checkproc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩数据中心后台服务程序的备份日志。</span></span><br><span class="line">/project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /log/idc &quot;*.log.20*&quot; 0.02</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成用于测试的全国气象站点观测的分钟数据。</span></span><br><span class="line">/project/tools1/bin/procctl  60 /project/idc1/bin/crtsurfdata /project/idc/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理原始的全国气象站点观测的分钟数据目录/tmp/idc/surfdata中的历史数据文件。</span></span><br><span class="line">/project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /tmp/idc/surfdata &quot;*&quot; 0.02</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止数据中心后台服务程序的脚本。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################################################</span></span></span><br><span class="line"></span><br><span class="line">killall -9 procctl</span><br><span class="line">killall gzipfiles crtsurfdata deletefiles</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line">killall -9 gzipfiles crtsurfdata deletefiles</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416202922360.png" alt="image-20220416202922360"></p>
<p><strong>注意</strong>：这些start，kill脚本，是跟项目，业务相关的，也就是说，我们一定要放在对应的idc1里面，不能乱 放</p>
<p>现在我们知道了如何在命令行启动脚本实现服务程序的运行调度</p>
<p>现在我们来看看如何在操作系统启动的时候把全部的服务程序运行起来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/re.local</span><br></pre></td></tr></table></figure>

<p>Linux下面启动程序的方法比较多，比如说采用系统服务，crontab，但是要启动项目，还是我们这种脚本的方式合适</p>
<h1 id="检查服务程序是否超时"><a href="#检查服务程序是否超时" class="headerlink" title="检查服务程序是否超时"></a>检查服务程序是否超时</h1><p>/project/tools/bin/procctl 30 /project/tools/bin/checkproc</p>
<h1 id="启动数据中心的后台服务程序"><a href="#启动数据中心的后台服务程序" class="headerlink" title="启动数据中心的后台服务程序"></a>启动数据中心的后台服务程序</h1><h2 id="设置开机自启脚本"><a href="#设置开机自启脚本" class="headerlink" title="设置开机自启脚本"></a>设置开机自启脚本</h2><p>1.在/etc/init.d/目录下编写脚本 名字任意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/init.d</span><br><span class="line">touch xxx.sh</span><br></pre></td></tr></table></figure>

<p>复制成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">必须要添加 应该是为了设置 defaults的值 否则不成功#! /bin/sh</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides: OnceDoc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start: <span class="variable">$network</span> <span class="variable">$remote_fs</span> <span class="variable">$local_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop: <span class="variable">$network</span> <span class="variable">$remote_fs</span> <span class="variable">$local_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start: 2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop: 0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: start and stop node</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description: OnceDoc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br></pre></td></tr></table></figure>

<p>添加完上面的文本之后在脚本里写下要自启动的命令，完成后保存。<br>3.给脚本添加执行权限<br><code>chmod 777 xxx.sh</code><br>4.添加进开机自启项<br><code>update-rc.d xxx.sh defaults number</code><br>这里的number是启动顺序，在某些情况下后有先后顺序的要求。</p>
<p>完成后重启。</p>
<p>*移除开机自启：<code>update-rc.d -f xxx remove</code></p>
<p><strong>调度</strong>程序由<strong>root</strong>启动，<strong>服务</strong>程序由j<strong>jyaoao</strong>启动<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220416211120601.png" alt="image-20220416211120601"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;project01.sh&quot;                                                                                                </span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides: OnceDoc</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start: <span class="variable">$network</span> <span class="variable">$remote_fs</span> <span class="variable">$local_fs</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop: <span class="variable">$network</span> <span class="variable">$remote_fs</span> <span class="variable">$local_fs</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start: 2 3 4 5</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop: 0 1 6</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: start and stop node</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Description: OnceDoc</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查服务程序是否超时</span> </span><br><span class="line">/project/tools/bin/procctl 30 /project/tools/bin/checkproc </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动数据中心的后台服务程序</span> </span><br><span class="line">su - jjyaoao -c &quot;/bin/sh /project/idc1/c/start.sh&quot; </span><br></pre></td></tr></table></figure>

<h1 id="第二板块-基于ftp协议的文件传输系统"><a href="#第二板块-基于ftp协议的文件传输系统" class="headerlink" title="第二板块-基于ftp协议的文件传输系统"></a>第二板块-基于ftp协议的文件传输系统</h1><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105514093.png" alt="image-20220417105514093"></p>
<h2 id="章节内容-1"><a href="#章节内容-1" class="headerlink" title="章节内容"></a>章节内容</h2><h3 id="一、ftp基础知识"><a href="#一、ftp基础知识" class="headerlink" title="一、ftp基础知识"></a>一、ftp基础知识<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105248022.png" alt="image-20220417105248022"></h3><h3 id="二、ftp客户端封装"><a href="#二、ftp客户端封装" class="headerlink" title="二、ftp客户端封装"></a>二、ftp客户端封装<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105325146.png" alt="image-20220417105325146"></h3><h3 id="三、文件下载功能实现"><a href="#三、文件下载功能实现" class="headerlink" title="三、文件下载功能实现"></a>三、文件下载功能实现<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105354106.png" alt="image-20220417105354106"></h3><h3 id="四、文件上传功能实现"><a href="#四、文件上传功能实现" class="headerlink" title="四、文件上传功能实现"></a>四、文件上传功能实现<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105422601.png" alt="image-20220417105422601"></h3><h2 id="ftp协议是否过时？"><a href="#ftp协议是否过时？" class="headerlink" title="ftp协议是否过时？"></a>ftp协议是否过时？</h2><p>网上有这么多的缺点例举…..并且说的也没错</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105552661.png" alt="image-20220417105552661"></p>
<p>可这并不表示ftp就会被淘汰</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105704371.png" alt="image-20220417105704371"></p>
<p>就好比，铁门坚固，还有密码，但也不可能取代普通木门一样</p>
<p>​        适用场合不同</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417105805859.png" alt="image-20220417105805859"></p>
<p>ftp不需要考虑这么多的安全性，也不需要这么多的效率，只是用来实现文件的交换而已</p>
<p>技术和应用场景要放在一起讨论，只看缺点不看优点，是不合适的。</p>
<h2 id="ftp查看状态"><a href="#ftp查看状态" class="headerlink" title="ftp查看状态"></a>ftp查看状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd status</span><br></pre></td></tr></table></figure>

<h2 id="一、FTP基础知识"><a href="#一、FTP基础知识" class="headerlink" title="一、FTP基础知识"></a>一、FTP基础知识</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417113343345.png" alt="image-20220417113343345"></p>
<h3 id="FTP简介"><a href="#FTP简介" class="headerlink" title="FTP简介"></a>FTP简介</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417113611421.png" alt="image-20220417113611421"></p>
<h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417114232963.png" alt="image-20220417114232963"></p>
<p>控制连接在整个文件传送过程当中都是保持打开的，ftp客户发出的传送请求，都要通过客户的控制连接来发送给服务器端的控制进程，所以控制连接相当于正式连接之前的一个准备步骤，而数据连接才是文件传输过程中的实际连接</p>
<p>​        服务器端的控制进程接收到客户端的数据传输请求后，才创建一个数据传送进程，并且创建数据连接</p>
<p>​        由于控制连接和数据连接是区分开的，因此我们也说ftp的控制信息是带外传送的</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417115416227.png" alt="image-20220417115416227"></p>
<p>主动：服务器端接收到客户端的端口号，然后建立控制连接关系，服务器端主动告诉客户端，它自己的端口号，这样就是20.</p>
<p>被动：如果是建立联系之后，客户端向服务端发送命令，提出自己的需求，那么服务器端一般就会安排一个＞1024端口号的端口来进行连接。</p>
<h4 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417115634740.png" alt="image-20220417115634740"></h4><h2 id="二、ftp客户端封装-1"><a href="#二、ftp客户端封装-1" class="headerlink" title="二、ftp客户端封装"></a>二、ftp客户端封装</h2><h3 id="基本连接"><a href="#基本连接" class="headerlink" title="基本连接"></a>基本连接</h3><p>在这里我采用的是，用root账户来连接jjyaoao账户，模拟远程访问的过程</p>
<p><a target="_blank" rel="noopener" href="https://github.com/codebrainz/ftplib">https://github.com/codebrainz/ftplib</a></p>
<p>将上面的c代码进一步封装成cpp的库_ftp.h，_ftp.cpp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o ftpclient ftpclient.cpp /project/public/_ftp.cpp /project/public/_public.cpp -I/project/public -L/project/public -lftp -lm -lc</span><br></pre></td></tr></table></figure>

<p>会遇到链接动态库问题=-=</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kex1n/p/5993498.html">linux环境变量LD_LIBRARY_PATH - 小 楼 一 夜 听 春 雨 - 博客园 (cnblogs.com)</a></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417164155864.png" alt="image-20220417164155864"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_ftp.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line">Cftp ftp; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(ftp.<span class="built_in">login</span>(<span class="string">&quot;192.168.211.130:21&quot;</span>, <span class="string">&quot;jjyaoao&quot;</span>, <span class="string">&quot;gh&quot;</span>) == <span class="literal">false</span>)&#123; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(192.168.211.130:21) failed.\n&quot;</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ftp.login(192.168.211.130:21) ok.\n&quot;</span>); </span><br><span class="line"> </span><br><span class="line">        ftp.<span class="built_in">logout</span>(); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试size-time"><a href="#测试size-time" class="headerlink" title="测试size(),time()"></a>测试size(),time()</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417170528688.png" alt="image-20220417170528688"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417170503059.png" alt="image-20220417170503059"></p>
<p>这里他的尺寸是对的，但是时间，=-=，我还不太清楚底层，感觉奇特</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_ftp.h&quot;</span><span class="comment">//仅仅是在上一个的基础上增加了查找时间和尺寸的功能</span></span></span><br><span class="line"></span><br><span class="line">Cftp ftp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ftp.<span class="built_in">login</span>(<span class="string">&quot;192.168.211.130:21&quot;</span>, <span class="string">&quot;jjyaoao&quot;</span>, <span class="string">&quot;gh&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ftp.login(192.168.211.130:21) failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ftp.login(191.168.211.130:21) ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ftp.<span class="built_in">mtime</span>(<span class="string">&quot;/project/public/socket/demo01.cpp&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ftp.mtime(/project/public/socket/demo01.cpp) failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ftp.mtime(/project/public/socket/demo01.cpp) ok, mtime = %d.\n&quot;</span>, ftp.m_mtime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ftp.<span class="built_in">size</span>(<span class="string">&quot;/project/public/socket/demo01.cpp&quot;</span>) == <span class="literal">false</span>)&#123; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ftp.size(/project/public/socket/demo01.cpp) failed.\n&quot;</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ftp.size(/project/public/socket/demo01.cpp) ok, size = %d.\n&quot;</span>, ftp.m_size); </span><br><span class="line"></span><br><span class="line">	ftp.<span class="built_in">logout</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试nlist"><a href="#测试nlist" class="headerlink" title="测试nlist() "></a>测试nlist() <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417171422013.png" alt="image-20220417171422013"></h3><p>意思就是只列出子目录，和文件名，不会列出子目录中的文件名<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417171521986.png" alt="image-20220417171521986"></p>
<p>将socket中的文件名，列到了bbb.lst清单里</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417171542362.png" alt="image-20220417171542362"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Cftp ftp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ftp.<span class="built_in">login</span>(<span class="string">&quot;192.168.211.130:21&quot;</span>, <span class="string">&quot;jjyaoao&quot;</span>, <span class="string">&quot;gh&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ftp.login(192.168.211.130:21) failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ftp.login(191.168.211.130:21) ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ftp.<span class="built_in">mtime</span>(<span class="string">&quot;/project/public/socket/demo01.cpp&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ftp.mtime(/project/public/socket/demo01.cpp) failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ftp.mtime(/project/public/socket/demo01.cpp) ok, mtime = %d.\n&quot;</span>, ftp.m_mtime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ftp.<span class="built_in">size</span>(<span class="string">&quot;/project/public/socket/demo01.cpp&quot;</span>) == <span class="literal">false</span>)&#123; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ftp.size(/project/public/socket/demo01.cpp) failed.\n&quot;</span>); </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ftp.size(/project/public/socket/demo01.cpp) ok, size = %d.\n&quot;</span>, ftp.m_size); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ftp.<span class="built_in">nlist</span>(<span class="string">&quot;/project/public/socket&quot;</span>, <span class="string">&quot;/aaa/bbb.lst&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ftp.nlist(/project/public/socket) failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ftp.nlist(/project/public/socket) ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ftp.<span class="built_in">logout</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h3><h4 id="get-具体细节"><a href="#get-具体细节" class="headerlink" title="get()具体细节"></a>get()具体细节</h4><p>get函数也就是ftp的<strong>下载</strong><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417171907924.png" alt="image-20220417171907924"></p>
<p>​        第一个参数，ftp服务器上的文件名，第二个参数，保存到本地想要采用的文件名，第三个参数，默认true，核对发送前后的时间，以便确保完整发送</p>
<p>​        下载采用临时文件命名的方法，即后缀+ .tmp，完成后才正式改为localfilename（第二个参数）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417172237024.png" alt="image-20220417172237024"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417172318713.png" alt="image-20220417172318713"></p>
<h4 id="put-具体细节"><a href="#put-具体细节" class="headerlink" title="put()具体细节"></a>put()具体细节<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417172504145.png" alt="image-20220417172504145"></h4><p>第一个参数是本地待发送的文件的文件名，第二个参数是想要发送到ftp服务器上显示的文件名，第三个是核对本地与远程文件的大小是否相同<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417172624884.png" alt="image-20220417172624884"></p>
<h4 id="get-put差异"><a href="#get-put差异" class="headerlink" title="get/put差异"></a>get/put差异</h4><p>现在可能我们会有一个疑问，为什么上传的时候，采用的是核对文件的大小，下载却是核对文件的时间</p>
<p>​        一个文件是否发生了变换，只能用文件的时间来判断，不能用文件的大小，比如说把文件aaa改成了文件bbb，大小是一样的，文件的时间就不一样了</p>
<p>​        在上传文件的函数中，服务器上文件的时间，是上传这个动作，也就是调用FtpPut这个函数的时间，这个时间是没有意义的，我们可以保证本地的文件在上传中不会发生变换，所以只要比较服务器中最后收到的文件的大小和本地的文件大小相同就可以了</p>
<h4 id="get-put测试"><a href="#get-put测试" class="headerlink" title="get/put测试"></a>get/put测试</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220417173131294.png" alt="image-20220417173131294"></p>
<p>这样，就在本地下载了_public.cpp， 在本地显示的名字是_public.cpp.bak</p>
<p>也将本地的ftpclient.cpp上传到了ftp服务器，ftp服务器中文件名为ftpclient.cpp.bak</p>
<h2 id="三、文件下载功能实现-1"><a href="#三、文件下载功能实现-1" class="headerlink" title="三、文件下载功能实现"></a>三、文件下载功能实现<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220418124554658.png" alt="image-20220418124554658"></h2><p><em><strong>我们先思考第一步，从简单的功能出发，逐渐拓展到复杂的功能</strong></em></p>
<h3 id="makefile问题分析"><a href="#makefile问题分析" class="headerlink" title="makefile问题分析"></a>makefile问题分析</h3><p>实现之前，我们先编辑makefile文件，出现了一个问题<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220418133804493.png" alt="image-20220418133804493"></p>
<p>听着感觉，好像是libftp.a无法调用啥啥的，好像是个动态库？</p>
<p>我们先来看看.a文件是啥，之前听过，就是对开源框架的封装，将其多个.h.cpp封装到.a里？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">linux .o,.a,.so</span><br><span class="line">        .o,是目标文件,相当于windows中的.obj文件 </span><br><span class="line"></span><br><span class="line">　　.so 为共享库,是shared object,用于动态连接的,相当于windows下的dll </span><br><span class="line"></span><br><span class="line">　　.a为静态库,是好多个.o合在一起,用于静态连接 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">静态函数库</span><br><span class="line">特点：实际上是简单的普通目标文件的集合，在程序执行前就加入到目标程序中。</span><br><span class="line">优点：可以用以前某些程序兼容；描述简单；允许程序员把程序link起来而不用重新编译代码，节省了重新编译代码的时间（该优势目前已不明显）；开发者可以对源代码保密；理论上使用ELF格式的静态库函数生成的代码可以比使用共享或动态函数库的程序运行速度快（大概1%-5%）</span><br><span class="line">生成：使用ar程序（archiver的缩写）。ar rcs my_lib.a f1.o f2.o是把目标代码f1.o和f2.o加入到my_lib.a这个函数库文件中（如果my_lib.a不存在则创建）</span><br><span class="line">使用：用gcc生成可执行代码时，使用-l参数指定要加入的库函数。也可以用ld命令的-l和-L参数。</span><br></pre></td></tr></table></figure>

<p>其次，我就去求助广大网友，最终通过三篇文章解决问题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xinyuan510214/article/details/50457433">(20条消息) CFLAGS详解_xinyuan0214的博客-CSDN博客_cflags编写makefile</a></p>
<p>[(20条消息) Resolve “`.rodata’ can not be used when making a PIE object; recompile with -fPIC”_如月灵的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/hanyulongseucas/article/details/87715186">https://blog.csdn.net/hanyulongseucas/article/details/87715186</a>)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xinyu391/article/details/79013707?spm=1001.2101.3001.6650.2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_default">(20条消息) “recompile with -fPIC” 错误，及c代码引用C++库_xinyu391的博客-CSDN博客</a></p>
<p>解决办法就是，在CFLAG宏里面加入 <strong>-no-pie</strong></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220418134256088.png" alt="image-20220418134256088"></p>
<h3 id="目标一"><a href="#目标一" class="headerlink" title="目标一"></a>目标一</h3><p>目前，我们的目标是把服务器上<strong>某目录的文件全部下载到本地目录</strong>（可以指定文件名的匹配规则）</p>
<p>​        那么，我们现在就要思考，我们需要传入什么参数，首先，肯定需要<strong>日志文件名</strong>，其次，ftp的服务器IP和端口，传输模式，FTP的用户名，密码，服务器存放文件的目录，本地存放文件的目录，下载文件名匹配的规则，都是我们需要的，这样数一数，就已经八个参数了，难道我们要一一对应匹配输入吗？我们说这是不现实的，因此，我们采用一种新的方法，使用xml格式，一方面方便拓展，二方面不会输错，考虑顺序之类的</p>
<p>​        因此，我们现在只需要两个参数，一个是日志文件名（自定义），另外一个就是这个xml格式的文档，将内容放进去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_ftp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CLogFile logfile;</span><br><span class="line">Cftp ftp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序退出和信号2、15的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _help();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="comment">// 小目标，把ftp服务上某目录中的文件下载到本地的目录中</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">		_help();<span class="comment">//帮助文档</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理程序的退出信号，和别的程序一样...</span></span><br><span class="line">	<span class="comment">// 打开日志文件</span></span><br><span class="line">	<span class="comment">// 解析xml，得到程序运行的参数</span></span><br><span class="line">	<span class="comment">// 登录ftp服务器</span></span><br><span class="line">	<span class="comment">// 进入ftp服务器存放文件的目录</span></span><br><span class="line">	<span class="comment">// 调用ftp.nlist()方法列出服务器目录中的文件，结果存放到本地文件中。</span></span><br><span class="line">	<span class="comment">// 把ftp.nlist()方法获取到的list文件加载到容器vfilelist中</span></span><br><span class="line">	<span class="comment">// 遍历容器vfilelist</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlistfile.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="comment">// 调用ftp.get()方法从服务器下载文件。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftp.<span class="built_in">logout</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;程序退出， sig = %d\n\n&quot;</span>, sig);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打开日志文件"><a href="#打开日志文件" class="headerlink" title="打开日志文件"></a>打开日志文件</h4><p>虽然和别的之前的也一样，不过这里我忍不住提一句，由于水平上升了，才有机会在这个地方咬文嚼字。</p>
<p>a+，w+，r+到底是什么意思，知道是文件的读写方式，不过今天去了解了更多</p>
<ul>
<li><p>r：以只读的方式打开文本文件，文件必须存在；</p>
</li>
<li><p>w：以只写的方式打开文本文件，文件<strong>若存在则清空</strong>文件内容<strong>从</strong>文件<strong>头部</strong>开始写，若不存在则根据文件名创建新文件并只写打开；</p>
</li>
<li><p>a：以只写的方式打开文本文件，文件若存在则从<strong>文件尾部以追加</strong>的方式开始写，文件<strong>原来存在的内容不会清除</strong>（<strong>除了</strong>文件尾标志<strong>EOF</strong>），若不存在则根据文件名创建新文件并只写打开；</p>
</li>
<li><p>r+：以可读写的方式打开文本文件，文件必须存在；</p>
</li>
<li><p>w+：以可读写的方式打开文本文件，其他与w一样；</p>
</li>
<li><p>a+：以可读写的方式打开文本文件，其他与a一样；</p>
</li>
<li><p>若打开二进制文件，可在后面加个b注明，其他一样，如rb，r+b（或rb+）。</p>
</li>
</ul>
<h4 id="解析xml"><a href="#解析xml" class="headerlink" title="解析xml"></a>解析xml</h4><p>使用xml，就需要先解析他，开发框架中，有解析的函数<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220418142840573.png" alt="image-20220418142840573"></p>
<p>如果第三个参数是字符串，可以用<strong>第四个参数</strong>指定字符串的长度，<strong>缺省为0</strong>，表示<strong>不限长度</strong>，不限长度就一定要确保value数组空间足够大，否则发生内存溢出的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把xml解析到参数starg结构中。</span></span><br><span class="line"><span class="keyword">bool</span> _xmltoarg(<span class="keyword">char</span> *strxmlbuffer)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;starg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_arg));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;host&quot;</span>,starg.host,<span class="number">30</span>);   <span class="comment">// 远程服务器的IP和端口。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.host)==<span class="number">0</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;host is null.\n&quot;</span>);  <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;mode&quot;</span>,&amp;starg.mode);   <span class="comment">// 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span></span><br><span class="line">  <span class="keyword">if</span> (starg.mode!=<span class="number">2</span>)  starg.mode=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;username&quot;</span>,starg.username,<span class="number">30</span>);   <span class="comment">// 远程服务器ftp的用户名。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.username)==<span class="number">0</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;username is null.\n&quot;</span>);  <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;password&quot;</span>,starg.password,<span class="number">30</span>);   <span class="comment">// 远程服务器ftp的密码。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.password)==<span class="number">0</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;password is null.\n&quot;</span>);  <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;remotepath&quot;</span>,starg.remotepath,<span class="number">300</span>);   <span class="comment">// 远程服务器存放文件的目录。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.remotepath)==<span class="number">0</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;remotepath is null.\n&quot;</span>);  <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;localpath&quot;</span>,starg.localpath,<span class="number">300</span>);   <span class="comment">// 本地文件存放的目录。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.localpath)==<span class="number">0</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;localpath is null.\n&quot;</span>);  <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;matchname&quot;</span>,starg.matchname,<span class="number">100</span>);   <span class="comment">// 待下载文件匹配的规则。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.matchname)==<span class="number">0</span>)</span><br><span class="line">  &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;matchname is null.\n&quot;</span>);  <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;jjyaoao&lt;/username&gt;&lt;password&gt;gh&lt;/password&gt;&lt;localpath&gt;/idcdata/surfdata&lt;/localpath&gt;&lt;remotepath&gt;/tmp/idc/surfdata&lt;/remotepath&gt;&lt;matchname&gt;SURF_ZH*.XML,SURF_ZH*.CSV&lt;/matchname&gt;&lt;listfilename&gt;/idc/data/ftplist/ftpgetfiles_surfdata.list&lt;listfilename&gt;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="存放目录的细节"><a href="#存放目录的细节" class="headerlink" title="存放目录的细节"></a>存放目录的细节</h4><p>有两种写代码的方式：</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419110211202.png" alt="image-20220419110211202"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419110314999.png" alt="image-20220419110314999"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419110401543.png" alt="image-20220419110401543"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419110413530.png" alt="image-20220419110413530"></p>
<p>那我们来想一想，是返回全部路径好，还是相对路径好呢？</p>
<p>答案是：相对路径(只返回文件名)好</p>
<p>有以下几点原因:</p>
<ol>
<li>如果加上绝对路径，则会增加相当一部分没有必要的带宽，从而加重网络的负担<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419110526451.png" alt="image-20220419110526451"></li>
<li>我们调用这个方法，已经往里面传入了保存文件的路径，也就是/tmp/idc/surfdata为我们已经知道的东西，再把它写入，是没有必要的举措</li>
</ol>
<p>所以，我们先通过chdir函数，进入starg.remotepath（目录），再nlist得到当前目录的所有文件+目录名，返回是最好的举措。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/project/tools1/bin/procctl 60 /project/idc1/bin/crtsurfdata /project/idc/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/project/tools1/bin/procctl 60 /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv</span><br></pre></td></tr></table></figure>

<h4 id="下载文件的一个细节"><a href="#下载文件的一个细节" class="headerlink" title="下载文件的一个细节"></a>下载文件的一个细节</h4><p>踩得大坑，还好自己把他调出来了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419162726863.png" alt="image-20220419162726863"></p>
<p>百思不得其解，这咋失败了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419162812307.png" alt="image-20220419162812307"></p>
<p>原来是对细节把握的不到位，有了路径，和文件名，中间得加  /  呀=-=我还以为/是啥新的特殊用法，结果=-=，悟了误了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419162949998.png" alt="image-20220419162949998"></p>
<h3 id="目标扩充"><a href="#目标扩充" class="headerlink" title="目标扩充"></a>目标扩充</h3><p>但是在，实际应用过程中，文件下载功能，不会这么简单……</p>
<p>​        会有更多的需求。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419163321742.png" alt="image-20220419163321742"></p>
<h4 id="删除-备份文件"><a href="#删除-备份文件" class="headerlink" title="删除/备份文件"></a>删除/备份文件</h4><p>​        删除文件十分简单，只需要调用ftp的一个方法，下载文件并备份就稍微复杂一点点,需要额外多一个备份目录，并使用strremotefilenamebak来暂存新的目录名加文件名，然后再运用ftprename函数，对strremotefilename改名，改成这个xxxxxbak，就ok了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419194001015.png" alt="image-20220419194001015"></p>
<h4 id="增量下载文件"><a href="#增量下载文件" class="headerlink" title="增量下载文件"></a>增量下载文件</h4><p>相对困难的是增量下载文件，我们先来理解一下这个过程。</p>
<p>​        首先需要四个vector容器，第<strong>一</strong>个容器，存放<strong>已成功下载</strong>的文件，程序第一次运行的时候，这个容器肯定是空的，第<strong>二</strong>个容器，存放nlist返回的结果，也就是当前服务端的文件，第二个容器中有，第一个容器中没有的文件，放在第四个文件(待下载)，第二个容器中有，第一个容器中也有的放在第三个容器(不需要下载的，方便区分？)</p>
<p>第一个状态：服务端五个文件，客户端没有</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419194354991.png" alt="image-20220419194354991"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419194416782.png" alt="image-20220419194416782"></p>
<p>通过上面规则对比，我们得到第二个状态：<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419194508167.png" alt="image-20220419194508167"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419194559596.png" alt="image-20220419194559596"></p>
<p>第二次运行时的初始状态如下：可能这个时候你就会问了，为什么服务段的1，2不在了呢？这很简单，因为<strong>服务端</strong>也要<strong>清理历史文件</strong>嘛，不然文件越堆越多<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419194653375.png" alt="image-20220419194653375"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419194824387.png" alt="image-20220419194824387"></p>
<p>然后程序把6，7下载下来，3和4<strong>不需要下载</strong>了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419195255270.png" alt="image-20220419195255270"></p>
<p>第三次运行：可能我们现在会对第一个容器产生疑问，我们只需要思考一下，连服务端都没有一和二了，那么客户端还有没有必要保留一和二呢？这就好比游戏，服务端开发已经取消了一个功能，那么制作GUI的客户端自然可以把那个功能相应的按键都删除掉，虽然保留按键也没算错，但这样会让容器变大，让客户以为还有那个功能，这实在是没有必要的。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419195345235.png" alt="image-20220419195345235"></p>
<p>以下是处理细节：PS：ptype == 1 即为访问，然后什么都不做，不删除也不备份<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220419201524280.png" alt="image-20220419201524280"></p>
<p>​        注意，这个意思就是，已下载的3，就是下一次的已下载1，待下载4，就是这一次需要下载的内容，由于我们之前nlist得到的，是存放在vlistfile2里面，所以，为了和后面遍历vlistfile2，读取，下载的过程兼容，我们把待下载容器4里面的内容放入容器2里面，从而使得后面的代码不用修改！</p>
<p>我们把这四步拆解，第一步一个函数LoadOKFile()  第二步CompVector()  第三步WriteToOKFile()  第四步直接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vlistfile2.<span class="built_in">clear</span>();   vlistfile2.<span class="built_in">swap</span>(vlistfile4);</span><br></pre></td></tr></table></figure>

<p>另外，由于我们第三步，已经更新了OKFile，因此，我们还需要加入一条函数语句，当ptype == 1时，把下载成功的文件记录追加到okfilename文件中去，下面这个是执行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/project/tools1/bin/ftpgetfiles /log/idc/ftpgetfiles_surfdata.log &quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;jjyaoao&lt;/username&gt;&lt;password&gt;gh&lt;/password&gt;&lt;localpath&gt;/tmp/client&lt;/localpath&gt;&lt;remotepath&gt;/tmp/server&lt;/remotepath&gt;&lt;matchname&gt;*.txt&lt;/matchname&gt;&lt;listfilename&gt;/idc/data/ftplist/ftpgetfiles_surfdata.list&lt;/listfilename&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt;&lt;okfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.xml&lt;/okfilename&gt;&quot; </span><br></pre></td></tr></table></figure>

<p>313行有问题=-=，现在已经解决，原来是早在167行xmltoarg时，由于copy了一些代码，所以一次性没改完，也就是getxmlbuffer函数的第三个参数我居然还是写的上一个starg.remotepathbak，真是大意了┭┮﹏┭┮<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220420191910256.png" alt="image-20220420191910256"></p>
<h4 id="增量-修改下载文件"><a href="#增量-修改下载文件" class="headerlink" title="增量+修改下载文件"></a>增量+修改下载文件</h4><p>上面已经实现了，仅仅包括新增这种情况，对应应该修改的服务端、客户端文件目录，接下来，我们再包含，加上修改文件内容以后，我们应该考虑的目录情况<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220420192243227.png" alt="image-20220420192243227"></p>
<p>​        简而言之，程序的算法是一样的，但是需要把程序的时间考虑进去 5:50</p>
<p>修改结构体st_arg，加入bool checkmtime，修改帮助文档，修改解析xmltoarg，接着，跟着主函数一步一步看哪里需修改，第一处就是<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220420194436923.png" alt="image-20220420194436923"></p>
<p>第二处………………….将仅仅解析文件名称，变为解析时间和名称<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220420194526053.png" alt="image-20220420194526053"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/project/tools1/bin/ftpgetfiles /log/idc/ftpgetfiles_surfdata.log &quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;jjyaoao&lt;/username&gt;&lt;password&gt;gh&lt;/password&gt;&lt;localpath&gt;/tmp/client&lt;/localpath&gt;&lt;remotepath&gt;/tmp/server&lt;/remotepath&gt;&lt;matchname&gt;*.txt&lt;/matchname&gt;&lt;listfilename&gt;/idc/data/ftplist/ftpgetfiles_surfdata.list&lt;/listfilename&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt;&lt;okfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.xml&lt;/okfilename&gt;&lt;checkmtime&gt;true&lt;/checkmtime&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>于是现在又遇到了新的问题，=-=顺利解决，第一个就是上面这个框框最后那个checkmtime没有反斜线，最开始，被我日志debug找到咯<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220420204726825.png" alt="image-20220420204726825"></p>
<p>后面又遇到一个新的问题，他无法做到更新时间，始终要取得所有的txt文件，于是我发现我compare这个函数里面敲错了，=-=<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220420204812878.png" alt="image-20220420204812878"></p>
<p>最开始没加这个 == 0，不过好在已经发现，越来越理解项目了！</p>
<p>接下来，我们测试了true，理所应该也要测试测试false，因为这已经是最终版本了，最后测试显示，成功实现功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">具体测试步骤：</span><br><span class="line">mkdir /tmp/server</span><br><span class="line">touch /tmp/server/1.txt</span><br><span class="line">touch /tmp/server/2.txt</span><br><span class="line">touch /tmp/server/3.txt</span><br><span class="line">touch /tmp/server/4.txt</span><br><span class="line">touch /tmp/server/5.txt</span><br><span class="line">mkdir /tmp/client</span><br><span class="line">第二次测试，，删除1.txt，新增6.txt，修改2.txt</span><br><span class="line">即可看到结果，（checkmtime)true的话，会重新加载6和2 我们进log就可以看到</span><br><span class="line">false的话，只会重新加载6</span><br></pre></td></tr></table></figure>

<h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>这个程序是一个网络的<strong>客户端</strong>程序，这种程序一定会挂死，不知道什么时候挂死，所以一定要做进程的心跳<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421100846841.png" alt="image-20220421100846841"></p>
<h5 id="那些程序会挂死？"><a href="#那些程序会挂死？" class="headerlink" title="那些程序会挂死？"></a>那些程序会挂死？</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421101051845.png" alt="image-20220421101051845"></p>
<p>为了解决这个问题我们继续引入进程心跳机制……………….<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421101238278.png" alt="image-20220421101238278"></p>
<p>​        我们上一章写的心跳，包括了超时时间，进程名，日志名，但是网络的超时时间难以估计，通常看网络状态，网络好就填小点，网络差就填久一点，也有可能同一个程序启动多个心跳的情况（多个文件下载的任务）</p>
<p>​        所以我们之前的运行参数结构体，还需要加上超时时间和进程名两个参数，接着改动需要加入这两个参数的地方，例如帮助文档，xmltoarg之类，最后扫描一遍项目流程，将可能会消耗时间超时的地方全部都updatetime，不用担心会不会超时的问题，因为本来就一个赋值语句，相比于没有记录到超时位置而言，显然这个浪费是可以接受的</p>
<p>​        最后调试运行，并且把<strong>多年前</strong>那个<strong>调度</strong>程序<strong>无法启动的bug</strong>找到了=-=原因是之前配置clion的时候，因为有idc的存在，而导致无法编译（数据库相关还未配置）所以。。。，现在找到了就好啦！</p>
<h2 id="四、文件上传的功能"><a href="#四、文件上传的功能" class="headerlink" title="四、文件上传的功能"></a>四、文件上传的功能<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421112614027.png" alt="image-20220421112614027"></h2><p>知道了文件下载功能的实现之后，文件上传就变得十分简单。技术流程完全一样，只是有一些细节会发生变化</p>
<h3 id="上传-下载的步骤对比"><a href="#上传-下载的步骤对比" class="headerlink" title="上传 / 下载的步骤对比"></a>上传 / 下载的步骤对比<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421112739681.png" alt="image-20220421112739681"></h3><blockquote>
<p>先把上次已成功上传的文件加载到容器一，然后用dir2获取本地的文件列表，得到容器二，再把容器二与容器一进行对比，不需要上传的文件放到容器三，需要上传的放到容器四</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421112753498.png" alt="image-20220421112753498"></p>
<h3 id="上传和下载的不同："><a href="#上传和下载的不同：" class="headerlink" title="上传和下载的不同："></a>上传和下载的不同：</h3><ol>
<li><p>想要得到文件的目录，在下载，需要分三步走，上传，只需要dir一个指令即可<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421113515211.png" alt="image-20220421113515211"></p>
</li>
<li><p>listfilename不需要了，remotepathbak改为localpathbak，checkmtime不需要了（检查服务端文件的时间）原因有如下</p>
<ul>
<li>checkmtime里面while循环中有这句，意味着程序每运行一次，都需要把服务端目录中全部的时间取回来，如果服务端的目录很多，取时间这个动作要消耗大量的资源，包括客户端等待的时间，网络带宽，还有对服务端造成的压力，如果服务端中的目录不会更新，就应该把checkmtime设置为false，在文件下载的过程中，checkmtime的取值对性能和服务端的压力有很大的影响，但在上传的过程中checkmtime对程序的性能不会有任何的影响（没有任何代价），所以干脆就不要了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421114104282.png" alt="image-20220421114104282"></li>
</ul>
<p>LoadLocalFile的openDir也有一些问题，他的缺省值是获取10000个文件</p>
</li>
</ol>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421131332675.png" alt="image-20220421131332675"></p>
<p>但这里使用的是我们自己的目录（本地目录），所以可以配置脚本来清理，一般就不会有这个问题</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/project/tools1/bin/ftpputfiles /log/idc/ftpputfiles_surfdata.log &quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;jjyaoao&lt;/username&gt;&lt;password&gt;gh&lt;/password&gt;&lt;localpath&gt;/tmp/client&lt;/localpath&gt;&lt;remotepath&gt;/tmp/server&lt;/remotepath&gt;&lt;matchname&gt;*.txt&lt;/matchname&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;localpathbak&gt;/tmp/idc/surfdatabak&lt;/localpathbak&gt;&lt;okfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.xml&lt;/okfilename&gt;&lt;timeout&gt;80&lt;/timeout&gt;&lt;pname&gt;ftpgetfiles_surfdata&lt;/pname&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>给client 1 2 3 4 5.txt   然后开测就好</p>
<p>最后配置start.sh 和killall.sh脚本        我们就已经有三个主要的程序在运行了，生成数据程序，下载程序，上传程序<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421143356108.png" alt="image-20220421143356108"></p>
<h3 id="又一个权限小细节"><a href="#又一个权限小细节" class="headerlink" title="又一个权限小细节"></a>又一个权限小细节</h3><p>好家伙！！不给权限就失败是吧！<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421144136741.png" alt="image-20220421144136741"></p>
<p>给了秒OK，就TM离谱哦，下次果然还是用jjyaoao给root发信号吧！！！！！</p>
<h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421144830124.png" alt="image-20220421144830124"></p>
<ul>
<li><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421145034783.png" alt="image-20220421145034783"></li>
<li>由于应用场景，每个业务系统的负责人的不同的，我们肯定不能在别人的业务系统上创建目录，这样很可能导致被人甩锅</li>
<li>在ftp服务端创建目录会影响效率<ul>
<li>试探打开，不行就创建他，这些没什么代价<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421145051938.png" alt="image-20220421145051938"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421145145690.png" alt="image-20220421145145690"></li>
<li>但在ftp服务端就不一样，每执行一次命令，就需要进行一次网络报文的传输</li>
</ul>
</li>
</ul>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421145243643.png" alt="image-20220421145243643"></p>
<ul>
<li><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421145333271.png" alt="image-20220421145333271"></li>
<li>ftp.get（）设置为false，是因为我们还有checkmtime存在，如果服务端的参数会改变，我们把checkmtime设置为true就可以实现<strong>重传</strong></li>
</ul>
<h1 id="第三板块-基于TCP协议的文件传输系统"><a href="#第三板块-基于TCP协议的文件传输系统" class="headerlink" title="第三板块-基于TCP协议的文件传输系统"></a>第三板块-基于TCP协议的文件传输系统</h1><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421205411572.png" alt="image-20220421205411572"></p>
<p>​        其实根本没咋过掌握，直接就是一个，裸开TCP！！！！冲冲冲</p>
<p>将socket的常用函数，进行封装，变成更佳好用的工具<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421205506867.png" alt="image-20220421205506867"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421205615924.png" alt="image-20220421205615924"></p>
<p> 速度非常快，比FTP快很多倍<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421205647866.png" alt="image-20220421205647866"></p>
<h2 id="一、socket基础知识学习"><a href="#一、socket基础知识学习" class="headerlink" title="一、socket基础知识学习"></a>一、socket基础知识学习</h2><blockquote>
<p>[Socket (一) 基础及接口函数 - Jack王 - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/blogwww/p/9499811.html#:~:text=socket">https://www.cnblogs.com/blogwww/p/9499811.html#:~:text=socket</a> ()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。,connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。 客户端通过调用connect函数来建立与TCP服务器的连接。)</p>
</blockquote>
<p>　Socket,又称为套接字，Socket是计算机网络通信的基本的技术之一。如今大多数基于网络的软件，如浏览器，即时通讯工具甚至是P2P下载都是基于Socket实现的。本篇会介绍一下基于TCP/IP的Socket编程，并且如何写一个客户端/服务器程序。</p>
<p><strong>1.1 背景介绍</strong></p>
<p>　　Unix的输入输出(IO)系统遵循Open-Read-Write-Close这样的操作范本。当一个用户进程进行IO操作之前，它需要调用Open来指定并获取待操作文件或设备读取或写入的权限。一旦IO操作对象被打开，那么这个用户进程可以对这个对象进行一次或多次的读取或写入操作。Read操作用来从IO操作对象读取数据，并将数据传递给用户进程。Write操作用来将用户进程中的数据传递（写入）到IO操作对象。 当所有的Read和Write操作结束之后，用户进程需要调用Close来通知系统其完成对IO对象的使用。<br>　　在Unix开始支持进程间通信（InterProcess Communication，简称IPC）时，IPC的接口就设计得类似文件IO操作接口。在Unix中，一个进程会有一套可以进行读取写入的IO描述符。IO描述符可以是文件，设备或者是通信通道（socket套接字）。一个文件描述符由三部分组成：创建（打开socket），读取写入数据（接受和发送到socket）还有销毁（关闭socket）。<br>　　在Unix系统中，类BSD版本的IPC接口是作为TCP和UDP协议之上的一层进行实现的。消息的目的地使用socket地址来表示。一个socket地址是由网络地址和端口号组成的通信标识符。<br>　　进程间通信操作需要一对儿socket。进程间通信通过在一个进程中的一个socket与另一个进程中得另一个socket进行数据传输来完成。当一个消息执行发出后，这个消息在发送端的socket中处于排队状态，直到下层的网络协议将这些消息发送出去。当消息到达接收端的socket后，其也会处于排队状态，直到接收端的进程对这条消息进行了接收处理。</p>
<p><strong>1.2 TCP和UDP通信</strong><br>　　关于socket编程我们有两种通信协议可以进行选择。一种是数据报通信，另一种就是流通信。<br>　　<strong>1.2.1 数据报通信</strong><br>　　数据报通信协议，就是我们常说的UDP（User Data Protocol 用户数据报协议）。UDP是一种无连接的协议，这就意味着我们每次发送数据报时，需要同时发送本机的socket描述符和接收端的socket描述符。因此，我们在每次通信时都需要发送额外的数据。<br>　　<strong>1.2.2 流通信</strong><br>　　流通信协议，也叫做TCP(Transfer Control Protocol，传输控制协议)。和UDP不同，TCP是一种基于连接的协议。在使用流通信之前，我们必须在通信的一对儿socket之间建立连接。其中一个socket作为服务器进行监听连接请求。另一个则作为客户端进行连接请求。一旦两个socket建立好了连接，他们可以单向或双向进行数据传输。<br>　　我们进行socket编程使用UDP还是TCP呢。选择基于何种协议的socket编程取决于你的具体的客户端-服务器端程序的应用场景。下面我们简单分析一下TCP和UDP协议的<strong>区别</strong>：<br>　　在UDP中，每次发送数据报时，需要附带上本机的socket描述符和接收端的socket描述符。而由于TCP是基于连接的协议，在通信的socket对之间需要在通信之前建立连接，因此会有建立连接这一耗时存在于TCP协议的socket编程。<br>　　在UDP中，数据报数据在大小上有64KB的限制。而TCP中也不存在这样的限制。一旦TCP通信的socket对建立了连接，他们之间的通信就类似IO流，所有的数据会按照接受时的顺序读取。<br>　　UDP是一种不可靠的协议，发送的数据报不一定会按照其发送顺序被接收端的socket接受。然后TCP是一种可靠的协议。接收端收到的包的顺序和包在发送端的顺序是一致的。<br>　　简而言之，TCP适合于诸如远程登录(rlogin,telnet)和文件传输（FTP）这类的网络服务。因为这些需要传输的数据的大小不确定。而UDP相比TCP更加简单轻量一些。UDP用来实现实时性较高或者丢包不重要的一些服务。在局域网中UDP的丢包率都相对比较低。</p>
<p><strong>1.3 C 中的 Socket 编程</strong></p>
<p>　　  说白了<strong>Socket</strong>是应用层与TCP/IP协议族通信的<strong>中间软件抽象层</strong>，它是一组<strong>接口</strong>。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。　　</p>
<p>　　在使用Socket API编程时，需要重点先了解几个API，包括：socket()、bind()、connect()、listen()、accept()、send()和recv()、sendto()和recvfrom()、close()和shutdown()、getpeername()、gethostname()。这些接口是在Winsock2.h 中定义的不是在 MFC 中定义的，只需包含 Winsock2.h 头文件和 Ws2_32.lib 库就可以了。</p>
<p>　　 <strong>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</strong></p>
<p><strong>1.3.1 客户端/服务端模式：</strong></p>
<p>　　在TCP/IP网络应用中，通信的两个进程相互作用的主要模式是客户/服务器模式，即客户端向服务器发出请求，服务器接收请求后，提供相应的服务。<br>　　<strong>服务端</strong>：建立socket，声明自身的端口号和地址并绑定到socket，使用listen打开监听，然后不断用accept去查看是否有连接，如果有，捕获socket，并通过recv获取消息的内容，通信完成后调用closeSocket关闭这个对应accept到的socket，如果不再需要等待任何客户端连接，那么用closeSocket关闭掉自身的socket。<br>　　<strong>客户端</strong>：建立socket，通过端口号和地址确定目标服务器，使用Connect连接到服务器，send发送消息，等待处理，通信完成后调用closeSocket关闭socket。</p>
<p><strong>1.3.2 编程步骤</strong><br>　　（1）服务端<br>　　　　加载套接字库，创建套接字（WSAStartup()/socket()）;<br>　　　　绑定套接字到一个IP地址和一个端口上（bind()）;<br>　　　　将套接字设置为监听模式等待连接请求（listen()）；<br>　　　　请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）；<br>　　　　用返回的套接字和客户端进行通信（send()/recv()）；<br>　　　　返回，等待另一个连接请求；<br>　　　　关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；<br>　　（2）客户端<br>　　　　加载套接字库，创建套接字（WSAStartup()/socket()）；<br>　　　　向服务器发出连接请求（connect()）；<br>　　　　和服务器进行通信（send()/recv()）；<br>　　　　关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；</p>
<p>1.4 函数详解</p>
<p>1.4.1 socket()函数<br>　　int socket(int protofamily, int type, int protocol);//返回sockfd</p>
<p>　　sockfd是描述符。socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。<br>   创建socket的时候，可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：<br>　　protofamily：即协议域，又称为协议族（family）。常用的协议族有，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。<br>　　type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。<br>　　protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。<br>　　注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。<br>　　当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<p>1.4.2 bind()函数<br>　　正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。<br>　　int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>　　函数的三个参数分别为：<br>　　sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。<br>　　addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。<br>　　addrlen：对应的是地址的长度。<br>　　通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<p>1.4.3 listen()、connect()函数<br>　　如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。<br>　　int listen(int sockfd, int backlog);<br>　　int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>　　listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。<br>　　connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<p>1.4.4 accept()函数<br>　　TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。<br>　　int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); //返回连接connect_fd<br>　　参数sockfd<br>　　参数sockfd就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。<br>　　参数addr<br>　　这是一个结果参数，它用来接受一个返回值，这返回值指定客户端的地址，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。<br>　　参数len</p>
<p>　　它也是结果的参数，用来接受上述addr的结构的大小的，它指明addr结构所占有的字节个数。同样的，它也可以被设置为NULL。<br>　　如果accept成功返回，则服务器与客户已经正确建立连接了，此时服务器通过accept返回的套接字来完成与客户的通信。<br>注意：<br>   accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。<br>此时我们需要区分两种套接字，<br>    监听套接字: 监听套接字正如accept的参数sockfd，它是监听套接字，在调用listen函数之后，是服务器开始调用socket()函数生成的，称为监听socket描述字(监听套接字)<br>    连接套接字：一个套接字会从主动连接的套接字变身为一个监听套接字；而accept函数返回的是已连接socket描述字(一个连接套接字)，它代表着一个网络已经存在的点点连接。</p>
<p>　　一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。<br>   自然要问的是：为什么要有两种套接字？原因很简单，如果使用一个描述字的话，那么它的功能太多，使得使用很不直观，同时在内核确实产生了一个这样的新的描述字。<br>　　连接套接字socketfd_new 并没有占用新的端口与客户端通信，依然使用的是与监听套接字socketfd一样的端口号</p>
<p>1.4.5 read()、write()等函数<br>　　万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：<br>　　read()/write()；recv()/send()；readv()/writev()；recvmsg()/sendmsg()；recvfrom()/sendto()</p>
<p>　　int send( SOCKET s, const char FAR *buf, int len,int flags);<br>　　不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。<br>　　客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。<br>　　该函数的第一个参数指定发送端套接字描述符；第二个参数指明一个存放应用程序要发送数据的缓冲区；第三个参数指明实际要发送的数据的字节数；第四个参数一般置0。<br>　　int recv( SOCKET s, char FAR *buf, int len,int flags);<br>　　不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。<br>　　该函数的第一个参数指定接收端套接字描述符；第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；第三个参数指明buf的长度；第四个参数一般置0。</p>
<p>1.4.6 close()函数<br>　　在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br>　　#include &lt;unistd.h&gt;<br>　　int close(int fd);<br>　　close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。<br>　　注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h2 id="二、封装socket的API"><a href="#二、封装socket的API" class="headerlink" title="二、封装socket的API"></a>二、封装socket的API</h2><ul>
<li>解决了TCP报文粘包/分包的问题</li>
<li>封装socket的常用函数</li>
</ul>
<h3 id="粘包和分包"><a href="#粘包和分包" class="headerlink" title="粘包和分包"></a>粘包和分包</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421211036969.png" alt="image-20220421211036969"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yxh168/articles/9033311.html">TCP Socket的粘包和分包的处理 - 不懂123 - 博客园 (cnblogs.com)</a></p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>  在进行TCP Socket开发时,都需要处理数据包粘包和分包的情况.实际上解决该问题很简单,在应用层下,定义一个协议:消息头部+消息长度+消息正文即可。</p>
<h4 id="分包和粘包"><a href="#分包和粘包" class="headerlink" title="分包和粘包"></a>分包和粘包</h4><p>​     分包：发送方发送字符串”helloworld”，接收方却接收到了两个字符串”hello”和”world”</p>
<p>​     粘包：发送方发送两个字符串”hello”+”world”，接收方却一次性接收到了”helloworld”</p>
<p>  socket环境有以上问题,但是TCP传输数据能保证几点:</p>
<p>​    \1. 顺序不变,例如发送方发送hello,接收方也一定顺序接收到hello,这个是TCP协议承诺的,因此这点成为我们解决分包,黏包问题的关键.</p>
<p>​    \2. 分割的包中间不会插入其他数据</p>
<p> 因此如果要使用socket通信,就一定要自己定义一份协议.目前最常用的协议标准是:消息头部(包头)+消息长度+消息正文</p>
<h4 id="TCP分包的原理"><a href="#TCP分包的原理" class="headerlink" title="TCP分包的原理"></a>TCP分包的原理</h4><p>  <strong>TCP</strong>是以<strong>段</strong>（Segment）为单位<strong>发送</strong>数据的,建立TCP链接后,有一个最大消息长度（MSS）.如果<strong>应用层数据包超过MSS</strong>,就会把应用层<strong>数据包拆分</strong>,分成两个段来发送.</p>
<p>  这个时候接收端的<strong>应用层</strong>就<strong>要拼接</strong>这两个TCP包，才能正确处理数据。</p>
<p>  相关的,<strong>路由器</strong>有一个<strong>MTU</strong>（ 最大传输单元）一般是<strong>1500</strong>字节,除去IP头部20字节,留给TCP的就只有MTU-20字节。所以一般TCP的<strong>MSS</strong>为MTU-20=<strong>1460</strong>字节</p>
<p>  当应用层数据<strong>超过1460</strong>字节时,TCP会<strong>分多个数据包来发送</strong>。</p>
<h4 id="TCP粘包的原理"><a href="#TCP粘包的原理" class="headerlink" title="TCP粘包的原理"></a>TCP粘包的原理</h4><p>   TCP为了提高网络的利用率,会使用一个叫做Nagle的算法.该算法是指,<strong>发送端</strong>即使有要<strong>发送的数据</strong>,如果<strong>很少</strong>的话,会<strong>延迟发送</strong>.</p>
<p>​    如果<strong>应用层</strong>给TCP<strong>传送数据很快</strong>的话,就会把<strong>两个应用层数据包</strong>“粘”在一起,TC<strong>P最后只发一个</strong>TCP数据包给接收端.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​        我们可以看见TCP发出去才会出现分包（接受数据那是应用层的事，我们默认应用层发送过来的都是完整数据呗），而粘包会出现在TCP接受数据和发送数据，分别是不同的原因</p>
<h3 id="TCP的分包与粘包原理的简单理解"><a href="#TCP的分包与粘包原理的简单理解" class="headerlink" title="TCP的分包与粘包原理的简单理解"></a>TCP的分包与粘包原理的简单理解</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903886881292302">TCP的分包与粘包原理简单理解 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p><strong>1，首先我们来看看粘包的图解：如下图:</strong></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/16bdb22f6d213081tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="img"></p>
<p><strong>为什么会出现粘包</strong></p>
<blockquote>
<p>假如说，我们要发送两个hello数据，一个hello占5个，TCP假如一次性传输能存10个。当第一个hello存进TCP的缓存区里面时，没有存满，还剩下5个空位，这时第二个hello过来，刚好占满剩下的5个，然后这两个hello就粘在一起了，变成hellohello了。</p>
</blockquote>
<p><strong>2，再来看看分包的图解：如下图：</strong></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/16bdb2ce44c9caebtplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="img"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/16bdb37eed3194b7tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="img"></p>
<p><strong>为什么会出现分包</strong></p>
<blockquote>
<p>假如说，我们要发送两个hello，一个hello要占领5个空位。但是TCP的一个包只有4个空位，。这时第一个hello传过来，只存了hell，剩下的e被分到下一个包存储，所以就成了分包。</p>
</blockquote>
<p><strong>3，在哪种情况下会出现分包与粘包：</strong></p>
<ul>
<li>1，<strong>要发送</strong>的数据<strong>大于</strong>TCP<strong>发送缓冲区剩余空间大小</strong>，将会发生分包。</li>
<li>2，<strong>待发送</strong>数据<strong>大于MSS</strong>（最大报文长度），TCP在传输前将进行分包。</li>
<li>3，要<strong>发送</strong>的数据<strong>小于</strong>TCP<strong>发送缓冲区的大小</strong>，TCP<strong>将多次写入</strong>缓冲区的数据<strong>一次发送</strong>出去，将会发生粘包。</li>
<li>4，<strong>接收数据</strong>端的<strong>应用层****没</strong>有<strong>及时读取</strong>接收缓冲区中的数据，<strong>将发生粘包</strong>。</li>
</ul>
<p>自定义协议</p>
<h4 id="解决粘包-分包常用方式："><a href="#解决粘包-分包常用方式：" class="headerlink" title="解决粘包/分包常用方式："></a>解决粘包/分包常用方式：</h4><blockquote>
<p>两种方式</p>
</blockquote>
<ul>
<li>1，定义数据包包头，包头众包含数据完整包的长度，接收端接收到数据后，通过读取包头的长度字段，便知道每一个数据包的实际长度了。</li>
</ul>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/16bdb3bf56d406datplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="img"></p>
<blockquote>
<p>比如说，将原数据加密，在密文前面加上包头，即：[包头]+[密文]。 包头=[密文长度+加密方式+…]</p>
</blockquote>
<ul>
<li>2，数据包之间设置边界</li>
</ul>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/16bdb3c4b8b5dea0tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="img"></p>
<h3 id="粘包实践"><a href="#粘包实践" class="headerlink" title="粘包实践"></a>粘包实践</h3><p>/project/public/socket中的demo03(客户端)和demo04(服务端）<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421213304334.png" alt="image-20220421213304334"></p>
<h3 id="TCP协议的保证"><a href="#TCP协议的保证" class="headerlink" title="TCP协议的保证"></a>TCP协议的保证<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421213504042.png" alt="image-20220421213504042"></h3><h3 id="解决粘包方案"><a href="#解决粘包方案" class="headerlink" title="解决粘包方案"></a>解决粘包方案</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421213538464.png" alt="image-20220421213538464"></p>
<h4 id="采用ASCII码"><a href="#采用ASCII码" class="headerlink" title="采用ASCII码"></a>采用ASCII码</h4><p>在实际开发一般不采用，因为有一个问题，当报文的内容超过四个9的时候，四个字节就存不下了，用整型变量存放报文长度就不会存在这个问题</p>
<h4 id="采用整型"><a href="#采用整型" class="headerlink" title="采用整型"></a>采用整型</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421213738372.png" alt="image-20220421213738372"></p>
<p>在开发框架中，tcpwrite和tcpread解决了这两个问题(粘包分包)</p>
<h4 id="TcpWrite-TcpRead"><a href="#TcpWrite-TcpRead" class="headerlink" title="TcpWrite()/TcpRead()"></a>TcpWrite()/TcpRead()</h4><p>TcpWrite和TcpRead的使用一定要成双成对的，也就是协议需要大家一起来遵守</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421214301425.png" alt="image-20220421214301425"></p>
<h5 id="TcpWrite"><a href="#TcpWrite" class="headerlink" title="TcpWrite()"></a>TcpWrite()</h5><p>​        我们看这几行代码，注意我们发送缓冲区数据是采用的封装的Writen函数，而不是send（c自带），原因就是因为socket有缓冲区，读和写两个缓冲区，并且大小有限，如果这时候的写缓冲区快满了，还有五百字节可以用，调用send函数，只能成功写入500字节，剩下的要等缓冲区空闲了才能再次写入。Writen循环调用send函数，直到全部数据被成功的发送，返回true，如果发送过程中tcp断开了或者其他原因，返回false<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220421222419772.png" alt="image-20220421222419772"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向socket的对端发送数据。</span></span><br><span class="line"><span class="comment">// sockfd：可用的socket连接。</span></span><br><span class="line"><span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line"><span class="comment">// ibuflen：待发送数据的字节数，如果发送的是ascii字符串，ibuflen填0或字符串的长度，</span></span><br><span class="line"><span class="comment">//          如果是二进制流数据，ibuflen为二进制数据块的大小。</span></span><br><span class="line"><span class="comment">// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TcpWrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sockfd,<span class="keyword">const</span> <span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> ibuflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sockfd==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ilen=<span class="number">0</span>;  <span class="comment">// 报文长度。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ibuflen==0，就认为需要发送的是字符串，报文长度为字符串的长度。</span></span><br><span class="line">  <span class="keyword">if</span> (ibuflen==<span class="number">0</span>) ilen=<span class="built_in">strlen</span>(buffer);</span><br><span class="line">  <span class="keyword">else</span> ilen=ibuflen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ilenn=<span class="built_in">htonl</span>(ilen);    <span class="comment">// 把报文长度转换为网络字节序。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> TBuffer[ilen+<span class="number">4</span>];     <span class="comment">// 发送缓冲区。</span></span><br><span class="line">  <span class="built_in">memset</span>(TBuffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(TBuffer));  <span class="comment">// 清区发送缓冲区。</span></span><br><span class="line">  <span class="built_in">memcpy</span>(TBuffer,&amp;ilenn,<span class="number">4</span>);           <span class="comment">// 把报文长度拷贝到缓冲区。</span></span><br><span class="line">  <span class="built_in">memcpy</span>(TBuffer+<span class="number">4</span>,buffer,ilen);      <span class="comment">// 把报文内容拷贝到缓冲区。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送缓冲区中的数据。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Writen</span>(sockfd,TBuffer,ilen+<span class="number">4</span>) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Writen"><a href="#Writen" class="headerlink" title="Writen()"></a>Writen()</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向已经准备好的socket中写入数据。</span></span><br><span class="line"><span class="comment">// sockfd：已经准备好的socket连接。</span></span><br><span class="line"><span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line"><span class="comment">// n：待发送数据的字节数。</span></span><br><span class="line"><span class="comment">// 返回值：成功发送完n字节的数据后返回true，socket连接不可用返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Writen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sockfd,<span class="keyword">const</span> <span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nLeft=n;  <span class="comment">// 剩余需要写入的字节数。</span></span><br><span class="line">  <span class="keyword">int</span> idx=<span class="number">0</span>;    <span class="comment">// 已成功写入的字节数。</span></span><br><span class="line">  <span class="keyword">int</span> nwritten; <span class="comment">// 每次调用send()函数写入的字节数。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(nLeft &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="keyword">if</span> ( (nwritten=<span class="built_in">send</span>(sockfd,buffer+idx,nLeft,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;      </span><br><span class="line">    </span><br><span class="line">    nLeft=nLeft-nwritten;</span><br><span class="line">    idx=idx+nwritten;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="TcpRead"><a href="#TcpRead" class="headerlink" title="TcpRead()"></a>TcpRead()</h5><p>​        先不管超时时间，我们来梳理一下过程，把传进来的字节数初始化为0(注意用了解引用*)意思是我们把这个传进来的int型的地址里面的内容改为了0，接着使用Readn()接受sockfd中的内容，用ibuflen来当做容器接受好像不一定必须转为char，但反正recv底层接受的是void*，最后，在将报文长度的  网络字节序 用ntohl转换为主机字节序，最后在buffer接受得到报文的实际内容，同样用readn()函数，读sockfd里面的，读取的长度设置为ibuflen的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收socket的对端发送过来的数据。</span></span><br><span class="line"><span class="comment">// sockfd：可用的socket连接。</span></span><br><span class="line"><span class="comment">// buffer：接收数据缓冲区的地址。</span></span><br><span class="line"><span class="comment">// ibuflen：本次成功接收数据的字节数。</span></span><br><span class="line"><span class="comment">// itimeout：接收等待超时的时间，单位：秒，-1-不等待；0-无限等待；&gt;0-等待的秒数。</span></span><br><span class="line"><span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时；2）socket连接已不可用。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TcpRead</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buffer,<span class="keyword">int</span> *ibuflen,<span class="keyword">const</span> <span class="keyword">int</span> itimeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sockfd==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果itimeout&gt;0，表示需要等待itimeout秒，如果itimeout秒后还没有数据到达，返回false。</span></span><br><span class="line">  <span class="keyword">if</span> (itimeout&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line">    fds.fd=sockfd;</span><br><span class="line">    fds.events=POLLIN;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">poll</span>(&amp;fds,<span class="number">1</span>,itimeout*<span class="number">1000</span>) &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果itimeout==-1，表示不等待，立即判断socket的缓冲区中是否有数据，如果没有，返回false。</span></span><br><span class="line">  <span class="keyword">if</span> (itimeout==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line">    fds.fd=sockfd;</span><br><span class="line">    fds.events=POLLIN;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">poll</span>(&amp;fds,<span class="number">1</span>,<span class="number">0</span>) &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (*ibuflen) = <span class="number">0</span>;  <span class="comment">// 报文长度变量初始化为0。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先读取报文长度，4个字节。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Readn</span>(sockfd,(<span class="keyword">char</span>*)ibuflen,<span class="number">4</span>) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  (*ibuflen)=<span class="built_in">ntohl</span>(*ibuflen);  <span class="comment">// 把报文长度由网络字节序转换为主机字节序。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再读取报文内容。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Readn</span>(sockfd,buffer,(*ibuflen)) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Readn"><a href="#Readn" class="headerlink" title="Readn()"></a>Readn()</h6><p>函数反复调用recv，如果读取的过程中接收到n个子杰，函数返回true，如果读写的过程中发送了意外，比如说：连接被断开，那么就返回false</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从已经准备好的socket中读取数据。</span></span><br><span class="line"><span class="comment">// sockfd：已经准备好的socket连接。</span></span><br><span class="line"><span class="comment">// buffer：接收数据缓冲区的地址。</span></span><br><span class="line"><span class="comment">// n：本次接收数据的字节数。</span></span><br><span class="line"><span class="comment">// 返回值：成功接收到n字节的数据后返回true，socket连接不可用返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Readn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nLeft=n;  <span class="comment">// 剩余需要读取的字节数。</span></span><br><span class="line">  <span class="keyword">int</span> idx=<span class="number">0</span>;    <span class="comment">// 已成功读取的字节数。</span></span><br><span class="line">  <span class="keyword">int</span> nread;    <span class="comment">// 每次调用recv()函数读到的字节数。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nLeft &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (nread=<span class="built_in">recv</span>(sockfd,buffer+idx,nLeft,<span class="number">0</span>)) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    idx=idx+nread;</span><br><span class="line">    nLeft=nLeft-nread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="socket封装函数"><a href="#socket封装函数" class="headerlink" title="socket封装函数"></a>socket封装函数</h3><p>我们先来看看一组对比：下面这个是没有用socket封装的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:./demo01 ip port\nExample:./demo01 127.0.0.1 5005\n\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第1步：创建客户端的socket。</span></span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="keyword">if</span> ( (sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>))==<span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第2步：向服务器发起连接请求。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">h</span>;</span></span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> )   <span class="comment">// 指定服务端的ip地址。</span></span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;gethostbyname failed.\n&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 指定服务端的通讯端口。</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (struct sockaddr *)&amp;servaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) != <span class="number">0</span>)  <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); <span class="built_in">close</span>(sockfd); <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> iret;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">102400</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第3步：与服务端通讯，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">10</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">send</span>(sockfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>) <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">    &#123; <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">recv</span>(sockfd,buffer,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>) <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;iret=%d\n&quot;</span>,iret); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 每隔一秒后再次发送报文。</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第4步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../_public.h&quot;</span> <span class="comment">//这个是已经封装了的</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:./demo07 ip port\nExample:./demo07 127.0.0.1 5005\n\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发起连接请求。</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(argv[<span class="number">1</span>],<span class="built_in">atoi</span>(argv[<span class="number">2</span>]))==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(%s,%s) failed.\n&quot;</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">102400</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 与服务端通讯，发送一个报文后等待回复，然后再发下一个报文。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">100000</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">SPRINTF</span>(buffer,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>,ii+<span class="number">1</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Write</span>(buffer)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (TcpClient.<span class="built_in">Read</span>(buffer)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);  <span class="comment">// 每隔一秒后再次发送报文。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，用了socket，会让我们的程序设计变得简单，更多的精力可以用在业务逻辑的处理</p>
<h4 id="CTcpClient"><a href="#CTcpClient" class="headerlink" title="CTcpClient()"></a>CTcpClient()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket通讯的客户端类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpClient</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span>  m_connfd;    <span class="comment">// 客户端的socket.</span></span><br><span class="line">  <span class="keyword">char</span> m_ip[<span class="number">21</span>];    <span class="comment">// 服务端的ip地址。</span></span><br><span class="line">  <span class="keyword">int</span>  m_port;      <span class="comment">// 与服务端通讯的端口。</span></span><br><span class="line">  <span class="keyword">bool</span> m_btimeout;  <span class="comment">// 调用Read方法时，失败的原因是否是超时：true-超时，false-未超时。</span></span><br><span class="line">  <span class="keyword">int</span>  m_buflen;    <span class="comment">// 调用Read方法后，接收到的报文的大小，单位：字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpClient</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发起连接请求。</span></span><br><span class="line">  <span class="comment">// ip：服务端的ip地址。</span></span><br><span class="line">  <span class="comment">// port：服务端监听的端口。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ConnectToServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip,<span class="keyword">const</span> <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收服务端发送过来的数据。</span></span><br><span class="line">  <span class="comment">// buffer：接收数据缓冲区的地址，数据的长度存放在m_buflen成员变量中。</span></span><br><span class="line">  <span class="comment">// itimeout：等待数据的超时时间，单位：秒，缺省值是0-无限等待。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时，成员变量m_btimeout的值被设置为true；2）socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Read</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> itimeout=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发送数据。</span></span><br><span class="line">  <span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line">  <span class="comment">// ibuflen：待发送数据的大小，单位：字节，缺省值为0，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开与服务端的连接</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CTcpClient</span>();  <span class="comment">// 析构函数自动关闭socket，释放资源。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="ConnectToServer"><a href="#ConnectToServer" class="headerlink" title="ConnectToServer()"></a>ConnectToServer()</h5><p>这里有两个细节：</p>
<ol>
<li>m_connfd是客户端是否已经连接的信号，如果都本身已经处于连接状态了，那就先关闭它，并且再把这个参数变为-1，也可以用false啥的，这个没啥特别的，但是一般连接状态的socket都大于0，所以用-1更容易区分。</li>
<li><strong>重要</strong>细节：SIGPIPE这个信号，在应用开发中，我们如果向已关闭的socket发出数据，内核就会发送SIGPIPE的信号，这个信号是直接关闭异常程序，我们肯定不希望直接就把他关闭了，所以一般来讲要屏蔽</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpClient::ConnectToServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip,<span class="keyword">const</span> <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果已连接到服务端，则断开，这种处理方法没有特别的原因，不要纠结。</span></span><br><span class="line">  <span class="keyword">if</span> (m_connfd!=<span class="number">-1</span>) &#123; <span class="built_in">close</span>(m_connfd); m_connfd=<span class="number">-1</span>; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 忽略SIGPIPE信号，防止程序异常退出。</span></span><br><span class="line">  <span class="comment">// 如果send到一个disconnected socket上，内核就会发出SIGPIPE信号。这个信号</span></span><br><span class="line">  <span class="comment">// 的缺省处理方法是终止进程，大多数时候这都不是我们期望的。我们重新定义这</span></span><br><span class="line">  <span class="comment">// 个信号的处理方法，大多数情况是直接屏蔽它。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGPIPE,SIG_IGN);   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="屏蔽与否SIGPIPE演示"><a href="#屏蔽与否SIGPIPE演示" class="headerlink" title="屏蔽与否SIGPIPE演示"></a>屏蔽与否SIGPIPE演示</h6><p>可以看到仅第一条有输出<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423114825550.png" alt="image-20220423114825550"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423114847072.png" alt="image-20220423114847072"></p>
<p>我们再把忽略信号加上…………..<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423114911658.png" alt="image-20220423114911658"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423114951526.png" alt="image-20220423114951526"></p>
<h5 id="Read"><a href="#Read" class="headerlink" title="Read()"></a>Read()</h5><p>​        程序也像我们打电话一样，如果打了十几秒，还没接，就可能会怀疑对方程序有问题，或者哪哪的问题，要挂掉，这里要用到io复用技术(poll)，现在先暂时不了解，我们知道大致意思就好</p>
<p>​        就是如果itimeout&gt;0就判断程序在itimeout指定的时间内有没有到达，没有的话把m_btimeout关掉，if的那段代码只判断有没有数据到达，不会读取数据，读取用return的TcpRead来读，TcpRead上面已经封装好了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收服务端发送过来的数据。</span></span><br><span class="line"><span class="comment">// buffer：接收数据缓冲区的地址，数据的长度存放在m_buflen成员变量中。</span></span><br><span class="line"><span class="comment">// itimeout：等待数据的超时时间，单位：秒，缺省值是0-无限等待。</span></span><br><span class="line"><span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时，成员变量m_btimeout的值被设置为true；2）socket连接已不可用。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpClient::Read</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> itimeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_connfd==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果itimeout&gt;0，表示需要等待itimeout秒，如果itimeout秒后还没有数据到达，返回false。</span></span><br><span class="line">  <span class="keyword">if</span> (itimeout&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line">    fds.fd=m_connfd;</span><br><span class="line">    fds.events=POLLIN;  </span><br><span class="line">    <span class="keyword">int</span> iret;</span><br><span class="line">    m_btimeout=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">poll</span>(&amp;fds,<span class="number">1</span>,itimeout*<span class="number">1000</span>)) &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">0</span>) m_btimeout = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m_buflen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">TcpRead</span>(m_connfd,buffer,&amp;m_buflen));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其余函数"><a href="#其余函数" class="headerlink" title="其余函数"></a>其余函数</h5><p>Write中调用了TcpWrite，close关闭socket连接，在析构函数中调用了close</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpClient::Write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> ibuflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_connfd==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ilen=ibuflen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ibuflen==<span class="number">0</span>) ilen=<span class="built_in">strlen</span>(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(<span class="built_in">TcpWrite</span>(m_connfd,buffer,ilen));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpClient::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_connfd &gt; <span class="number">0</span>) <span class="built_in">close</span>(m_connfd); </span><br><span class="line"></span><br><span class="line">  m_connfd=<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(m_ip,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(m_ip));</span><br><span class="line">  m_port=<span class="number">0</span>;</span><br><span class="line">  m_btimeout=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpClient::~<span class="built_in">CTcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CTcpServer"><a href="#CTcpServer" class="headerlink" title="CTcpServer()"></a>CTcpServer()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket通讯的服务端类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTcpServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_socklen;                    <span class="comment">// 结构体struct sockaddr_in的大小。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">m_clientaddr</span>;</span>  <span class="comment">// 客户端的地址信息。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">m_servaddr</span>;</span>    <span class="comment">// 服务端的地址信息。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span>  m_listenfd;   <span class="comment">// 服务端用于监听的socket。</span></span><br><span class="line">  <span class="keyword">int</span>  m_connfd;     <span class="comment">// 客户端连接上来的socket。</span></span><br><span class="line">  <span class="keyword">bool</span> m_btimeout;   <span class="comment">// 调用Read方法时，失败的原因是否是超时：true-超时，false-未超时。</span></span><br><span class="line">  <span class="keyword">int</span>  m_buflen;     <span class="comment">// 调用Read方法后，接收到的报文的大小，单位：字节。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CTcpServer</span>();  <span class="comment">// 构造函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端初始化。</span></span><br><span class="line">  <span class="comment">// port：指定服务端用于监听的端口。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，一般情况下，只要port设置正确，没有被占用，初始化都会成功。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InitServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">int</span> backlog=<span class="number">5</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞等待客户端的连接请求。</span></span><br><span class="line">  <span class="comment">// 返回值：true-有新的客户端已连接上来，false-失败，Accept被中断，如果Accept失败，可以重新Accept。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取客户端的ip地址。</span></span><br><span class="line">  <span class="comment">// 返回值：客户端的ip地址，如&quot;192.168.1.100&quot;。</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> *<span class="title">GetIP</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收客户端发送过来的数据。</span></span><br><span class="line">  <span class="comment">// buffer：接收数据缓冲区的地址，数据的长度存放在m_buflen成员变量中。</span></span><br><span class="line">  <span class="comment">// itimeout：等待数据的超时时间，单位：秒，缺省值是0-无限等待。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，失败有两种情况：1）等待超时，成员变量m_btimeout的值被设置为true；2）socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Read</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> itimeout=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向客户端发送数据。</span></span><br><span class="line">  <span class="comment">// buffer：待发送数据缓冲区的地址。</span></span><br><span class="line">  <span class="comment">// ibuflen：待发送数据的大小，单位：字节，缺省值为0，如果发送的是ascii字符串，ibuflen取0，如果是二进制流数据，ibuflen为二进制数据块的大小。</span></span><br><span class="line">  <span class="comment">// 返回值：true-成功；false-失败，如果失败，表示socket连接已不可用。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> ibuflen=<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭监听的socket，即m_listenfd，常用于多进程服务程序的子进程代码中。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭客户端的socket，即m_connfd，常用于多进程服务程序的父进程代码中。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">CTcpServer</span>();  <span class="comment">// 析构函数自动关闭socket，释放资源。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="InitServer"><a href="#InitServer" class="headerlink" title="InitServer()"></a>InitServer()</h5><p>三个细节：</p>
<ol>
<li>忽略SIGPIPE信号</li>
<li>服务端一定要打开SO_REUSEADDR，否则下面的bind调用，很容易出现地址被使用的问题</li>
<li>传参列表 backlog，会填写在listen里面，在绝大多数情况下5已经够用了，如果客户端成百上千个，可以改大一点，50,100都行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTcpServer::InitServer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果服务端的socket&gt;0，关掉它，这种处理方法没有特别的原因，不要纠结。</span></span><br><span class="line">  <span class="keyword">if</span> (m_listenfd &gt; <span class="number">0</span>) &#123; <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (m_listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>))&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 忽略SIGPIPE信号，防止程序异常退出。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGPIPE,SIG_IGN);   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开SO_REUSEADDR选项，当服务端连接处于TIME_WAIT状态时可以再次启动服务器，</span></span><br><span class="line">  <span class="comment">// 否则bind()可能会不成功，报：Address already in use。</span></span><br><span class="line">  <span class="comment">//char opt = 1; unsigned int len = sizeof(opt);</span></span><br><span class="line">  <span class="keyword">int</span> opt = <span class="number">1</span>; <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(opt);</span><br><span class="line">  <span class="built_in">setsockopt</span>(m_listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,len);    </span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;m_servaddr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(m_servaddr));</span><br><span class="line">  m_servaddr.sin_family = AF_INET;</span><br><span class="line">  m_servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);   <span class="comment">// 任意ip地址。</span></span><br><span class="line">  m_servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(m_listenfd,(struct sockaddr *)&amp;m_servaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(m_servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CloseListen</span>(); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(m_listenfd,backlog) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CloseListen</span>(); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="关闭socket"><a href="#关闭socket" class="headerlink" title="关闭socket"></a>关闭socket</h5><p>有两个，一个用于关闭监听，一个用于关闭客户端的socket</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseListen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_listenfd &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">close</span>(m_listenfd); m_listenfd=<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTcpServer::CloseClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m_connfd &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">close</span>(m_connfd); m_connfd=<span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTcpServer::~<span class="built_in">CTcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">CloseListen</span>(); <span class="built_in">CloseClient</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xingguang1130/p/11643446.html">https://www.cnblogs.com/xingguang1130/p/11643446.html</a></p>
</blockquote>
<h4 id="1、大端、小端字节序"><a href="#1、大端、小端字节序" class="headerlink" title="1、大端、小端字节序"></a>1、大端、小端字节序</h4><p>考虑一个16位整数，它由2个字节组成。内存中存储这两个字节有两种方法：一种是将<strong>低序字节</strong>存储在<strong>起始地址</strong>，这称为小端（little-endian）字节序；另一种方法是将<strong>高序字节</strong>存储在<strong>起始地址</strong>，这称为大端（big-endian）字节序。如下所示：</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009170021990-1780228810.png" alt="img"></p>
<p> 术语“大端”和“小端”表示多个字节值的哪一端（小端或大端）存储在该值的起始地址。</p>
<p><strong>遗憾</strong>的是，这两种字节序之间<strong>没有标准可循</strong>，两种格式都有系统使用。比如，Inter x86、ARM核采用的是小端模式，Power PC、MIPS UNIX和HP-PA UNIX采用大端模式。</p>
<h4 id="2、网络字节序和主机字节序"><a href="#2、网络字节序和主机字节序" class="headerlink" title="2、网络字节序和主机字节序"></a>2、网络字节序和主机字节序</h4><p>网络字节序</p>
<p>　　<strong>网络字节序</strong>是TCP/IP中<strong>规定好</strong>的一种<strong>数据表示格式</strong>，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。<strong>网络字节序采用big endian排序方式。</strong>(大端—-big endian)</p>
<p>主机字节序</p>
<p>　　<strong>不同的机器</strong>主机字节序不相同，<strong>与CPU</strong>设计<strong>有关</strong>，<strong>数据的顺序</strong>是由<strong>cpu决定</strong>的，而<strong>与操作系统无关</strong>。我们把某个给定系统所用的字节序称为主机字节序（host byte order）。比如<strong>x86</strong>系列<strong>CPU</strong>都是<strong>little-endian</strong>的字节序。</p>
<p>　　由于这个原因<strong>不同体系结构</strong>的机器之间<strong>无法通信</strong>,所以<strong>要转换成</strong>一种<strong>约定的数序</strong>,也就是<strong>网络字节顺序。</strong></p>
<p>网络字节序与主机字节序之间的转换函数：htons(), ntohs(), htons()，htonl()，位于头文件&lt;netinet/in.h&gt;，htons和ntohs完成16位无符号数的相互转换，htonl和ntohl完成32位无符号数的相互转换。</p>
<p>在使用<strong>little endian</strong>的系统中，这些函数会<strong>把字节序进行转换</strong>；</p>
<p>在使用<strong>big endian</strong>类型的<strong>系统</strong>中，这些函数会定义成<strong>空宏</strong>；</p>
<p>在<strong>网络程序开发</strong>时 或是<strong>跨平台开发</strong>时，也应该注意<strong>保证只用一种字节序</strong>，不然两方的解释不一样就会产生bug。</p>
<h4 id="3、IP地址的三种表示格式及在开发中的应用"><a href="#3、IP地址的三种表示格式及在开发中的应用" class="headerlink" title="3、IP地址的三种表示格式及在开发中的应用"></a>3、IP地址的三种表示格式及在开发中的应用</h4><p>1）点分十进制表示格式</p>
<p>2）网络字节序格式</p>
<p>3）主机字节序格式</p>
<p>用IP地址127.0.0.1为例：（我估计这个例子是把小端主机转化为大端网络字节序)</p>
<p>　　第一步  127   .     0     .     0     .    1         把IP地址每一部分转换为8位的二进制数。</p>
<p>　　第二步 01111111   00000000   00000000   00000001   =  2130706433  （主机字节序）</p>
<p>　　然后把上面的四部分二进制数从右往左按部分重新排列，那就变为：</p>
<p>　　第三步 00000001   00000000   00000000  01111111    =  16777343    （网络字节序）</p>
<p>eg:</p>
<p>　　<code>struct sockaddr_in addrSrv;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　　addrSrv.sin_addr.S_un.S_addr=htonl(2130706433);　　</span></span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">addrSrv.sin_family=AF_INET;</span><br><span class="line">addrSrv.sin_port=<span class="built_in">htons</span>(<span class="number">6000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4、inet-aton-、inet-addr-和inet-ntoa-函数"><a href="#4、inet-aton-、inet-addr-和inet-ntoa-函数" class="headerlink" title="4、inet_aton()、inet_addr()和inet_ntoa()函数"></a>4、inet_aton()、inet_addr()和inet_ntoa()函数</h4><p>头文件： &lt;arpa/inet.h&gt;</p>
<p>1）int inet_aton（const char *strptr, struct in_addr *addrptr）;</p>
<p>将strptr所指<strong>C字符串转换</strong>成一个32位的<strong>网络字节序</strong>二进制值，并通过指针addrptr来存储。若成功则返回1，否则返回0。</p>
<p>2）in_addr_t inet_addr(const char *strptr)</p>
<p>若字符串有效，则<strong>返回值</strong>为<strong>32位</strong>的<strong>网络字节序</strong>二进制值，否则为<strong>INADDR_NONE</strong>。</p>
<p>该函数存在一个问题，所有2^32^个可能的二进制值都是有效的IP地址（0.0.0.0—255.255.255.255），但是当出错时该函数返回<strong>INADDR_NONE</strong>常值（通常是一个<strong>32位均为1</strong>的值）。这意味着点分十进制数串<strong>255.255.255.255 ** <strong>不能</strong>由该函数</strong>处理<strong>，因为它的二进制值用来指示该函数失败。所以该函数已经被废弃，</strong>应该尽量用inet_aton()函数**，或者将要说到的inet_pton()函数。</p>
<p>3）char *inet_ntoa(struct in_addr inaddr);</p>
<p>将一个32位的网络字节序二进制值IPv4地址转换成相应的点分十进制数串。该函数以一个结构而不是以指向该结构的一个指针作为其参数。</p>
<p>返回：指向一个点分十进制数串的指针</p>
<p>5、inet_pton()和inet_ntop()函数</p>
<p>这两个函数是随着IPv6出现的新函数，对于IPv4地址和IPv6地址都适用。函数名中p和n分别代表表达（presentation）和数值（numeric）。</p>
<p>头文件： &lt;arpa/inet.h&gt;</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180546018-2022186935.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180601048-850741256.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180620819-1867991897.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180635675-1237427561.png" alt="img"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180708604-390483638.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180732935-2091572235.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180745077-1725614479.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180751550-1666055833.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180759021-85380945.png" alt="img"></p>
<p> <img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180806636-2116522325.png" alt="img"></p>
<p> 总结这几个转换函数：</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/1380746-20191009180821469-1834992781.png" alt="img"></p>
<h3 id="C语言-网络-主机字节序"><a href="#C语言-网络-主机字节序" class="headerlink" title="C语言-网络/主机字节序"></a>C语言-网络/主机字节序</h3><h4 id="如何判断字节序"><a href="#如何判断字节序" class="headerlink" title="如何判断字节序"></a>如何判断字节序</h4><p>字节序的判断只需要一段简单的代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int x=0x12345678; </span><br><span class="line">  </span><br><span class="line">    unsigned char *p=(char *)&amp;x;  </span><br><span class="line">    printf(&quot;%p %p %p %p\r\n&quot;,p,p+1,p+2,p+3);</span><br><span class="line">    printf(&quot;%0x %0x %0x %0x\r\n&quot;,p[0],p[1],p[2],p[3]);  </span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>在ubuntu下的执行结果为：<br><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/20201116134723879.png#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-h249YuCY-1605505603244)(F9E0E3F35D694C0F9A4767AC1F62F26F)]"></p>
<p>从执行结果可以得到低字节的78存储在低地址0x7ffe4970678c，所以ubuntu的字节序是小端序。</p>
<p>linux下还可以使用shell查看字节序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep -i byte</span><br><span class="line"></span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>lscpu表示查看cup的相关信息，grep -i byte表示过滤字节序字段。</p>
<h4 id="二、网络字节序"><a href="#二、网络字节序" class="headerlink" title="二、网络字节序"></a>二、网络字节序</h4><p><strong>TCP/IP协议规定:把接收到的第一个字节当作高位字节看待，所以网络字节序是大端序;</strong> 我们的电脑和一些常用的处理器芯片大都是小端序的存储方式，在发送数据之前需要进行字节序的转换。</p>
<p>假设我们需要把0x12345678通过udp发送出去，我们在linux上写如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int buffer = 0x12345678;</span><br><span class="line">ret = sendto(sockfd,&amp;buffer,sizeof(int),0,&amp;dest_addr,sizeof(dest_addr));</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>通过wireshark抓取得到的数据包为：<br><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI3MDk4Nw==,size_16,color_FFFFFF,t_70#pic_center.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-O1xC6YO5-1605505603246)(3DB291F709EA465C8F22BBF4A87A76BB)]"></p>
<p>我们可以使用htonl将主机字节序转换成网络字节序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int buffer = 0x12345678;</span><br><span class="line">buffer = htonl(buffer);</span><br><span class="line">ret = sendto(sockfd,&amp;buffer,sizeof(int),0,&amp;dest_addr,sizeof(dest_addr));</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>使用wireshark抓取得到的数据如下：<br><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI3MDk4Nw==,size_16,color_FFFFFF,t_70#pic_center.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GHXOeh1a-1605505603247)(D765F3E188B944F08A3B5C901E8FF633)]"></p>
<h3 id="ipv4-ipv6"><a href="#ipv4-ipv6" class="headerlink" title="ipv4/ipv6"></a>ipv4/ipv6</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/271708071">IPv4和IPv6有什么区别？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>Internet协议（IP）是为连接到Internet网络的每个设备分配的数字地址。它类似于电话号码，是一种独特的数字组合，允许用户与他人通信。IP地址主要有两个主要功能。首先，有了IP，用户能够<strong>在Internet上被识别</strong>。第二，IP地址允许计算机<strong>通过Internet发送和接收数据</strong>，也就是我们经常说的通信。在本文中，我们将深入研究两种类型的IP地址：IPv4与IPv6。我们将从以下几个方面来给大家介绍这两种类型的IP地址，让大家了解到两类IP的必备知识：</p>
<ul>
<li>什么是IPv4和IPv6？</li>
<li>IPv4和IPv6之间的区别</li>
<li>IPv4或IPv6：使用哪个？</li>
<li>IPv4与IPv6安全性如何</li>
</ul>
<h4 id="什么是IPv4和IPv6？"><a href="#什么是IPv4和IPv6？" class="headerlink" title="什么是IPv4和IPv6？"></a>什么是IPv4和IPv6？</h4><p>IPv4和IPv6是不同类型的IP地址。它们的主要用途相同，标记不同的用户，并且让用户能通过IP进行通信。主要区别在于IPv6是最新一代的IP地址。</p>
<p><strong>IPv4地址</strong></p>
<p>IPv4地址的概念是在1980年代初期提出的。即使有新版本的IP地址，IPv4地址仍然是Internet用户使用最广泛的地址。通常，IPv4地址以<strong>点分十进制</strong>表示。每个部分代表一组构成8位地址方案的8位地址。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/v2-2320b6909f65cfa025c90b25edaf351a_1440w.jpg" alt="img"></p>
<p>IPv4地址组合的数量是有限的。总体而言，可以算出40亿<strong>（256 4）</strong>个唯一地址。在IPv4地址才开始时，这个数字似乎永远不会过期。但是，现在情况有所不同了。2011年，全球互联网编号分配机构（IANA）分发了IPv4地址空间的最后一块。2015年，IANA正式宣布美国已用完IPv4地址。直到今天，IPv4地址仍然承载着最多（超过90％）的互联网流量。到目前为止，即使目前存在IPv4地址耗尽的问题，也有一些方法可以继续使用IPv4地址。例如，当仅需要一个唯一的IP地址来代表一组设备时，网络地址转换（NAT）是一种方法。除此之外，IP地址可以重复使用。当然，我们已经有了彻底耗尽的解决方案-IPv6地址。</p>
<p><strong>IPv6地址</strong></p>
<p>仔细观察，您会发现IPv6地址并不是一种全新的技术。它是Internet协议的最新版本，但它是在1998年开发的，旨在替换IPv4地址。IPv6地址使用以冒号分隔的十六进制数字。它分为八个16位块，构成一个128位地址方案。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/v2-b965f60c92695b058f8dc3ff91734a11_1440w.jpg" alt="img"></p>
<p>IPv6也存在数量限制。不过可用的IP数量远大于IPv4。从理论上讲，可以创建大约<strong>3.4×10 38</strong>个地址。这一数据听起来很高，远超于IPv4的总数40亿个，但是有一天也可能出现不够的情况。但就目前而言，这些地址将可以供我们使用很长一段时间。</p>
<h4 id="IPv4和IPv6之间的区别"><a href="#IPv4和IPv6之间的区别" class="headerlink" title="IPv4和IPv6之间的区别"></a>IPv4和IPv6之间的区别</h4><p>IPv4和IPv6用于用户标识和Internet上不同设备之间的通信。IPv4是32位IP地址，而IPv6是128位IP地址。IPv4是数字地址，用点分隔。IPv6是一个字母数字地址，用冒号分隔。</p>
<p>我们分别详细介绍了IPv4和IPv6类型。现在，我们可以比较这些类型，并找出这两种协议之间的主要区别。我们列举了IPv4和IPv6之间的八个主要区别。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/v2-3f23cad60b8e07c571e23e0a34a18647_1440w.jpg" alt="img"></p>
<p><strong>1.地址类型。</strong>IPv4具有三种不同类型的地址：多播，广播和单播。IPv6还具有三种不同类型的地址：任意广播，单播和多播。</p>
<p><strong>2.数据包大小。</strong>对于IPv4，最小数据包大小为576字节。对于IPv6，最小数据包大小为1208字节。</p>
<p><strong>3.header区域字段数。</strong>IPv4具有12个标头字段，而IPv6支持8个标头字段。</p>
<p><strong>4.可选字段。</strong>IPv4具有可选字段，而IPv6没有。但是，IPv6具有扩展header，可以在将来扩展协议而不会影响主包结构。</p>
<p><strong>5.配置。</strong>在IPv4中，新装的系统必须配置好才能与其他系统通信。在IPv6中，配置是可选的，它允许根据所需功能进行选择。</p>
<p><strong>6.安全性。</strong>在IPv4中，安全性主要取决于网站和应用程序。它不是针对安全性而开发的IP协议。而IPv6集成了Internet协议安全标准（IPSec）。IPv6的网络安全不像IPv4是可选项，IPv6里的网络安全项是强制性的。</p>
<p><strong>7.与移动设备的兼容性。</strong>IPv4不适合移动网络，因为正如我们前面提到的，它使用点分十进制表示法，而IPv6使用冒号，是移动设备的更好选择。</p>
<p><strong>8.主要功能。</strong>IPv6允许直接寻址，因为存在大量可能的地址。但是，IPv4已经广泛传播并得到许多设备的支持，这使其更易于使用。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/v2-96b3a74f438357dfd7a0e9f28bcd3222_1440w.jpg" alt="img"></p>
<h4 id="IPv4或IPv6：使用哪个？"><a href="#IPv4或IPv6：使用哪个？" class="headerlink" title="IPv4或IPv6：使用哪个？"></a>IPv4或IPv6：使用哪个？</h4><p>对于使用IPv6还是IPv4这个问题，没有标准答案。在考虑未来的网络体验时，IPv6地址就显得至关重要。即使在我们已经没有网络地址的情况下仍然可以有其他办法使用IPv4地址，但是这些选项也可能会轻微影响到网络速度或引起其他问题。不过，使用IPv6需要开发支持IPv6的新技术和产品。IPv6的速度显然不比IPv4快，但是从IPv4完全更改为IPv6将为Internet提供更大的唯一IP池。<strong>那么为什么我们仍在使用IPv4？</strong></p>
<p>问题就在于IPv4和IPv6无法相互通信。这就是为什么IPv6的集成和适配很复杂。大多数网站或应用程序仅支持IPv4类型的IP地址。想象一下突然更改每个设备的IP地址。用户将无法访问大多数网站或应用程序，而我们在互联网上将陷入一片混乱。从旧的IP类型转换为新的IP类型的过程应分步完成。例如，这两个协议能够并行运行。此功能称为<strong>双重堆栈</strong>。它允许用户同时访问IPv4和IPv6内容。</p>
<p><strong>您需要什么才能使用IPv6？</strong></p>
<p>1.操作系统必须与IPv6兼容。Windows Vista和Windows的较新版本，Mac OS X的现代版本以及Linux。</p>
<p>2.大多数路由器不支持IPv6。如果您想尝试使用IPv6，请检查路由器的详细信息。</p>
<p>\3. Internet服务提供商（ISP）也必须支持IPv6。即使您具有合适的操作系统和路由器，您的ISP也必须提供IPv6连接。</p>
<h4 id="IPv4与IPv6的安全性"><a href="#IPv4与IPv6的安全性" class="headerlink" title="IPv4与IPv6的安全性"></a>IPv4与IPv6的安全性</h4><p>IPv6的开发考虑了<strong>安全性</strong>。这就是将IPSec集成在IPv6中的原因，而对于IPv4，IPSec是可选的。</p>
<p><strong>什么是IPSec？</strong></p>
<p><strong>IPSec（Internet协议安全性）</strong>是一种安全的网络协议，它对数据包进行身份验证和加密，以在设备之间提供安全的通信。加密是只有经过确认的各方才能理解的一种秘密代码。它有助于确保通过公共网络发送的信息的安全。</p>
<p>由于IPv4还可以选择集成IPSec，因此我们可以假设在安全性方面IPv4与IPv6几乎相同。但是，如果已经集成了安全措施，则要简单得 多。</p>
<h2 id="三、多进程的网络服务端"><a href="#三、多进程的网络服务端" class="headerlink" title="三、多进程的网络服务端"></a>三、多进程的网络服务端</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423173519983.png" alt="image-20220423173519983"></p>
<p>服务端可以是多进程，也可以是多线程，如果采用IO复用技术，单进程单线程的服务端也可以和多个客户端程序通信，这个章节我们先搞定定多进程和多线程的服务端</p>
<h3 id="主体流程"><a href="#主体流程" class="headerlink" title="主体流程"></a>主体流程</h3><p>父进程先初始化服务端，然后Accept等待服务端的连接，新的客户端连上了之后，fork一个子进程出来，然后父进程回到accept继续等待其他客户端的连接请求，让子进程与刚才连进来的客户端进行处理业务。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423173834599.png" alt="image-20220423173834599"></p>
<h4 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h4><p>寄托于fork函数实现，我们用while反复迭代，达到不断接受客户端的目的（回到Accept），</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423201612991.png" alt="image-20220423201612991"></p>
<p>​        但接下来就出现了一个问题（demo10为服务端），现在，客户端已经全部结束了，但是服务端还有这么多进程，这是怎么回事呢？</p>
<p>那原因就在那个while，当fork生成子进程，子进程进入while，并且执行完自己的程序之后，就会继续进入上面那层while，并且不断卡在连接阶段，就和父进程一起等待在哪里挂起了</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423201840979.png" alt="image-20220423201840979"></p>
<p>所以我们应该在最下面增加一行代码，用return 0或者exit(0)都可以<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423202119413.png" alt="image-20220423202119413"></p>
<h4 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h4><p>​        现在，我们解决了服务端进程等待的问题，接下来，新的问题又出现了。客户端全部退出之后，服务端的进程变成了这样，也就是产生了很多僵尸进程。因为最后服务端还没有关闭的，至少最初的父进程任然在等待子进程，所以说哪些进程暂时挂起，变成僵尸进程，占用进程号</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423202255720.png" alt="image-20220423202255720"></p>
<h4 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423202817539.png" alt="image-20220423202817539"></p>
<p>我们在程序连接到，并且不做任何行动的这段时间内，sleep100s，<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423203052571.png" alt="image-20220423203052571"></p>
<p>现在我们得到demo10的进程编号，</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423203143047.png" alt="image-20220423203143047"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423203311325.png" alt="image-20220423203311325"></p>
<p>在fd里，有他打开过的文件描述符<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423203403409.png" alt="image-20220423203403409"></p>
<p>0,1,2是标准输入，标准输出，标准错误，3应该是监听的socket，4</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423204148262.png" alt="image-20220423204148262"></p>
<p>现在我们在换个花样，如果我们把sleep放在fork之后，让一个客户端连上去。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423204434027.png" alt="image-20220423204434027"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423204353570.png" alt="image-20220423204353570"></p>
<p>此时我们可以观察到<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423204527094.png" alt="image-20220423204527094"></p>
<p>​        父进程和子进程文件表示符一样的！因为fork那节课，就已经讲过，fork是全部复制，也就是二者的任何信息，不会和彼此有关联，是独立的个体。</p>
<p>​        在网络服务程序中，父进程只负责监听客户端的连接，客户端连上了之后，对父进程来说，connfd是不需要的，对子进程而言，他使用的只是connfd，他也不需要监听的listenfd，既然这样，那么我们可以在父进程中关掉4，子进程中关掉3<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423204906966.png" alt="image-20220423204906966"></p>
<p>​        当然，不关闭这两个文件描述符，其实也可以，但是对一个进程来说，打开的文件描述符是有限制的，打开的越多，消耗的资源会更多，所以我们肯定会执行这两行的，再开发当中</p>
<p>​        另外，日志闪亮登场。(将服务端的printf语句改为file.Write(argv[2], a+) == false…..)</p>
<h5 id="fork一点点补充："><a href="#fork一点点补充：" class="headerlink" title="fork一点点补充："></a>fork一点点补充：</h5><p>至于fork()函数的返回值：<br>子进程返回：0<br>父进程返回：&gt;0的整数(返回子进程ID号)<br>错误返回：－1</p>
<p>补充这个的目的就是说，我们可以完全看出子进程继续往下，父进程再度回去（用continue，等效回去，而且本来就是第一个进程，所以自然也是父进程）</p>
<h4 id="多进程网络服务程序-端-的退出"><a href="#多进程网络服务程序-端-的退出" class="headerlink" title="多进程网络服务程序(端)的退出"></a>多进程网络服务程序(端)的退出</h4><p>​        我们之前知道，可以用信号(killall xx xxx)来实现单进程的程序退出（杀掉），我们现在来思考一下多进程该如何退出，应该说，什么才是我们想要的退出，我们知道，对于一个进程而言，当他的父进程退出了，他不会跟着一起退出，所以说：</p>
<ol>
<li>如果杀掉父亲，进行中的子进程不会跟着一起退出，会执行到结束，当子进程结束了，就别让他挂起了，喊他退出，但在这个期间内，新的客户端想要连接客户端，就不会被通过，因为父进程是用于监听的，连监听的都死掉了，你还怎么连进来？</li>
<li>如果杀掉孩子，我们自然是不希望影响到别的进程的，但是，我们也不想让这个孩子变成僵尸进程，所以，我们最开始的想法是让父进程忽略掉子进程的信号，现在我们可以把它封装成一个chldEXIT函数，具体思路如下面代码</li>
<li>如果父子都收到了信号，叫你们断掉，那么和第一种情况类似</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>）在多进程的服务程序中，如果杀掉一个子进程，和这个子进程通讯的客户端会断开，但是，不</span><br><span class="line">*    会影响其它的子进程和客户端，也不会影响父进程。</span><br><span class="line">* <span class="number">2</span>）如果杀掉父进程，不会影响正在通讯中的子进程，但是，新的客户端无法建立连接。</span><br><span class="line">* <span class="number">3</span>）如果用killall+程序名，可以杀掉父进程和全部的子进程。</span><br><span class="line">*</span><br><span class="line">* 多进程网络服务端程序退出的三种情况：</span><br><span class="line">* <span class="number">1</span>）如果是子进程收到退出信号，该子进程断开与客户端连接的socket，然后退出。</span><br><span class="line">* <span class="number">2</span>）如果是父进程收到退出信号，父进程先关闭监听的socket，然后向全部的子进程发出退出信号。</span><br><span class="line">* <span class="number">3</span>）如果父子进程都收到退出信号，本质上与第<span class="number">2</span>种情况相同。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父进程退出函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="keyword">int</span> sig)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;父进程退出，sig=%d。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  TcpServer.<span class="built_in">CloseListen</span>();    <span class="comment">// 关闭监听的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">kill</span>(<span class="number">0</span>,<span class="number">15</span>);     <span class="comment">// 通知全部的子进程退出。具体解释看下面</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程退出函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="keyword">int</span> sig)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;子进程退出，sig=%d。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  TcpServer.<span class="built_in">CloseClient</span>();    <span class="comment">// 关闭客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="问题再深入"><a href="#问题再深入" class="headerlink" title="问题再深入"></a>问题再深入</h5><p>当服务端客户端正常运行的时候，如果我们把服务端突然来个ctrl终止了，他就GG了，但是我们现在观察后台<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423225241777.png" alt="image-20220423225241777"></p>
<p>​        他居然退出了两次，我们说，这不是我们想要的(虽然他实质肯定就退出了一次)</p>
<p>​        这样的原因是因为，信号退出处理函数在执行的过程中又受到了信号，要解决这个问题，我们可以，给退出函数，做屏蔽处理，具体如下哦，这样无敌的退出函数就出来啦</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父进程退出函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="keyword">int</span> sig)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;父进程退出，sig=%d。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  TcpServer.<span class="built_in">CloseListen</span>();    <span class="comment">// 关闭监听的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">kill</span>(<span class="number">0</span>,<span class="number">15</span>);     <span class="comment">// 通知全部的子进程退出。具体解释看下面</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程退出函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="keyword">int</span> sig)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;子进程退出，sig=%d。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  TcpServer.<span class="built_in">CloseClient</span>();    <span class="comment">// 关闭客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h5><p>​        思路别限制的太死，退出函数除了响应退出信号，还可以在其他的地方调用它，比如说，这个return，我们就可以改成FathEXIT(-1)<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423225508724.png" alt="image-20220423225508724"></p>
<p>又或者是这里，我们处理结束以后把客户端关了，可以用我们刚刚写好的ChldEXIT(0)<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220423225620007.png" alt="image-20220423225620007"></p>
<h5 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h5><p>头文件：#include &lt;sys/types.h&gt;  #include &lt;signal.h&gt;</p>
<p>定义函数：int kill(pid_t pid, int sig);</p>
<p>函数说明：kill()可以用来送参数sig 指定的信号给参数pid 指定的进程。参数pid 有几种情况：<br><strong>1</strong>、pid&gt;0 将信号传给进程识别码为pid 的进程.<br><strong>2</strong>、pid=0 将信号传给和目前进程相同进程组的所有进程<br><strong>3</strong>、pid=-1 将信号广播传送给系统内所有的进程<br><strong>4</strong>、pid&lt;0 将信号传给进程组识别码为pid 绝对值的所有进程参数 sig 代表的信号编号可参考附录D</p>
<p>返回值：执行成功则返回0, 如果有错误则返回-1.</p>
<p>错误代码：<br>1、EINVAL 参数sig 不合法<br>2、ESRCH 参数pid 所指定的进程或进程组不存在<br>3、EPERM 权限不够无法传送信号给指定进程</p>
<h3 id="网银APP软件业务"><a href="#网银APP软件业务" class="headerlink" title="网银APP软件业务"></a>网银APP软件业务</h3><h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><p>首先，我们在介绍之前，先来了解网络通信的过程</p>
<ol>
<li>客户端发起连接请求，服务端响应，建立连接，他们之间就可以进行通信了</li>
<li>请求报文可以由客户端发起，也可以由服务端发起，并且，请求报文和回应报文之间的关系，可以是一对一，也可以是多对多，一对多之类的</li>
<li>总的来说，没有固定的格式，要看双方的约定，所谓的约定就是通信协议，结束以后，可以由客户端断开，也可以由服务端断开</li>
</ol>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424101634171.png" alt="image-20220424101634171"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424101647760.png" alt="image-20220424101647760"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424101701870.png" alt="image-20220424101701870"></p>
<h4 id="业务实例"><a href="#业务实例" class="headerlink" title="业务实例"></a>业务实例</h4><p><strong>登录</strong></p>
<p>银行的服务端，收到报文之后，先判断业务代码，如果是1，表示登录业务，再判断手机号码和密码，如果号码和密码都正确，服务端返回0，提示成功，不正确….</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424101820514.png" alt="image-20220424101820514"></p>
<p><strong>我的账户</strong>  </p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424102029128.png" alt="image-20220424102029128"></p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>我们先从客户端改起，把登录业务和查看余额，封装成两个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CTcpClient TcpClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">srv001</span><span class="params">()</span></span>;    <span class="comment">// 登录业务。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">srv002</span><span class="params">()</span></span>;    <span class="comment">// 我的账户（查询余额）。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:./demo11 ip port\nExample:./demo11 127.0.0.1 5005\n\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向服务端发起连接请求。</span></span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">ConnectToServer</span>(argv[<span class="number">1</span>],<span class="built_in">atoi</span>(argv[<span class="number">2</span>]))==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpClient.ConnectToServer(%s,%s) failed.\n&quot;</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">srv001</span>()==<span class="literal">false</span>)     <span class="comment">// 登录业务。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;srv001() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">srv002</span>()==<span class="literal">false</span>)     <span class="comment">// 我的账户（查询余额）。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;srv002() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="登录业务"><a href="#登录业务" class="headerlink" title="登录业务"></a>登录业务</h6><p>三步走，先发送请求，再接受回报，最后解析回报</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录业务。 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">srv001</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">SPRINTF</span>(buffer,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="string">&quot;&lt;srvcode&gt;1&lt;/srvcode&gt;&lt;tel&gt;1392220000&lt;/tel&gt;&lt;password&gt;123456&lt;/password&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">Write</span>(buffer)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">Read</span>(buffer)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析服务端返回的xml。</span></span><br><span class="line">  <span class="keyword">int</span> iretcode=<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;retcode&quot;</span>,&amp;iretcode);</span><br><span class="line">  <span class="keyword">if</span> (iretcode!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;登录失败。\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;登录成功。\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="查询业务"><a href="#查询业务" class="headerlink" title="查询业务"></a>查询业务</h6><p>同样三步走，发送请求，接受回报，解析回报</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的账户（查询余额）。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">srv002</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SPRINTF</span>(buffer,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="string">&quot;&lt;srvcode&gt;2&lt;/srvcode&gt;&lt;cardid&gt;62620000000001&lt;/cardid&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">Write</span>(buffer)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">  <span class="keyword">if</span> (TcpClient.<span class="built_in">Read</span>(buffer)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 接收服务端的回应报文。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析服务端返回的xml。</span></span><br><span class="line">  <span class="keyword">int</span> iretcode=<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;retcode&quot;</span>,&amp;iretcode);</span><br><span class="line">  <span class="keyword">if</span> (iretcode!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;查询余额失败。\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> ye=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(buffer,<span class="string">&quot;ye&quot;</span>,&amp;ye);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;查询余额成功(%.2f)。\n&quot;</span>,ye); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>在接受客户端和发送响应之间插入处理业务的主函数</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424114853821.png" alt="image-20220424114853821"></p>
<p>解析+处理，用switch，判断他的isrvcode来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理业务的主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _main(<span class="keyword">const</span> <span class="keyword">char</span> *strrecvbuffer,<span class="keyword">char</span> *strsendbuffer)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 解析strrecvbuffer，获取服务代码（业务代码）。</span></span><br><span class="line">  <span class="keyword">int</span> isrvcode=<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strrecvbuffer,<span class="string">&quot;srvcode&quot;</span>,&amp;isrvcode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (isrvcode!=<span class="number">1</span>) &amp;&amp; (bsession==<span class="literal">false</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(strsendbuffer,<span class="string">&quot;&lt;retcode&gt;-1&lt;/retcode&gt;&lt;message&gt;用户未登录。&lt;/message&gt;&quot;</span>); <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理每种业务。</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (isrvcode)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:   <span class="comment">// 登录。</span></span><br><span class="line">      <span class="built_in">srv001</span>(strrecvbuffer,strsendbuffer); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:   <span class="comment">// 查询余额。</span></span><br><span class="line">      <span class="built_in">srv002</span>(strrecvbuffer,strsendbuffer); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:   <span class="comment">// 转账。</span></span><br><span class="line">      <span class="built_in">srv003</span>(strrecvbuffer,strsendbuffer); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;业务代码不合法：%s\n&quot;</span>,strrecvbuffer); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="登录业务-1"><a href="#登录业务-1" class="headerlink" title="登录业务"></a>登录业务</h6><p>这里仅用登录业务就好，大同小异，都是进一步解析，因为上一步直解析了isrvcode，这里解析更细致的，登录所需要的参数解析在这，再处理业务，最后strsendbuffer发送出去，其他也是一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">srv001</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strrecvbuffer,<span class="keyword">char</span> *strsendbuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// &lt;srvcode&gt;1&lt;/srvcode&gt;&lt;tel&gt;1392220000&lt;/tel&gt;&lt;password&gt;123456&lt;/password&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析strrecvbuffer，获取业务参数。</span></span><br><span class="line">  <span class="keyword">char</span> tel[<span class="number">21</span>],password[<span class="number">31</span>];</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strrecvbuffer,<span class="string">&quot;tel&quot;</span>,tel,<span class="number">20</span>);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strrecvbuffer,<span class="string">&quot;password&quot;</span>,password,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理业务。</span></span><br><span class="line">  <span class="comment">// 把处理结果生成strsendbuffer。</span></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(tel,<span class="string">&quot;1392220000&quot;</span>)==<span class="number">0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(password,<span class="string">&quot;123456&quot;</span>)==<span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(strsendbuffer,<span class="string">&quot;&lt;retcode&gt;0&lt;/retcode&gt;&lt;message&gt;成功。&lt;/message&gt;&quot;</span>);  bsession=<span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strcpy</span>(strsendbuffer,<span class="string">&quot;&lt;retcode&gt;-1&lt;/retcode&gt;&lt;message&gt;失败。&lt;/message&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        另外，我们在思考一下，现在服务程序使用了switch case 所以登录和其他业务是并列关系，但是，我们可以知道，对于一个网银系统而言，你连登录都没登录，肯定是不能执行下面的语句的，因此，我们还得做一些修改</p>
<p>​        在服务端，我们定义一个bession变量<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424120307640.png" alt="image-20220424120307640"></p>
<p>并且在处理业务的函数中，switch判断之前，加一个检测到未登录，就退出，具体就是说，如果他的isrvcode不是1,（不是进行登录业务）那么我们检测一下他的bsession打开没有，bsession<strong>默认没有打开</strong>，没有打开<strong>说明没有登录</strong>，就让他退出，为了实现这个功能，我们就在登录成功的业务代码哪里加上 <strong>bsession = true</strong> ，这样就可以说，每一个客户端的子进程，最开始bsession都是false，实现了登录业务后，就永久打开，直到他退出！</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424120522459.png" alt="image-20220424120522459"></p>
<h3 id="Tcp长连接，短连接"><a href="#Tcp长连接，短连接" class="headerlink" title="Tcp长连接，短连接"></a>Tcp长连接，短连接</h3><blockquote>
<p>[TCP的长连接和短连接-阿里云开发者社区 (aliyun.com)](<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/37987#:~:text=%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5">https://developer.aliyun.com/article/37987#:~:text=长连接与短连接</a>. 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。.,短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接，一般银行都使用短连接。. 比如http的，只是连接、请求、关闭，过程时间较短%2C服务器若是一段时间内没有收到请求即可关闭连接。. 其实长连接是相对于通常的短连接而说的，也就是长时间保持客户端与服务端的连接状态。.)</p>
</blockquote>
<p><strong>简介：</strong> TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><p>TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。</p>
<p>在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。<br>在传输层中有TCP协议与UDP协议。<br>在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="data:image/jpeg;base64,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" alt="2Q=="></h2><h4 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h4><h2 id="-2"><a href="#-2" class="headerlink" title></a></h2><p>所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。 </p>
<p>短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接，一般银行都使用短连接。 </p>
<p>比如http的，只是连接、请求、关闭，过程时间较短,服务器若是一段时间内没有收到请求即可关闭连接。</p>
<p>其实长连接是相对于通常的短连接而说的，也就是长时间保持客户端与服务端的连接状态。</p>
<h4 id="长连接与短连接的操作过程"><a href="#长连接与短连接的操作过程" class="headerlink" title="长连接与短连接的操作过程"></a>长连接与短连接的操作过程</h4><h2 id="-3"><a href="#-3" class="headerlink" title></a></h2><p>通常的短连接操作步骤是：<br>连接→数据传输→关闭连接；</p>
<p>而长连接通常就是：<br>连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接； </p>
<p>这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态，短连接在没有数据传输时直接关闭就行了。</p>
<h4 id="什么时候用长连接，短连接"><a href="#什么时候用长连接，短连接" class="headerlink" title="什么时候用长连接，短连接"></a>什么时候用长连接，短连接</h4><h2 id="-4"><a href="#-4" class="headerlink" title></a></h2><p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数。</p>
<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。 </p>
<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：<strong>数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</strong></p>
<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，<strong>如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧</strong>。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。 </p>
<p>总之，长连接和短连接的选择要视情况而定。</p>
<h4 id="Tcp短连接"><a href="#Tcp短连接" class="headerlink" title="Tcp短连接"></a>Tcp短连接</h4><p>一对一的请求与回应，快速+高频，使用资源很多，使用的场景不多</p>
<p>连接之后，马上进行通讯，通讯结束之后，连接就断开了，管理起来非常简单，不需要其他的控制手段<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424122105035.png" alt="image-20220424122105035"></p>
<h4 id="Tcp长连接"><a href="#Tcp长连接" class="headerlink" title="Tcp长连接"></a>Tcp长连接</h4><p>大部分场景，采用Tcp长连接，这个过程就是，通信的次数和时间，是不确定的<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424122250642.png" alt="image-20220424122250642"></p>
<p>n秒之后，<strong>服务端也可能主动发起连接请求</strong>…….</p>
<p>​        比如说我们用vx给好友发消息，vx登录之后，我们的手机和腾讯的服务器建立了Tcp连接，服务端在把信息转发给你，服务端向客户端转发的时候，就是服务端主动连接你，vx业务采用的是Tcp长连接，要求客户端一直在线，否则满足不了业务需求，如果你不在线，就收不到别人给你发的信息，很自然<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424122403831.png" alt="image-20220424122403831"></p>
<p>​        长连接和短连接的退出就有很大的区别，连接建立之后，除非程序退出，或者网络断开，否则，这个连接会一直保存，这样的话就产生了一个新的问题，如何管理Tcp连接？            方法是这样的，采用<strong>Tcp心跳机制</strong><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424122657450.png" alt="image-20220424122657450"></p>
<h5 id="Tcp长连接心跳机制"><a href="#Tcp长连接心跳机制" class="headerlink" title="Tcp长连接心跳机制"></a>Tcp长连接心跳机制</h5><p>理解了之后，要实现就很容易，一句话，客户端在空闲的时候，要向服务端，发送心跳报文。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424122903494.png" alt="image-20220424122903494"></p>
<p>心跳报文的格式也很简单</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424122956990.png" alt="image-20220424122956990"></p>
<p>​        我们就从网银系统开始改，想一下需要做什么，首先我们得在服务端传参列表，加入心跳一项(自己拟定多少秒算超时)，心跳传进来，他也算是一种业务的类型，我们可以放在switch里面 接着，假设我们心跳的业务处理代码为0，我们就可以整一个方法，叫做bool srv000,解析  下xml的心跳一项，其实吧，说是解析，根本不需要解析，只要客户端在规定时间传进来了，不就证明他没死吗，所以只会成功，不会失败</p>
<p>​        接着我们改客户端，让他具有发送的能力，并且，只要客户端有收到服务端的报文，我们就可以认为他是成功的，没必要解析xml，如果报文发不出去，或者没有收到回应，我们就说，他是失败的</p>
<p>​        我们现在来测试一下，注意，我们先设置服务端最大空闲时间是11秒，也就是说，虽然这里sleep了两次，加起来超过了10秒，但是我们心跳是针对于，不作任何处理的时间段，所以就没有这个顾虑。<strong>注意</strong>：为什么说没有顾虑呢？，因为在服务端的switch语句里面，第一行就是先执行心跳语句，也就是说，无论我们执行了什么操作，首先都能进入心跳判断那一行，更新了心跳之后，再执行对应的语句，所以说，每执行一种业务，都刷新一次心跳，具体判断，我们是用的read里面封装的心跳机制，应该用到了IO复用的技术，以后遇到了在研究<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424125243606.png" alt="image-20220424125243606"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424125307522.png" alt="image-20220424125307522"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424123859924.png" alt="image-20220424123859924"></p>
<p>我们先来运行服务端<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424124206885.png" alt="image-20220424124206885"></p>
<p>再来运行客户端<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424124222220.png" alt="image-20220424124222220"></p>
<p>如果把超时时间改成8<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424125354161.png" alt="image-20220424125354161"></p>
<p>从结果来说，是非常顺利的！</p>
<h6 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h6><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424125448637.png" alt="image-20220424125448637"></p>
<p>如果我们有连接云服务器之类的经验，就知道Tcp空闲的时候会被断开，中间经过了很多防火墙路由器什么的<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424125617291.png" alt="image-20220424125617291"></p>
<p>例如，在这里，就设置了每50s发送一次心跳，这样的话一天也不会断开，所以，在项目开发中<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424125708356.png" alt="image-20220424125708356"></p>
<p>太短没有必要，太长也不合适，肯定要比网络设备之间要短，一般<strong>60s</strong></p>
<h2 id="四、基于Tcp协议的文件传输系统"><a href="#四、基于Tcp协议的文件传输系统" class="headerlink" title="四、基于Tcp协议的文件传输系统"></a>四、基于Tcp协议的文件传输系统</h2><p>​        从这里开始，正式开始文件传输系统的实现！</p>
<p>之前开发的Ftp文件传输系统，主要用于系统之间，文件传输交换，Ftp很简单，但是效率不高；基于Tcp的主要用于系统内部的代码交换，代码写起来麻烦一些，但是文件传输的效率特别高，功能也更强大</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424203624343.png" alt="image-20220424203624343"></p>
<p>​        这是我们的框架，为什么考虑分成三个部分，这能让系统的结构更佳简单，可能这里会产生一个疑惑，为什么客户端分成上传下载，服务端则不分呢？</p>
<p>​        原因是这样的，服务端是网络服务程序，两个网络服务程序，就需要两个监听的端口，这样的话配置网络参数会更麻烦，比如路由器，要开通两个端口，防火墙也要开通两个端口</p>
<h3 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h3><p>流程图：<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424204032965.png" alt="image-20220424204032965"></p>
<p>​        首先，登录的意义并不是判断用户名和密码，而是与服务端协商文件传输的参数，最重要的参数是文件存放的目录</p>
<p>文件信息：文件名，文件时间，文件大小</p>
<p>文件内容：里面存放的内容</p>
<p>​        服务端接受文件之后，再向客户端发送报文，客户端收到回复的报文，就算上传成功了，然后用while循环来执行这一段迭代，保证把文件清单里每一个文件都上传，当上传完毕，客户端可以休息几秒，再去获取文件清单，再把文件上传给服务端，按照上述的步骤循环。</p>
<p>要求：<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220424204843850.png" alt="image-20220424204843850"></p>
<p>​        第一个要求是因为，该传输功能处于系统内部，对文件传输的时效要求很高，不能延迟太长时间</p>
<p>​        第二个要求是客户端不需要增量上传的功能，上传以后删除便是，这种处理方法最简单，效率也最高，当然，如果要同时上传到多个服务端，那我们可以上传的时候多拷贝几份嘛</p>
<h4 id="exit与return"><a href="#exit与return" class="headerlink" title="exit与return"></a>exit与return</h4><p>​        在实现的过程中我们用到了return和exit的关系，所以在这里我又去百度了一下…</p>
<p>exit（0）：正常运行程序并退出程序；</p>
<p>exit（1）：非正常运行导致退出程序；</p>
<p>return（）：返回函数，若在主函数中，则会退出函数并返回一值。</p>
<p>详细说：</p>
<ol>
<li><p>return<strong>返回函数值</strong>，是关键字； exit <strong>是一个函数</strong>。</p>
</li>
<li><p><strong>return</strong>是<strong>语言</strong>级别的，它表示了调用堆栈的返回；而<strong>exit</strong>是<strong>系统</strong>调用级别的，它表示了一个进程的结束。</p>
</li>
<li><p>return是<strong>函数的退出</strong>(返回)；exit是<strong>进程的退出</strong>。</p>
</li>
<li><p>return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。</p>
</li>
<li><p>return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；<strong>exit</strong>函数是退出应用程序，<strong>删除进程使用的内存空间</strong>，并将应用程序的<strong>一个状态返回给OS</strong>，这个状态<strong>标识了</strong>应用程序的<strong>一些运行信息</strong>，这个信息和机器和操作系统有关，一般是 0 为正常退出， 非0 为非正常退出。</p>
</li>
<li><p>非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。</p>
</li>
</ol>
<p>exit（0）与exit（1）对你的程序来说，没有区别。对使用你的程序的人或者程序来说，区别可就大了。<br>一般来说，exit 0 可以告知你的程序的使用者：你的程序是正常结束的。如果 exit 非 0 值，那么你的程序的使用者通常会认为你的程序产生了一个错误。</p>
<p>以 shell 为例，在 shell 中调用完你的程序之后，用 echo $? 命令就可以看到你的程序的 exit 值。在 shell 脚本中，通常会根据上一个命令的 $? 值来进行一些流程控制。</p>
<h4 id="文件上传服务端"><a href="#文件上传服务端" class="headerlink" title="文件上传服务端"></a>文件上传服务端</h4><p>服务端的业务逻辑是这样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传文件的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvFileMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 接受客户端的报文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理心跳报文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理上传文件的请求报文</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        进一步的来讲是这样的，注意心跳报文，则是，如果此时接受的是&lt;a…..则处理，最开始还没明白这是怎么处理的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传文件的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvFileMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(strrecvbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strrecvbuffer));</span><br><span class="line">    <span class="built_in">memset</span>(strsendbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strsendbuffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端的报文,timetvl为扫描本地上传文件间隔，+10代表上传的真正时间（随意，+5也可以）</span></span><br><span class="line">    <span class="keyword">if</span>(TcpServer.<span class="built_in">Read</span>(strrecvbuffer, starg.timetvl + <span class="number">10</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;TcpServer.Read() failed.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;strrecvbuffer = %s\n&quot;</span>, strrecvbuffer);</span><br><span class="line">    <span class="comment">// 处理心跳报文</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(strrecvbuffer, <span class="string">&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(strsendbuffer, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;strsendbuffer = %s\n&quot;</span>, strsendbuffer);</span><br><span class="line">      <span class="keyword">if</span>(TcpServer.<span class="built_in">Write</span>(strsendbuffer) == <span class="literal">false</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;TcpServer.Write() failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理上传文件的请求报文</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(strrecvbuffer, <span class="string">&quot;&lt;filename&gt;&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 解析上传文件请求报文的xml</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 接受上传文件的内容</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把接受结果返回给对端</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="文件上传客户端"><a href="#文件上传客户端" class="headerlink" title="文件上传客户端"></a>文件上传客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件上传的主函数，执行一次文件上传的任务</span></span><br><span class="line"><span class="keyword">bool</span> _tcpputfiles()&#123;</span><br><span class="line">  <span class="comment">// 调用OpenDir()打开starg.clientpath目录</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 遍历目录中的每个文件，调用ReadDir()获取一个文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把文件名、修改时间、文件大小组成报文，发送给对端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把文件的内容发送给对端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受对端的确认报文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除或者转存本地的文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上传文件内容"><a href="#上传文件内容" class="headerlink" title="上传文件内容"></a>上传文件内容</h4><p>在建立过程中，最困难的工作就是实现传输，因此，我们有必要专门来讲解一下，如何在客户端实现发送和服务端实现接受</p>
<h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><h6 id="主框架"><a href="#主框架" class="headerlink" title="主框架"></a>主框架</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把文件的内容发送给对端</span></span><br><span class="line">   logfile.<span class="built_in">Write</span>(<span class="string">&quot;send %s(%d) ...&quot;</span>, Dir.m_FullFileName, Dir.m_FileSize);</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">SendFile</span>(TcpClient.m_connfd, Dir.m_FullFileName, Dir.m_FileSize) == <span class="literal">true</span>)&#123;</span><br><span class="line">     logfile.<span class="built_in">Write</span>(<span class="string">&quot;ok.\n&quot;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     logfile.<span class="built_in">Write</span>(<span class="string">&quot;failed.\n&quot;</span>);</span><br><span class="line">     TcpClient.<span class="built_in">Close</span>(); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile()"></a>sendfile()</h6><p>​        主要就是打开本地文件，然后发送本地文件，再关闭，就是有个细节，万一文件太大，无法一次打开，因此我们模拟缓冲区的思想，每次最多读1000个字节，但是<strong>注意</strong>：又是一场毒打，找了两个晚上的错误，真的找吐了，真不应该在脑袋昏昏沉沉的时候写代码，totalbytes局部变量最开始居然没初始化，最后我检查啊检查，已经检查到了，看到surfdata2里面生成了临时文件，但是0字节，又来比对了一次，结果还是没找出来，最后通过控制变量法，用吴哥的服务端，和客户端，以此与自己的匹配，最终确定是客户端的错误，在逐个比对，最终找到，呜呜呜呜呜呜</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 把文件的内容发送给对端</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">int</span> filesize)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>  onread = <span class="number">0</span>;       <span class="comment">// 每次调用fread时打算读取的字节数</span></span><br><span class="line">  <span class="keyword">int</span>  bytes  = <span class="number">0</span>;       <span class="comment">// 调用一次fread从文件中读取的字节数</span></span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1000</span>];     <span class="comment">// 存放读取数据的buffer</span></span><br><span class="line">  <span class="keyword">int</span>  totalbytes  = <span class="number">0</span>;       <span class="comment">// 从文件中已读取的字节总数， 真的是太难了，完全没发现没有初始化</span></span><br><span class="line">  FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以&quot;rb&quot;的模式打开文件</span></span><br><span class="line">  <span class="keyword">if</span>( (fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算本次应该读取的字节数，如果剩余数量超过1000字节，就打算读1000字节(模拟缓冲区，防止太大打不开)</span></span><br><span class="line">    <span class="keyword">if</span>(filesize - totalbytes &gt; <span class="number">1000</span>) onread = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> onread = filesize - totalbytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    bytes = <span class="built_in">fread</span>(buffer, <span class="number">1</span>, onread, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把读取到的数据发送给对端</span></span><br><span class="line">    <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Writen</span>(sockfd, buffer, bytes) == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算文件已读取的字节总数，如果文件已读完，跳出循环</span></span><br><span class="line">    totalbytes = totalbytes + bytes;</span><br><span class="line">    <span class="keyword">if</span>(totalbytes == filesize)  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h5><h6 id="RecvFile"><a href="#RecvFile" class="headerlink" title="RecvFile()"></a>RecvFile()</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受上传文件的内容</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">RecvFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mtime, <span class="keyword">int</span> filesize)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 生成临时的文件名</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建临时文件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 计算本次应该接受的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受文件内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把接收到的内容写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算已接收文件的总字节数，如果文件接受完，跳出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭临时文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置文件的时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把临时文件RENAME为正式的文件。</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除与转存文件"><a href="#删除与转存文件" class="headerlink" title="删除与转存文件"></a>删除与转存文件</h4><p>较为简单，简单看一下便是，仅仅只需要改动客户端，因为是上传功能，所以服务端没变化，客户端来决定把本地文件删除或者转存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除或者转存本地的文件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AckMessage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strrecvbuffer)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> filename[<span class="number">301</span>];</span><br><span class="line">  <span class="keyword">char</span> result[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(filename, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(filename));</span><br><span class="line">  <span class="built_in">memset</span>(result, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(result));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strrecvbuffer, <span class="string">&quot;filename&quot;</span>, filename, <span class="number">300</span>);</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strrecvbuffer, <span class="string">&quot;result&quot;</span>, result, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果服务端接受文件不成功，直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(result, <span class="string">&quot;ok&quot;</span>) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ptype == 1, 删除文件</span></span><br><span class="line">  <span class="keyword">if</span>(starg.ptype == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">REMOVE</span>(filename) == <span class="literal">false</span>) &#123;</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;REMOCE(%s) failed.\n&quot;</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ptype == 2, 移动到备份目录</span></span><br><span class="line">    <span class="keyword">if</span>(starg.ptype == <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">// 生成转存后备份目录的文件名。</span></span><br><span class="line">      <span class="keyword">char</span> bakfilename[<span class="number">301</span>];</span><br><span class="line">      <span class="built_in">STRCPY</span>(bakfilename, <span class="built_in"><span class="keyword">sizeof</span></span>(bakfilename), filename);</span><br><span class="line">      <span class="built_in">UpdateStr</span>(bakfilename, starg.clientpath, starg.clientpathbak, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">RENAME</span>(filename, bakfilename) == <span class="literal">false</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;RENAME(%s, %s) failed.\n&quot;</span>, filename, bakfilename);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步–异步通信"><a href="#同步–异步通信" class="headerlink" title="同步–异步通信"></a>同步–异步通信</h3><p>​        不管是FTP协议，还是TCP协议，都是同步通信，接下来会介绍几种异步通信的方式</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>​        同步通讯效率比较低，因为把大量的时间都浪费在等待上了，但是也有个好处，就是流程很简单，一问一答这种方式，程序写起来也非常简单<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427211128074.png" alt="image-20220427211128074"></p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>​        客户端发送n个请求，同时也会接收到很多回应，采用异步通信，不会把时间浪费在等待上面，所以效率非常高，但是也带来了新的问题，就是流程控制很麻烦，程序也会更复杂</p>
<p>​        比如说，客户端向服务端发送了1000个请求，这个时候网络断开了，此时客户端只收到了500个回应，还有500个回应没收到，此时客户端并不知道服务端到底处理成功与否，这种事情没有固定的解决方法，<strong>不同的业务有不同的方法</strong>，总的来说，要解决都是很麻烦的，不会太简单。</p>
<h5 id="异步通信的实现"><a href="#异步通信的实现" class="headerlink" title="异步通信的实现"></a>异步通信的实现<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427213120763.png" alt="image-20220427213120763"></h5><ul>
<li> 多进程，即fork()，使得父进程和子进程能够自己做自己的事情</li>
<li>多线程，暂时还未涉及，后面会讲</li>
<li>IO复用有点难，不是几句话能讲的，后面再讲</li>
</ul>
<h6 id="多进程实现"><a href="#多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h6><p>此时还是同步的，按部就班的，发一个接受一个<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427214640478.png" alt="image-20220427214640478"></p>
<p>​        此时进行一次fork分叉，分成一个子进程和一个父进程，父进程负责发送请求，子进程负责接受回应，也就是进行了一个分工，其中，我认为由父进程来发送是很有好处的，理由是，如果用子进程来发送，pid&lt;0为异常情况，可能就会发生，程序已经出现异常了，但仍然发送报文的情况，因此，用父进程来把控发送全局，是很好的。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427214748831.png" alt="image-20220427214748831"></p>
<p>这就是异步的显示情况<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427214952066.png" alt="image-20220427214952066"></p>
<p>我们通过改大数据，发现<strong>同步</strong>通信，每秒传输大概在<strong>2000</strong>个报文左右，<strong>异步</strong>通信则是<strong>80000</strong>个，这明显不是在一个数量级的</p>
<h6 id="IO复用演示"><a href="#IO复用演示" class="headerlink" title="IO复用演示"></a>IO复用演示</h6><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427215450591.png" alt="image-20220427215450591"></p>
<p>没有数据，直接返回，不会等待，有数据继续下面的流程，读取数据（现在只用知道这样就可以了，以后会详细讲解<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427215523611.png" alt="image-20220427215523611"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427215724609.png" alt="image-20220427215724609"></p>
<p>用while循环装起来，tcpread参数改为-1<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427215742193.png" alt="image-20220427215742193"></p>
<p>15秒开始<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427215955244.png" alt="image-20220427215955244"></p>
<p>51秒结束<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427220015707.png" alt="image-20220427220015707"></p>
<p>但是仔细看，我们这个程序，其实是存在缺陷的，虽然都发过去了，但是采用的IO复用，不等待，所以，服务端还没来得及回应完全部</p>
<p>​        所以，我们应该在for循环外面，再补接一下最后的结束，我们用一个计数器，来记录总共接收到的个数，确保接收完毕后及时退出for循环外的while循环（判断jj &lt; 1000000)就退了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427220517983.png" alt="image-20220427220517983"></p>
<p>一百万之后，只接受ok，没有报文可以发了。</p>
<p>​        采用IO复用技术实现异步通信，代码的开销比多进程和多线程要多一些，原因就是因为<strong>while循环哪些代码的开销</strong>，肯定比不上让一个进程或者线程在哪里等待<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427220729489.png" alt="image-20220427220729489"></p>
<h4 id="文件上传-异步"><a href="#文件上传-异步" class="headerlink" title="文件上传(异步)"></a>文件上传(异步)</h4><p>​        我们之前实现的上传功能是用的同步方式，接下来，我们尝试将它改成异步</p>
<p>​        目前为止，我们的程序的效率，大概每秒上传100个左右的文件<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427221049221.png" alt="image-20220427221049221"></p>
<p>​        我们现在考虑采用IO技术来实现异步通信，虽然多进程和多线程的效率更高，但是进程或者线程之间，需要做同步，比较麻烦（考虑这次执行那个进程，这次执行那个线程，需要调度）</p>
<p>​        在文件上传的主函数，定义一个文件数量的变量，每<strong>收到一个</strong>报文，这个delayed的值<strong>减一</strong><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427221441002.png" alt="image-20220427221441002"></p>
<p>​        再while循环里面，当delayed还有剩余时，疯狂TcpRead，然后delayed一没有，就退出，最后再在while循环外面加追加接受对端确认报文的函数（基本一样=-=)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 接受对端的确认报文</span></span><br><span class="line">  <span class="keyword">while</span>(delayed &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(strrecvbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strrecvbuffer));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TcpRead</span>(TcpClient.m_connfd, strrecvbuffer, &amp;buflen, <span class="number">-1</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// logfile.Write(&quot;strrecvbuffer = %s\n&quot;, strrecvbuffer);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除或者转存本地的文件</span></span><br><span class="line">    delayed--;</span><br><span class="line">  <span class="built_in">AckMessage</span>(strrecvbuffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续接受对端的确认报文</span></span><br><span class="line"><span class="comment">// read不用-1了，最多一两秒就能延迟结束，这里用10吧</span></span><br><span class="line"><span class="keyword">while</span>(delayed &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">memset</span>(strrecvbuffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strrecvbuffer));</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">TcpRead</span>(TcpClient.m_connfd, strrecvbuffer, &amp;buflen, <span class="number">10</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logfile.Write(&quot;strrecvbuffer = %s\n&quot;, strrecvbuffer);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除或者转存本地的文件</span></span><br><span class="line">  delayed--;</span><br><span class="line">  <span class="built_in">AckMessage</span>(strrecvbuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427222710108.png" alt="image-20220427222710108"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427222747172.png" alt="image-20220427222747172"></p>
<p>5000个文件，大概在10秒左右，每秒500个左右，之前同步通信在100左右，异步比同步<strong>快五倍</strong></p>
<h5 id="收尾-优化"><a href="#收尾-优化" class="headerlink" title="收尾+优化"></a>收尾+优化</h5><p>核心功能已经全部实现，接下来是优化细节</p>
<h6 id="时间间隔优化"><a href="#时间间隔优化" class="headerlink" title="时间间隔优化"></a>时间间隔优化</h6><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427222937938.png" alt="image-20220427222937938"></p>
<p>每上传一次，就sleep这么多秒，我们说这样不是最合理的，为什么这么说？<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427222953525.png" alt="image-20220427222953525"></p>
<p>​        如果一个目录下不断地有文件生成，生成的个数和时间都是不定的，例如有20个文件，文件上传一次把20个文件给传出去了，但是传输的过程中又有文件不断生成，这些只能等到下一次sleep结束才能执行，我们可以做一些优化，每次执行文件传输任务的时候，如果有传输成功的文件，说明系统比较忙，那么在执行完这次文件传输之后，就不要sleep了，继续去执行文件传输的任务，如果某次执行了_tcpputfiles之后，文件传输返回失败，说明此时没有这么忙了，才让他去sleep。这么做应该更合理</p>
<p>​        定义一个全局的bool变量，默认为true，再判断好空闲时候的处理，进入_tcpputfiles(),进去后把bcontinue设置为false，每获得一个文件就把bcontinue设置为true就好啦<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427223645345.png" alt="image-20220427223645345"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427223922059.png" alt="image-20220427223922059"></p>
<h6 id="心跳优化"><a href="#心跳优化" class="headerlink" title="心跳优化"></a>心跳优化</h6><p>启用心跳</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427224055224.png" alt="image-20220427224055224"></p>
<p>​        接着就是不断的考虑，在可能需要花费时间的地方做进程的心跳，更新心跳（服务端和客户端一起）</p>
<p>​        也要在服务端的每一个子进程里面做心跳，最开始使用<strong>AddPInfo</strong>创建心跳信息，后面while里面不断更新它！<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220427225008110.png" alt="image-20220427225008110"></p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428102338835.png" alt="image-20220428102338835"></h3><p>对客户端而言，文件下载，就是服务端的文件上传主函数，文件上传客户端的代码就是服务端的文件下载主函数代码</p>
<p>功能完善后，将此功能加入start.sh和killall.sh脚本，并且将两个文件系统的功能衔接起来使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件传输的服务端程序</span></span><br><span class="line">/project/tools1/bin/procctl 10 /project/tools1/bin/fileserver 5005 /<span class="built_in">log</span>/idc/fileserver.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把目录/tmp/ftpputest中的文件上传到/tmp/tcpputest目录中。</span></span><br><span class="line">/project/tools1/bin/procctl 20 /project/tools1/bin/tcpputfiles /<span class="built_in">log</span>/idc/tcpputfiles_surfdata.log <span class="string">&quot;&lt;ip&gt;127.0.0.1&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;clientpath&gt;/tmp/ftpputest&lt;/clientpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;srvpath&gt;/tmp/tcpputest&lt;/srvpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpputfiles_surfdata&lt;/pname&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把目录/tmp/tcpputest中的文件下载到/tmp/tcpgetest目录中。</span></span><br><span class="line">/project/tools1/bin/procctl 20 /project/tools1/bin/tcpgetfiles /<span class="built_in">log</span>/idc/tcpgetfiles_surfdata.log <span class="string">&quot;&lt;ip&gt;127.0.0.1&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;srvpath&gt;/tmp/tcpputest&lt;/srvpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;clientpath&gt;/tmp/tcpgetest&lt;/clientpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpgetfiles_surfdata&lt;/pname&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理采集的全国气象站点观测的分钟数据目录/tmp/tcpgetest中的历史数据文件。</span></span><br><span class="line">/project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /tmp/tcpgetest <span class="string">&quot;*&quot;</span> 0.02</span><br></pre></td></tr></table></figure>

<h2 id="学习总结-1"><a href="#学习总结-1" class="headerlink" title="学习总结"></a>学习总结</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428132635971.png" alt="image-20220428132635971"></p>
<ul>
<li><p> 计算机网络基础，一定要系统的学习，面试的常考点，并且理论和实践结合才能走的更远</p>
</li>
<li><p>没有封装的socketAPI，我们不知道该怎么开始实现程序</p>
</li>
<li><p>多进程是一种比较传统的方法，对高并发系统不适用，但是对并发需求不是这么高的，是一种不错的选择，程序流程简单，代码实现也比较容易。</p>
</li>
<li><p>实现采用TCP协议的文件传输和下载，这个是十分重要的系统，以后我们做的很多项目都可以使用它，只要学好了网络编程的基础知识，实现文件传输没有什么问题，重要的是采用异步通信提升性能，但是异步通信的实现就会带来编写代码的困难</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428133226638.png" alt="image-20220428133226638"></p>
<p>​    例如每个月有很多企业向银行发送转账信息，但是银行首先得保证自己不死，然后对每个企业进行限流，如果企业发多了就返回转账失败，这里我们做流量控制，方法有很多，最常用的就是滑动窗口，也是企业常用的，面试常考的</p>
</li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>计网学完记得闪耀回归~</p>
<h2 id="五、MySQL数据库开发"><a href="#五、MySQL数据库开发" class="headerlink" title="五、MySQL数据库开发"></a>五、MySQL数据库开发</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428202945272.png" alt="image-20220428202945272"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428203028751.png" alt="image-20220428203028751"></p>
<p>​        暂时不研究connection和sqlstatement的底层封装，现在能力有限</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428203126644.png" alt="image-20220428203126644"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428203204611.png" alt="image-20220428203204611"></p>
<p>我们现在开始走马观花的跑一遍头文件</p>
<p>filetobuf和buftofile用于操纵二进制文件<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428211737090.png" alt="image-20220428211737090"></p>
<p>CDA_DEF用于存放对数据操作的结果<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428211844815.png" alt="image-20220428211844815"></p>
<p>connection连接类，有几个主要的功能，连接，提交，回滚，断开</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220428211926373.png" alt="image-20220428211926373"></p>
<p>sqlstatement类用于操纵数据</p>
<p>这些都是到时候再说，下面我们来完成建库操作</p>
<h3 id="MySQL建库"><a href="#MySQL建库" class="headerlink" title="MySQL建库"></a>MySQL建库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   程序名：createtable.cpp 此程序演示开发框架操作MySQL数据库（创建表）</span></span><br><span class="line"><span class="comment">*   作者：jjyaoao</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_mysql.h&quot;</span>     <span class="comment">// 开发框架操作MySQL的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    connection conn;       <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span></span><br><span class="line">    <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span>(conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;127.0.0.1,root,123456,h2,3306&quot;</span>,<span class="string">&quot;utf8&quot;</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>, conn.m_cda.message);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>;   <span class="comment">// 执行sql语句的对象</span></span><br><span class="line">    <span class="comment">// sqlstatement stmt;   stmt.connect(&amp;conn);  和上面一行一样的意思 sqlstatement两个构造函数</span></span><br><span class="line">     stmt.<span class="built_in">prepare</span>(<span class="string">&quot;create table girls(id      bigint(10),\</span></span><br><span class="line"><span class="string">                   name    varchar(30),\</span></span><br><span class="line"><span class="string">                   weight  decimal(8,2),\</span></span><br><span class="line"><span class="string">                   btime   datetime,\</span></span><br><span class="line"><span class="string">                   memo    longtext,\</span></span><br><span class="line"><span class="string">                   pic     longblob,\</span></span><br><span class="line"><span class="string">                   primary key (id))&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220507141053221.png" alt="image-20220507141053221"></p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入，修改代码流程基本完全一样</p>
<p>插入数据的程序虽然没能跑出来，但业务逻辑大抵是这样的：</p>
<ol>
<li>登录数据库</li>
<li>定义存放单个信息的结构体</li>
<li>将结构体与操作数据库对象的每一个参数连接起来</li>
<li>执行插入<ol>
<li>清空结构体一次</li>
<li>注入信息一次</li>
<li>执行一次操作：execute() </li>
</ol>
</li>
<li>提交事务</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   程序名：createtable.cpp 此程序演示开发框架操作MySQL数据库（创建表）</span></span><br><span class="line"><span class="comment">*   作者：jjyaoao</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;_mysql.h&quot;</span>     <span class="comment">// 开发框架操作MySQL的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    connection conn;       <span class="comment">// 数据库连接类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span></span><br><span class="line">    <span class="comment">// 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span>(conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;127.0.0.1,root,123456,h2,3306&quot;</span>,<span class="string">&quot;utf8&quot;</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;connect database failed.\n%s\n&quot;</span>, conn.m_cda.message);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义用于超女信息的结构，与表中字段对应</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_girls</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span>    id;         <span class="comment">// 超女编号</span></span><br><span class="line">        <span class="keyword">char</span>    name[<span class="number">31</span>];   <span class="comment">// 超女姓名</span></span><br><span class="line">        <span class="keyword">double</span>  weight;     <span class="comment">// 超女体重</span></span><br><span class="line">        <span class="keyword">char</span>    btime[<span class="number">20</span>];  <span class="comment">// 报名时间</span></span><br><span class="line">    &#125;   stgirls;</span><br><span class="line"></span><br><span class="line">    <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>;  <span class="comment">// 操作SQL语句的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备插入表的SQL语句   注意，时间哪里使用一个百分号会段错误，得用转译%,因为%d之类的，代表这需要一个整数... str_to_date(:4,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;))&quot;);</span></span><br><span class="line">    stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">        insert into girls(id,name,weight,btime) values(:1,:2,:3,str_to_date(:4,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;))&quot;</span>);<span class="comment">// :1 :2 :3 :4统一用?代替也可以，但?的兼容性不太好</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">//printf(&quot;%s&quot;, stmt.m_cda.message); </span></span><br><span class="line">        stmt.<span class="built_in">bindin</span>(<span class="number">1</span>, &amp;stgirls.id);</span><br><span class="line">        stmt.<span class="built_in">bindin</span>(<span class="number">2</span>, stgirls.name, <span class="number">30</span>);</span><br><span class="line">        stmt.<span class="built_in">bindin</span>(<span class="number">3</span>, &amp;stgirls.weight);</span><br><span class="line">        stmt.<span class="built_in">bindin</span>(<span class="number">4</span>, stgirls.btime, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟超女数据，向表中插入5条测试数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;stgirls, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_girls));   <span class="comment">// 结构体变量初始化</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为结构体变量的成员赋值</span></span><br><span class="line">        stgirls.id = i + <span class="number">1</span>;                             <span class="comment">// 超女编号</span></span><br><span class="line">        <span class="built_in">sprintf</span>(stgirls.name, <span class="string">&quot;西施%05dgirl&quot;</span>, i + <span class="number">1</span>);   <span class="comment">// 超女姓名</span></span><br><span class="line">        stgirls.weight = <span class="number">45.25</span> + i;                     <span class="comment">// 超女体重</span></span><br><span class="line">        <span class="built_in">sprintf</span>(stgirls.btime, <span class="string">&quot;2022-05-07 14:47:%02d&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>, stmt.m_sql, stmt.m_cda.message);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功的插入了1条记录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;insert table girls ok.\n&quot;</span>);</span><br><span class="line">    conn.<span class="built_in">commit</span>();<span class="comment">//提交数据库事务，不提交会回滚事务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意事项：</span></span><br><span class="line"><span class="comment">    1、参数的序号从1开始，连续、递增，参数也可以用问号表示，但是，问号的兼容性不好，不建议；</span></span><br><span class="line"><span class="comment">    2、SQL语句中的右值才能作为参数，表名、字段名、关键字、函数名等都不能作为参数；</span></span><br><span class="line"><span class="comment">    3、参数可以参与运算或用于函数的参数；例如：values(:1+1,:2,:3+45.35)</span></span><br><span class="line"><span class="comment">    4、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；</span></span><br><span class="line"><span class="comment">    5、SQL语句中的每个参数，必须调用bindin()绑定变量的地址；</span></span><br><span class="line"><span class="comment">    6、如果SQL语句的主体已改变，prepare()后，需重新用bindin()绑定变量；</span></span><br><span class="line"><span class="comment">    7、prepare()方法有返回值，一般不检查，如果SQL语句有问题，调用execute()方法时能发现；</span></span><br><span class="line"><span class="comment">    8、bindin()方法的返回值固定为0，不用判断返回值；</span></span><br><span class="line"><span class="comment">    9、prepare()和bindin()之后，每调用一次execute()，就执行一次SQL语句，SQL语句的数据来自被绑定变量的值。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>手动执行查询语句<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220510210014029.png" alt="image-20220510210014029"></p>
<p>与其他语句最大的不同点，在于查询语句需要返回一个结果集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> iminid,imaxid;  <span class="comment">// 查询条件最小和最大的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">    select id,name,weight,date_format(btime,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意事项：</span></span><br><span class="line"><span class="comment">    1、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；也就是说，prepare尽量放循环外，每prepare一次，会产生IO</span></span><br><span class="line"><span class="comment">    2、结果集中的字段，调用bindout()绑定变量的地址；</span></span><br><span class="line"><span class="comment">    3、bindout()方法的返回值固定为0，不用判断返回值；</span></span><br><span class="line"><span class="comment">    4、如果SQL语句的主体已改变，prepare()后，需重新用bindout()绑定变量；</span></span><br><span class="line"><span class="comment">    5、调用execute()方法执行SQL语句，然后再循环调用next()方法获取结果集中的记录；</span></span><br><span class="line"><span class="comment">    6、每调用一次next()方法，从结果集中获取一条记录，字段内容保存在已绑定的变量中。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;iminid);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;imaxid);</span><br><span class="line">  <span class="comment">// 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stgirls.name,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stgirls.weight);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">4</span>, stgirls.btime,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">  iminid=<span class="number">1</span>;    <span class="comment">// 指定待查询记录的最小id的值。</span></span><br><span class="line">  imaxid=<span class="number">3</span>;    <span class="comment">// 指定待查询记录的最大id的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_girls));         <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把获取到的记录的值打印出来。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id=%ld,name=%s,weight=%.02f,btime=%s\n&quot;</span>,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二进制大对象"><a href="#二进制大对象" class="headerlink" title="二进制大对象"></a>二进制大对象</h3><p>将本地大对象存入数据库里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 定义用于超女信息的结构，与表中的字段对应。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_girls</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">long</span>   id;             <span class="comment">// 超女编号</span></span><br><span class="line">    <span class="keyword">char</span>   pic[<span class="number">100000</span>];    <span class="comment">// 超女图片的内容。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> picsize; <span class="comment">// 图片内容占用的字节数。</span></span><br><span class="line">  &#125; stgirls;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>;  <span class="comment">// 操作SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备修改表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;update girls set pic=:1 where id=:2&quot;</span>);</span><br><span class="line">  stmt.<span class="built_in">bindinlob</span>(<span class="number">1</span>, stgirls.pic,&amp;stgirls.picsize);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,&amp;stgirls.id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改超女信息表中id为1、2的记录。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;<span class="number">3</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_girls));         <span class="comment">// 结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体变量的成员赋值。</span></span><br><span class="line">    stgirls.id=ii;                                   <span class="comment">// 超女编号。</span></span><br><span class="line">    <span class="comment">// 把图片的内容加载到stgirls.pic中。</span></span><br><span class="line">    <span class="keyword">if</span> (ii==<span class="number">1</span>) stgirls.picsize=<span class="built_in">filetobuf</span>(<span class="string">&quot;1.jpg&quot;</span>,stgirls.pic);<span class="comment">//这里放在同一个文件夹内，就可以使用相对地址</span></span><br><span class="line">    <span class="keyword">if</span> (ii==<span class="number">2</span>) stgirls.picsize=<span class="built_in">filetobuf</span>(<span class="string">&quot;2.jpg&quot;</span>,stgirls.pic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">    <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功修改了%ld条记录。\n&quot;</span>,stmt.m_cda.rpc); <span class="comment">// stmt.m_cda.rpc是本次执行SQL影响的记录数。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;update table girls ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>();   <span class="comment">// 提交数据库事务。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从数据库取出大对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备查询表的SQL语句。</span></span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select id,pic from girls where id in (1,2)&quot;</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;stgirls.id);</span><br><span class="line">  stmt.<span class="built_in">bindoutlob</span>(<span class="number">2</span>, stgirls.pic,<span class="number">100000</span>,&amp;stgirls.picsize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span></span><br><span class="line">  <span class="comment">// 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的  缓冲区  中产生一个结果集。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirls,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(stgirls)); <span class="comment">// 先把结构体变量初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span></span><br><span class="line">    <span class="comment">// 在实际开发中，除了0和1403，其它的情况极少出现。</span></span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成文件名。</span></span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">101</span>]; <span class="built_in">memset</span>(filename,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(filename));</span><br><span class="line">    <span class="built_in">sprintf</span>(filename,<span class="string">&quot;%d_out.jpg&quot;</span>,stgirls.id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把内容写入文件。</span></span><br><span class="line">    <span class="built_in">buftofile</span>(filename,stgirls.pic,stgirls.picsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本次查询了girls表%ld条记录。\n&quot;</span>,stmt.m_cda.rpc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大对象操作的启示"><a href="#大对象操作的启示" class="headerlink" title="大对象操作的启示"></a>大对象操作的启示</h4><p>这样数据库就不会有压力~~</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511110149257.png" alt="image-20220511110149257"></p>
<h3 id="数据库开发注意事项和技巧"><a href="#数据库开发注意事项和技巧" class="headerlink" title="数据库开发注意事项和技巧"></a>数据库开发注意事项和技巧</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>一个connection对象同一时间仅连一个数据库，多个connection可以同时连多个数据库，并且每个对象之间的处理，不互相影响，按照顺序依次执行</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511194657524.png" alt="image-20220511194657524"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511195036825.png" alt="image-20220511195036825"></p>
<p>​        这个很容易理解，试想一下，如果一个进程要求提交事务，另一个进程却想要回滚，自然只会满足一个的需求，也就是报错了，虽然我们可以选择，比如给数据库连接加锁之类的方法，但是，他仍然是很麻烦的，不如我们先fork()后再登陆<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511195419309.png" alt="image-20220511195419309"></p>
<p>这样的话，就没有问题了<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511195441666.png" alt="image-20220511195441666"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511195513385.png" alt="image-20220511195513385"></p>
<p>​        这句话也就是说，在一个数据库的连接中，可以执行多条sql语句（sqlstatement是执行sql语句的对象）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511195604976.png" alt="image-20220511195604976"></p>
<p>​        并且注意，在这里直接execute()，并没有使用prepare，是因为我们封装了方法，如果没有绑定输入和输出变量，那我们可以直接execute()，这样是为了我们写代码的方便</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511195907921.png" alt="image-20220511195907921"></p>
<p>这一点是MySQL的缺点，给我们带来了不少麻烦</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511200212767.png" alt="image-20220511200212767"><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511200233370.png" alt="image-20220511200233370"></p>
<p>​        2014错误，百度的大概意思就是上面的，没有取完之前不能执行，增加一行代码while（只取结果集），最后就不会报错了，具体解决方法，等以后有应用背景了再回来激战</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511200341659.png" alt="image-20220511200341659"></p>
<h4 id="应用技巧"><a href="#应用技巧" class="headerlink" title="应用技巧"></a>应用技巧</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220511200457565.png" alt="image-20220511200457565"></p>
<p>首先我们来演示在命令行是如何处理的….</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">insert into girls(id) values(30);</span><br><span class="line">insert into girls(id, weight) values(31, null);</span><br><span class="line">insert into girls(id, weight) values(32, &#x27;45.33&#x27;);</span><br><span class="line">insert into girls(id, weight) values(33, &#x27;&#x27;);</span><br><span class="line">-- ERROR 1366 (HY000): Incorrect decimal value: &#x27;&#x27; for column &#x27;weight&#x27; at row 1</span><br><span class="line">select * from girls;</span><br><span class="line">| 30 | NULL            |   NULL | NULL                | NULL | NULL |</span><br><span class="line">| 31 | NULL            |   NULL | NULL                | NULL | NULL |</span><br><span class="line">| 32 | NULL            |  45.33 | NULL                | NULL | NULL |</span><br><span class="line">+----+-----------------+--------+---------------------+------+------+</span><br></pre></td></tr></table></figure>

<p>其次，在程序中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.<span class="built_in">prepare</span>(<span class="string">&quot;insert into girls(id,name,weight,btime) values(:1,:2,:3,str_to_date(:4,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;))&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们不可能提前知道weight会不会填 空或者不写</p>
<p>有一个解决方法，我们把体重改成字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double  weight;     // 超女体重       ----------------&gt;    char	 weight[10];</span><br></pre></td></tr></table></figure>

<p>用框架bindin，可以直接填<code>&#39;&#39;</code> ,因为我们做了封装，现在不研究，因为并不容易，以后有实力的再研究</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理字符串字段为空的情况。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;maxbindin;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (params_in[ii].buffer_type == MYSQL_TYPE_VAR_STRING )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strlen</span>((<span class="keyword">char</span> *)params_in[ii].buffer)==<span class="number">0</span>) </span><br><span class="line">      &#123;</span><br><span class="line">        params_in_is_null[ii]=<span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123;</span><br><span class="line">        params_in_is_null[ii]=<span class="literal">false</span>;</span><br><span class="line">        params_in_length[ii]=<span class="built_in">strlen</span>((<span class="keyword">char</span> *)params_in[ii].buffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (params_in[ii].buffer_type == MYSQL_TYPE_BLOB )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*params_in[ii].length)==<span class="number">0</span>) </span><br><span class="line">        params_in_is_null[ii]=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        params_in_is_null[ii]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这个技巧非常重要，以后工作中应该用得上，面试也可能会被问起</p>
<p>我们可以理解为：只要<strong>不做计算</strong>，我们对数据的存放，都统一采用字符串！</p>
<p>​        当然，数据变为字符串，对于<strong>浮点数</strong>而言我们通常需要将其变为整数，方便存储，这里定义一个临时变量（和wf一样，char类型 [11])</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(stzhobtmind.wf,<span class="number">10</span>,<span class="string">&quot;%d&quot;</span>,(<span class="keyword">int</span>)(<span class="built_in">atof</span>(tmp)*<span class="number">10</span>));</span><br><span class="line"><span class="comment">// 将tmp字符串的字符转为整数，再乘10(说明tmp里本身小数点后一位)，最后存入stzhobtmind.wf（存十位进去，wf为char类型，[11]）</span></span><br></pre></td></tr></table></figure>

<h3 id="强大的PowerDesigner"><a href="#强大的PowerDesigner" class="headerlink" title="强大的PowerDesigner"></a>强大的PowerDesigner</h3><p>自增字段，一定要设置为键，而不是组件</p>
<p>最重要的，表名（General），列（Columns），索引（Indexes），键（Keys）</p>
<p>次重要  物理选项（Physical Options）：可能以后会设置一些物理参数</p>
<h3 id="站点参数文件入库"><a href="#站点参数文件入库" class="headerlink" title="站点参数文件入库"></a>站点参数文件入库</h3><p>这里我们继续做项目……</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220512162250959.png" alt="image-20220512162250959"></p>
<p>这里有一个细节，为什么经纬度明明是浮点数，我们却用整数，原因很简单：</p>
<ol>
<li>整数运算速度快，相比于浮点数复杂的加减乘除</li>
<li>整数可以代替浮点数，只要我们记住了保留小数点后多少位<ol>
<li>例如在银行查询余额，如果还剩下1.25元，那么可以使用125在底层存放，只需要在对应的位置加上小数点就可以了</li>
<li>这样我们使用的<strong>存储空间更小</strong>，运算的<strong>效率也更高</strong></li>
</ol>
</li>
</ol>
<h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 帮助文档</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理程序退出的信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开日志文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把全国站点参数文件加载到vstcode容器中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备插入表的SQL语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备更新表的SQL语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历vstcode容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vstcode.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="comment">// 从容器中取出一条记录放入结构体中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行插入的SQL语句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果记录已存在，执行更新的SQL语句</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们提几点</p>
<ol>
<li> 为什么要用vstcode加载到容器中，而不直接打开文件，一行一行的循环读入呢？</li>
<li>处理方法本来就不唯一，习惯哪一种写法，就写哪一种写法</li>
<li>连接数据库的代码一定要放在加载参数文件之后，如果加载参数失败，后面的流程根本就不需要继续，数据库也不用连了。</li>
<li>判断记录已存在的方法，是判断SQL语句返回的结果，如果记录已存在，那么插入记录返回的结果是1062<ol>
<li><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220512164959900.png" alt="image-20220512164959900"></li>
</ol>
</li>
</ol>
<h4 id="开始战斗"><a href="#开始战斗" class="headerlink" title="开始战斗"></a>开始战斗</h4><p>在我们的表里，将mysql数据库的height故意设置为可以为空，这里是为了处理之前留下的应用技巧（就上上上个标题）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc T_ZHOBTCODE;</span><br><span class="line">+----------+-------------+------+-----+-------------------+-----------------------------+</span><br><span class="line">| Field    | Type        | Null | Key | Default           | Extra                       |</span><br><span class="line">+----------+-------------+------+-----+-------------------+-----------------------------+</span><br><span class="line">| obtid    | varchar(10) | NO   | PRI | NULL              |                             |</span><br><span class="line">| cityname | varchar(30) | NO   |     | NULL              |                             |</span><br><span class="line">| provname | varchar(30) | NO   |     | NULL              |                             |</span><br><span class="line">| lat      | int(11)     | NO   |     | NULL              |                             |</span><br><span class="line">| lon      | int(11)     | NO   |     | NULL              |                             |</span><br><span class="line">| height   | int(11)     | YES  |     | NULL              |                             |</span><br><span class="line">| upttime  | timestamp   | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |</span><br><span class="line">| keyid    | int(11)     | NO   | MUL | NULL              |                             |</span><br><span class="line">+----------+-------------+------+-----+-------------------+-----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全国气象站点参数结构体。    将原本double的lat lon height 全员改为char</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_stcode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> provname[<span class="number">31</span>]; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">char</span> obtid[<span class="number">11</span>];    <span class="comment">// 站号</span></span><br><span class="line">  <span class="keyword">char</span> cityname[<span class="number">31</span>];  <span class="comment">// 站名</span></span><br><span class="line">  <span class="keyword">char</span> lat[<span class="number">11</span>];      <span class="comment">// 纬度     </span></span><br><span class="line">  <span class="keyword">char</span> lon[<span class="number">11</span>];      <span class="comment">// 经度</span></span><br><span class="line">  <span class="keyword">char</span> height[<span class="number">11</span>];   <span class="comment">// 海拔高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="心跳进程小技巧"><a href="#心跳进程小技巧" class="headerlink" title="心跳进程小技巧"></a>心跳进程小技巧</h4><p>​        由于该程序通常来讲执行之间都不会超过1s，所以心跳处理非常简单，并且如果要用GDB调试，可以考虑注释掉心跳（防止被守护进程杀掉），或者心跳时间调的足够长<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220512193719703.png" alt="image-20220512193719703"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PActive.<span class="built_in">AddPInfo</span>(<span class="number">10</span>,<span class="string">&quot;obtcodetodb&quot;</span>);   <span class="comment">// 进程的心跳，10秒足够。</span></span><br><span class="line"><span class="comment">// 注意，在调试程序的时候，可以启用类似以下的代码，防止超时。 </span></span><br><span class="line"><span class="comment">// PActive.AddPInfo(5000,&quot;obtcodetodb&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="站点数据入库"><a href="#站点数据入库" class="headerlink" title="站点数据入库"></a>站点数据入库</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220514113120416.png" alt="image-20220514113120416"></p>
<h4 id="基础业务逻辑"><a href="#基础业务逻辑" class="headerlink" title="基础业务逻辑"></a>基础业务逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _obtmindtodb(<span class="keyword">char</span> *pathname,<span class="keyword">char</span> *connstr,<span class="keyword">char</span> *charset)&#123;</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取目录，得到一个数据文件名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 处理文件中的每一行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除文件、提交事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要创建表</p>
<p>其中有一个细节：</p>
<p>对这个唯一索引而言，是时间在前，obtid在后</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220514122449901.png" alt="image-20220514122449901"></p>
<p>而对于主键索引而言，是先obtid（站点代码）后数据时间</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220514122703226.png" alt="image-20220514122703226"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220514122423373.png" alt="image-20220514122423373"></p>
<p>因此，写这两行语句，利用的东西是不同的。</p>
<p>​        对于这个程序，我们只提供插入功能，不提供修改功能，原因是这样的：</p>
<ul>
<li>观测数据是由观测设备产生，比如说温度，设备感应到是35度，就是35度，这个错了就错了，没办法改变，如果设备的传感器出了问题，可以把数据标志为不可用，但是修改数据是不可能的，这么多设备，产生那么多数据，根本改不过来的。</li>
<li>也可以换一种思维方式：设备已经出问题了，那么就没有正确的数据了，那么，既然没有正确的数据，哪来的修改？</li>
</ul>
<h4 id="正式业务demo"><a href="#正式业务demo" class="headerlink" title="正式业务demo"></a>正式业务demo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _obtmindtodb(<span class="keyword">char</span> *pathname,<span class="keyword">char</span> *connstr,<span class="keyword">char</span> *charset)&#123;</span><br><span class="line">    sqlstatement stmt;</span><br><span class="line"></span><br><span class="line">    CDir Dir;</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    <span class="keyword">if</span>(Dir.<span class="built_in">OpenDir</span>(pathname, <span class="string">&quot;*.xml&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;Dir.OpenDir(%s) failed.\n&quot;</span>, pathname);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFile File;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取目录，得到一个数据文件名</span></span><br><span class="line">        <span class="keyword">if</span>(Dir.<span class="built_in">ReadDir</span>() == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接数据库。</span></span><br><span class="line">        <span class="keyword">if</span>(conn.m_state == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(connstr, charset)!=<span class="number">0</span>) &#123;</span><br><span class="line">            logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) failed.\n%s\n&quot;</span>, connstr, conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) ok.\n&quot;</span>, connstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stmt.m_state == <span class="number">0</span>)&#123;</span><br><span class="line">          stmt.<span class="built_in">connect</span>(&amp;conn);</span><br><span class="line">          stmt.<span class="built_in">prepare</span>(<span class="string">&quot;insert into T_ZHOBTMIND(obtid, ddatetime, t, p, u, wd, wf, r, vis) \</span></span><br><span class="line"><span class="string">          values(:1, str_to_date(:2, &#x27;%%Y%%m%%d%%H%%i%%s&#x27;), :3, :4, :5, :6, :7, :8, :9)&quot;</span>);</span><br><span class="line">          stmt.<span class="built_in">bindin</span>(<span class="number">1</span>, stzhobtmind.obtid, <span class="number">10</span>);<span class="comment">// bindin2  bindin3..........</span></span><br><span class="line">        &#125;</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;filename = %s\n&quot;</span>, Dir.m_FullFileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line">        <span class="keyword">if</span>(File.<span class="built_in">Open</span>(Dir.m_FullFileName, <span class="string">&quot;r&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">          logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.Open(%s) failed.\n&quot;</span>, Dir.m_FullFileName);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> strBuffer[<span class="number">1001</span>];   <span class="comment">// 存放从文件中读取的一行。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(File.<span class="built_in">FFGETS</span>(strBuffer, <span class="number">1000</span>, <span class="string">&quot;&lt;endl/&gt;&quot;</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">            logfile.<span class="built_in">Write</span>(<span class="string">&quot;strBuffer=%s&quot;</span>, strBuffer);</span><br><span class="line">            <span class="comment">// 处理文件中的每一行</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;stzhobtmind, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_zhobtmind));</span><br><span class="line">            <span class="built_in">GetXMLBuffer</span>(strBuffer, <span class="string">&quot;obtid&quot;</span>, stzhobtmind.obtid, <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">GetXMLBuffer</span>(strBuffer,<span class="string">&quot;ddatetime&quot;</span>,stzhobtmind.ddatetime,<span class="number">14</span>);</span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">11</span>];    <span class="comment">// 统一单位，使得与数据库中相同</span></span><br><span class="line">            <span class="built_in">GetXMLBuffer</span>(strBuffer, <span class="string">&quot;t&quot;</span>, tmp, <span class="number">10</span>);  <span class="keyword">if</span>(<span class="built_in">strlen</span>(tmp) &gt; <span class="number">0</span>) <span class="built_in">snprintf</span>(stzhobtmind.t, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, (<span class="keyword">int</span>)(<span class="built_in">atof</span>(tmp)*<span class="number">10</span>));</span><br><span class="line">            <span class="built_in">GetXMLBuffer</span>(strBuffer,<span class="string">&quot;u&quot;</span>,stzhobtmind.u,<span class="number">10</span>);</span><br><span class="line">			<span class="comment">// 这里留两个样例，展示tmp的作用，.u因为已经是整数,所以无需处理						 									</span></span><br><span class="line">            <span class="comment">// 把结构体中的数据插入表中</span></span><br><span class="line">            <span class="keyword">if</span>(stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="comment">// 1、失败的情况有哪些？是否全部的失败都要写日志？</span></span><br><span class="line">              <span class="comment">// 答：失败的原因主要有二：一是记录重复，二是数据内容非法。</span></span><br><span class="line">              <span class="comment">// 2、如果失败了怎么办？程序是否需要继续？是否rollback？是否返回false？</span></span><br><span class="line">              <span class="comment">// 答：如果失败的原因是数据内容非法，记录日志后继续；如果是记录重复，不必记录日志，且继续。</span></span><br><span class="line">              <span class="keyword">if</span>(stmt.m_cda.rc != <span class="number">1062</span>)&#123;</span><br><span class="line">                logfile.<span class="built_in">Write</span>(<span class="string">&quot;Buffer = %s\n&quot;</span>, strBuffer);</span><br><span class="line">                logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>, stmt.m_sql, stmt.m_cda.message);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除文件、提交事务</span></span><br><span class="line">        <span class="comment">//File.CloseAndRemove();  因为测试，暂时先关闭，不然没数据了</span></span><br><span class="line"></span><br><span class="line">        conn.<span class="built_in">commit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化业务"><a href="#优化业务" class="headerlink" title="优化业务"></a>优化业务</h4><h5 id="任务一：优化日志内容"><a href="#任务一：优化日志内容" class="headerlink" title="任务一：优化日志内容"></a>任务一：优化日志内容</h5><p>​        现在的太乱，基本没法看<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220515114422623.png" alt="image-20220515114422623"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _obtmindtodb(<span class="keyword">char</span> *pathname,<span class="keyword">char</span> *connstr,<span class="keyword">char</span> *charset)&#123;</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    <span class="keyword">int</span> totalcount = <span class="number">0</span>;   <span class="comment">// 文件的总记录数</span></span><br><span class="line">    <span class="keyword">int</span> insertcount = <span class="number">0</span>;  <span class="comment">// 成功插入的记录数</span></span><br><span class="line">    CTimer Timer;         <span class="comment">// 计时器，记录每个文件的处理耗时</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取目录，得到一个数据文件名</span></span><br><span class="line"></span><br><span class="line">        totalcount = insertcount = <span class="number">0</span>;        </span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 处理文件中的每一行</span></span><br><span class="line">            totalcount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">			........</span><br><span class="line">        &#125;<span class="keyword">else</span> insertcount++;        </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 删除文件、提交事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;已处理文件%s(totalcount=%d, insertcount = %d), 耗时%.2f秒。\n&quot;</span>, \</span><br><span class="line">                  Dir.m_FullFileName, totalcount, insertcount, Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220515115632110.png" alt="image-20220515115632110"></p>
<p>​        现在的日志就非常的整齐,不过我们可以看到还有一个问题，就是totalcount并不是单个文件的totalcount，所以我们可以在打开文件的上端初始化totalcount 和 insertcount，这里insertcount为何为0，其实是因为，之前已经插入过一次了，但是数据来说，还是旧数据反复运行，所以自然有了的就不会再插入咯<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220515124616036.png" alt="image-20220515124616036"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;68f5143d-d91c-4c4c-b55e-523ee2c7ee02&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=192.168.211.129</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.133.1</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="任务二：处理冗余的程序"><a href="#任务二：处理冗余的程序" class="headerlink" title="任务二：处理冗余的程序"></a>任务二：处理冗余的程序</h5><p>​        我们可以想象，如果我们的操作越来越多，那么程序只会越来越复杂，比如这里提到的表的字段50个，那我们光绑定参数，都要花100行，显然这是很没有必要的空间花费，我们说，还是想让程序变得优雅起来的。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220515160653223.png" alt="image-20220515160653223"></p>
<p>​        接下来我们尝试把数据结构，数据解析，和对表的操作封装成一个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全国站点分钟测试数据操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CZHOBTMIND</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    connection *m_conn;     <span class="comment">// 数据库连接</span></span><br><span class="line">    CLogFile   *m_logfile;  <span class="comment">// 日志</span></span><br><span class="line"></span><br><span class="line">    sqlstatement m_stmt;    <span class="comment">// 插入表操作的sql</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> m_buffer[<span class="number">1024</span>];    <span class="comment">// 从文件中读到的一行</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_zhobtmind</span> <span class="title">m_zhobtmind</span>;</span>  <span class="comment">// 全国站点分钟观测数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CZHOBTMIND</span>();</span><br><span class="line">    <span class="built_in">CZHOBTMIND</span>(connection *conn, CLogFile *logfile);  </span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CZHOBTMIND</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BindConnLog</span><span class="params">(connection *conn, CLogFile *logfile)</span></span>; <span class="comment">// 把connection和CLogFile的传进去 </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">SplitToBuffer</span><span class="params">(<span class="keyword">char</span> *strBuffer)</span></span>;    <span class="comment">// 把从文件读到的一行数据拆分到m_zhobtmind结构体中</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">InsertTable</span><span class="params">()</span></span>;   <span class="comment">// 把m_zhobtmind结构体中的数据插入到T_ZHOBTMIND表中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CZHOBTMIND::<span class="built_in">CZHOBTMIND</span>()&#123;</span><br><span class="line">  m_conn=<span class="number">0</span>;  m_logfile=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CZHOBTMIND::<span class="built_in">CZHOBTMIND</span>(connection *conn, CLogFile *logfile)&#123;</span><br><span class="line">  m_conn=conn;</span><br><span class="line">  m_logfile=logfile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CZHOBTMIND::~<span class="built_in">CZHOBTMIND</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CZHOBTMIND::BindConnLog</span><span class="params">(connection *conn, CLogFile *logfile)</span></span>&#123;</span><br><span class="line">  m_conn=conn;</span><br><span class="line">  m_logfile=logfile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把从文件读到的一行拆分到m_zhobtmind结构体中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CZHOBTMIND::SplitToBuffer</span><span class="params">(<span class="keyword">char</span> *strBuffer)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;m_zhobtmind, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct st_zhobtmind));</span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strBuffer, <span class="string">&quot;obtid&quot;</span>, m_zhobtmind.obtid, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">11</span>];    <span class="comment">// 统一单位，使得与数据库中相同</span></span><br><span class="line">  <span class="built_in">GetXMLBuffer</span>(strBuffer, <span class="string">&quot;t&quot;</span>, tmp, <span class="number">10</span>);  <span class="keyword">if</span>(<span class="built_in">strlen</span>(tmp) &gt; <span class="number">0</span>) <span class="built_in">snprintf</span>(m_zhobtmind.t, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, (<span class="keyword">int</span>)(<span class="built_in">atof</span>(tmp)*<span class="number">10</span>));</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">  <span class="built_in">STRCPY</span>(m_buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(m_buffer), strBuffer); <span class="comment">// 注意这里要传过去</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  把m_zhobtmind结构体中的数据插入到T_ZHOBTMIND表中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CZHOBTMIND::InsertTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(m_stmt.m_state == <span class="number">0</span>)&#123;</span><br><span class="line">    m_stmt.<span class="built_in">connect</span>(m_conn);</span><br><span class="line">    m_stmt.<span class="built_in">prepare</span>(<span class="string">&quot;insert into T_ZHOBTMIND(obtid, ddatetime, t, p, u, wd, wf, r, vis) \</span></span><br><span class="line"><span class="string">    values(:1, str_to_date(:2, &#x27;%%Y%%m%%d%%H%%i%%s&#x27;), :3, :4, :5, :6, :7, :8, :9)&quot;</span>);</span><br><span class="line">    m_stmt.<span class="built_in">bindin</span>(<span class="number">1</span>, m_zhobtmind.obtid, <span class="number">10</span>);</span><br><span class="line">	......</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 把结构体中的数据插入表中</span></span><br><span class="line">  <span class="keyword">if</span>(m_stmt.<span class="built_in">execute</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 1、失败的情况有哪些？是否全部的失败都要写日志？</span></span><br><span class="line">    <span class="comment">// 答：失败的原因主要有二：一是记录重复，二是数据内容非法。</span></span><br><span class="line">    <span class="comment">// 2、如果失败了怎么办？程序是否需要继续？是否rollback？是否返回false？</span></span><br><span class="line">    <span class="comment">// 答：如果失败的原因是数据内容非法，记录日志后继续；如果是记录重复，不必记录日志，且继续。</span></span><br><span class="line">    <span class="keyword">if</span>(m_stmt.m_cda.rc != <span class="number">1062</span>)&#123;</span><br><span class="line">      m_logfile -&gt; <span class="built_in">Write</span>(<span class="string">&quot;Buffer = %s\n&quot;</span>, m_buffer);</span><br><span class="line">      m_logfile -&gt; <span class="built_in">Write</span>(<span class="string">&quot;m_stmt.execute() failed.\n%s\n%s\n&quot;</span>, m_stmt.m_sql, m_stmt.m_cda.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _obtmindtodb(<span class="keyword">char</span> *pathname,<span class="keyword">char</span> *connstr,<span class="keyword">char</span> *charset)&#123;</span><br><span class="line">            <span class="comment">// 处理文件中的每一行</span></span><br><span class="line">            totalcount++;</span><br><span class="line"></span><br><span class="line">            ZHOBTMIND.<span class="built_in">SplitToBuffer</span>(strBuffer); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ZHOBTMIND.<span class="built_in">InsertTable</span>() == <span class="literal">true</span>)  insertcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        这样的话，无论代码有多长（插入绑定bindin，解析xml），我们都只需要<strong>两行</strong>。</p>
<h5 id="任务三：程序模块分离"><a href="#任务三：程序模块分离" class="headerlink" title="任务三：程序模块分离"></a>任务三：程序模块分离</h5><p>​        我们仔细思考不难得到，在数据中心项目中，这种得到数据，然后上传库的程序，他们的逻辑是完全相同的，并且可以这么说，有多少种数据，就得到了多少个程序。并且，我们定义的结构体，在其他程序中也有可能用得上（存放站点代码，数据时间，温度….），我们定义的数据操作类也是同样的道理，那么，这些代码是不是可以分离出去？</p>
<p>​        我们可以这样，为这个项目，创造一个头文件和一个cpp文件。</p>
<ul>
<li>结构体和类的声明分离到头文件中</li>
<li>类的实现代码，分离到cpp文件中</li>
</ul>
<p>所以到了这里，我又去百度了头文件，cpp文件这些标准写法，果然不断学习，就会不断有新的感悟.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41969690/article/details/105587141">(23条消息) C语言笔记——自定义头文件_Sunrise的博客的博客-CSDN博客_c语言自定义头文件</a></p>
<p>定义了idcapp.h 和 idcapp.cpp将其冗余部分存放</p>
<h5 id="任务四：对csv格式的支持"><a href="#任务四：对csv格式的支持" class="headerlink" title="任务四：对csv格式的支持"></a>任务四：对csv格式的支持</h5><p>进入业务处理主函数</p>
<ol>
<li>修改Dir.OpenDir里面的代码，加入支持读入*.csv</li>
<li>加入bool变量isxml true 为 xml  false 为 csv</li>
<li>读取目录，得到数据文件名后，判断他的后缀，根据后缀修改isxml的值</li>
<li>读取文件的每一行时候，更改读取结束时候的判断条件</li>
<li>SplitBuffer增加传入参数 bisxml </li>
</ol>
<h6 id="一个细节报错"><a href="#一个细节报错" class="headerlink" title="一个细节报错"></a>一个细节报错</h6><p>这里面这个if语句，是有歧义的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strBuffer[<span class="number">1001</span>];   <span class="comment">// 存放从文件中读取的一行。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isxml == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span>(File.<span class="built_in">FFGETS</span>(strBuffer, <span class="number">1000</span>, <span class="string">&quot;&lt;endl/&gt;&quot;</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(File.<span class="built_in">Fgets</span>(strBuffer, <span class="number">1000</span>, <span class="literal">true</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">strstr</span>(strBuffer, <span class="string">&quot;站点&quot;</span>) != <span class="number">0</span>) <span class="keyword">continue</span>;    <span class="comment">// 把文件中的第一行扔掉</span></span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">// 处理文件中的每一行</span></span><br><span class="line">    totalcount++;</span><br></pre></td></tr></table></figure>

<p>他还可以解析成这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isxml == <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span>(File.<span class="built_in">FFGETS</span>(strBuffer, <span class="number">1000</span>, <span class="string">&quot;&lt;endl/&gt;&quot;</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">   	 	<span class="keyword">if</span>(File.<span class="built_in">Fgets</span>(strBuffer, <span class="number">1000</span>, <span class="literal">true</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="built_in">strstr</span>(strBuffer, <span class="string">&quot;站点&quot;</span>) != <span class="number">0</span>) <span class="keyword">continue</span>;    <span class="comment">// 把文件中的第一行扔掉</span></span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>另外一个惨痛教训=-=。由于OpenDir不是我封装的，我习惯性的打了空格</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CDir Dir;</span><br><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line"><span class="keyword">if</span>(Dir.<span class="built_in">OpenDir</span>(pathname, <span class="string">&quot;*.xml, *.csv&quot;</span>) == <span class="literal">false</span>)&#123;<span class="comment">// 空格在这</span></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;Dir.OpenDir(%s) failed.\n&quot;</span>, pathname);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，就csv测试，日志没有任何东西（我把xml的文件都删除了，只留下csv的），奇了怪了=-=，原来不能加空格啊！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CDir Dir;</span><br><span class="line"><span class="comment">// 打开目录</span></span><br><span class="line"><span class="keyword">if</span>(Dir.<span class="built_in">OpenDir</span>(pathname, <span class="string">&quot;*.xml,*.csv&quot;</span>) == <span class="literal">false</span>)&#123;<span class="comment">// 空格在这</span></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;Dir.OpenDir(%s) failed.\n&quot;</span>, pathname);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220515181047608.png" alt="image-20220515181047608"></p>
<p>最后顺利运行。</p>
<h4 id="最后收尾工作"><a href="#最后收尾工作" class="headerlink" title="最后收尾工作"></a>最后收尾工作</h4><p>启用删除业务代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除文件、提交事务</span></span><br><span class="line">File.<span class="built_in">CloseAndRemove</span>();</span><br></pre></td></tr></table></figure>

<p>心跳从5000s改为10s</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PActive.<span class="built_in">AddPInfo</span>(<span class="number">30</span>,<span class="string">&quot;obtmindtodb&quot;</span>);   <span class="comment">// 进程的心跳，30秒足够。</span></span><br><span class="line"><span class="comment">// 注意，在调试程序的时候，可以启用类似以下的代码，防止超时。</span></span><br><span class="line"><span class="comment">//PActive.AddPInfo(5000,&quot;obtmindtodb&quot;);</span></span><br></pre></td></tr></table></figure>

<p>​        现在，我们已经彻底完工，不过，还不能让程序通过调度程序跑起来，因为一旦跑起来之后，数据是无穷无尽的，很快就会把磁盘空间给占满，因此，我们还可以提供一个小的脚本文件，来使得动态的删除清空</p>
<h4 id="执行SQL脚本文件"><a href="#执行SQL脚本文件" class="headerlink" title="执行SQL脚本文件"></a>执行SQL脚本文件</h4><p>​        现在我们有一个新的需求，希望定期执行sql脚本，并清理历史数据，就像之前开发的，清理历史文件一样<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220515195254820.png" alt="image-20220515195254820"></p>
<p>在linux下面，可以直接这样执行，注意只是报警，并没有报错，不过这里使用了输入重定向功能，而我们的调度程序并不支持，所以只能自己写hhhc</p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>程序流程也十分简单，打开文件，一行一行的读取出来，执行，参数也无需绑定</p>
<p>具体过程是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 打开日志文件</span></span><br><span class="line">   <span class="keyword">if</span>(logfile.<span class="built_in">Open</span>(argv[<span class="number">4</span>], <span class="string">&quot;a+&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;打开日志文件失败（%s）.\n&quot;</span>, argv[<span class="number">4</span>]);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   PActive.<span class="built_in">AddPInfo</span>(<span class="number">500</span>,<span class="string">&quot;obtcodetodb&quot;</span>);   <span class="comment">// 进程的心跳</span></span><br><span class="line">   <span class="comment">// 注意，在调试程序的时候，可以启用类似以下的代码，防止超时。</span></span><br><span class="line">   <span class="comment">// PActive.AddPInfo(5000,&quot;obtcodetodb&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库，不启用事务。</span></span><br><span class="line"> <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(argv[<span class="number">2</span>], argv[<span class="number">3</span>], <span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">   logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) failed.\n%s\n&quot;</span>, argv[<span class="number">2</span>], conn.m_cda.message); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) ok.\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"> CFile File;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打开SQL文件。</span></span><br><span class="line"> <span class="keyword">if</span> (File.<span class="built_in">Open</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>)&#123;</span><br><span class="line">   logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.Open(%s) failed.\n&quot;</span>, argv[<span class="number">1</span>]); </span><br><span class="line">   <span class="built_in">EXIT</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span> strsql[<span class="number">1001</span>];    <span class="comment">// 存放从SQL文件中读取的SQL语句。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">memset</span>(strsql, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strsql));</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 从SQL文件中读取以分号结束的一行。</span></span><br><span class="line">   <span class="keyword">if</span> (File.<span class="built_in">FFGETS</span>(strsql, <span class="number">1000</span>, <span class="string">&quot;;&quot;</span>) == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果第一个字符是#，注释，不执行。</span></span><br><span class="line">   <span class="keyword">if</span> (strsql[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 删除掉SQL语句最后的分号。也许有更好的方式</span></span><br><span class="line">   <span class="keyword">char</span> *pp = <span class="built_in">strstr</span>(strsql, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (pp == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">   pp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   logfile.<span class="built_in">Write</span>(<span class="string">&quot;%s\n&quot;</span>, strsql);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> iret = conn.<span class="built_in">execute</span>(strsql);  <span class="comment">// 执行SQL语句。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把SQL语句执行结果写日志。</span></span><br><span class="line">   <span class="keyword">if</span> (iret == <span class="number">0</span>) logfile.<span class="built_in">Write</span>(<span class="string">&quot;exec ok(rpc=%d).\n&quot;</span>, conn.m_cda.rpc);</span><br><span class="line">   <span class="keyword">else</span> logfile.<span class="built_in">Write</span>(<span class="string">&quot;exec failed(%s).\n&quot;</span>, conn.m_cda.message);</span><br><span class="line"></span><br><span class="line">   PActive.<span class="built_in">UptATime</span>();   <span class="comment">// 进程的心跳。</span></span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220515202710261.png" alt="image-20220515202710261"></p>
<p>接下来再做之前，做镜像，把网络连上，首先换源阿里云，然后配置ftp环境，重新启动调度一系列</p>
<p>搭建ftp</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ismallboy/p/6785270.html">CentOS搭建ftp服务器 - ismallboy - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43625917/article/details/104802977">Centos之FTP服务器的搭建与配置_Qwzf的博客-CSDN博客_centos 连接ftp服务器</a></p>
<p>换源</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Jankin-Wen/p/10114685.html">CentOS7更换国内源 - Jankin-Wen - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/auguse/articles/13554555.html">CentOS7更换国内源 - 蝉声且送阳西 - 博客园 (cnblogs.com)</a></p>
<p>固定ip</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jsnhux/article/details/88183317">centos配置固定IP（只需三步）_周星星_9527的博客-CSDN博客_centos 固定ip</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45912291/article/details/108894737">虚拟机VMware下载与安装教程（详细）_-借我杀死庸碌的情怀-的博客-CSDN博客_vmware</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a785975139/article/details/53023590?spm=1001.2101.3001.6650.1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-53023590-blog-81517636.pc_relevant_default">(23条消息) 解决CentOS7虚拟机无法上网并设置CentOS7虚拟机使用静态IP上网_a785975139的博客-CSDN博客_centos7虚拟机网络配置</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fanshuyao/p/14217096.html">Linux Centos 安装配置，Centos7设置静态IP地址不能上网 - 蕃薯耀 - 博客园 (cnblogs.com)</a></p>
<h2 id="六、开发数据抽取子系统"><a href="#六、开发数据抽取子系统" class="headerlink" title="六、开发数据抽取子系统"></a>六、开发数据抽取子系统</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220725105358312.png" alt="image-20220725105358312"></p>
<p>​        对于每个子系统，它们都会拥有它们自己的数据库，那么我们需要思考一下，如何将每一个子系统的数据，融入数据中心总系统中。</p>
<p>有一种简单的想法，是可以直接在两个系统之间建立connect类，然后通过插入语句使得两表相连，这样是一个思路，但也有一些问题，其中主要的就是有的时候我们不能直接操纵两个表。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220725105632080.png" alt="image-20220725105632080"></p>
<p>​        比如政府，省气象局等等的数据，我们不可能直接调用它的数据库，因此采用一个数据抽取的模块，利用模块化编程的思想，会使得我们的工作更佳轻松，并且条例清晰</p>
<h3 id="开发目标"><a href="#开发目标" class="headerlink" title="开发目标"></a>开发目标</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220725115409858.png" alt="image-20220725115409858"></p>
<h3 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h3><h4 id="宏结构体"><a href="#宏结构体" class="headerlink" title="宏结构体"></a>宏结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行参数的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_arg</span>&#123;</span>		<span class="comment">//注意都多了1，因为char数组最后要留给\0一个位置</span></span><br><span class="line">	<span class="keyword">char</span> connstr[<span class="number">101</span>];     <span class="comment">// 数据库的连接参数。</span></span><br><span class="line">  	<span class="keyword">char</span> charset[<span class="number">51</span>];      <span class="comment">// 数据库的字符集。</span></span><br><span class="line">  	<span class="keyword">char</span> selectsql[<span class="number">1024</span>];  <span class="comment">// 从数据源数据库抽取数据的SQL语句。</span></span><br><span class="line">  	<span class="keyword">char</span> fieldstr[<span class="number">501</span>];    <span class="comment">// 抽取数据的SQL语句输出结果集字段名，字段名之间用逗号分隔。</span></span><br><span class="line">  	<span class="keyword">char</span> fieldlen[<span class="number">501</span>];    <span class="comment">// 抽取数据的SQL语句输出结果集字段的长度，用逗号分隔。</span></span><br><span class="line">  	<span class="keyword">char</span> bfilename[<span class="number">31</span>];    <span class="comment">// 输出xml文件的前缀。</span></span><br><span class="line"> 	<span class="keyword">char</span> efilename[<span class="number">31</span>];    <span class="comment">// 输出xml文件的后缀。</span></span><br><span class="line">  	<span class="keyword">char</span> outpath[<span class="number">301</span>];     <span class="comment">// 输出xml文件存放的目录。</span></span><br><span class="line">	<span class="keyword">char</span> starttime[<span class="number">52</span>];    <span class="comment">// 程序运行的时间区间</span></span><br><span class="line">  	<span class="keyword">char</span> incfield[<span class="number">31</span>];     <span class="comment">// 递增字段名。</span></span><br><span class="line">  	<span class="keyword">char</span> incfilename[<span class="number">301</span>]; <span class="comment">// 已抽取数据的递增字段最大值存放的文件。</span></span><br><span class="line">  	<span class="keyword">int</span>  timeout;          <span class="comment">// 进程心跳的超时时间。</span></span><br><span class="line">  	<span class="keyword">char</span> pname[<span class="number">51</span>];        <span class="comment">// 进程名，建议用&quot;dminingmysql_后缀&quot;的方式。</span></span><br><span class="line">&#125; starg;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFIELDCOUNT 100 	<span class="comment">// 结果集字段的最大数。</span></span></span><br><span class="line"><span class="comment">//#define MAXFIELDLEN    500  // 结果集字段值的最大长度。</span></span><br><span class="line"><span class="keyword">int</span> MAXFIELDLEN=<span class="number">-1</span>;   <span class="comment">// 结果集字段值的最大长度，存放fieldlen数组中元素的最大值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> strfieldname[MAXFIELDCOUNT][<span class="number">31</span>];    <span class="comment">// 结果集字段名数组，从starg.fieldstr解析得到。</span></span><br><span class="line"><span class="keyword">int</span>  ifieldlen[MAXFIELDCOUNT];           <span class="comment">// 结果集字段的长度数组，从starg.fieldlen解析得到。</span></span><br><span class="line"><span class="keyword">int</span>  ifieldcount;                        <span class="comment">// strfieldname和ifieldlen数组中有效字段的个数。</span></span><br><span class="line"><span class="keyword">int</span>  incfieldpos=<span class="number">-1</span>;                     <span class="comment">// 递增字段在结果集数组中的位置。</span></span><br></pre></td></tr></table></figure>



<h4 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _help()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Using:/project/tools1/bin/dminingmysql logfilename xmlbuffer\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sample:/project/tools1/bin/procctl 3600 /project/tools1/bin/dminingmysql /log/idc/dminingmysql_ZHOBTCODE.log \&quot;&lt;connstr&gt;127.0.0.1,root,mysqlpwd,mysql,3306&lt;/connstr&gt;&lt;charset&gt;gbk&lt;/charset&gt;&lt;selectsql&gt;select obtid,cityname,provname,lat,lon,height from T_ZHOBTCODE&lt;/selectsql&gt;&lt;fieldstr&gt;obtid,cityname,provname,lat,lon,height&lt;/fieldstr&gt;&lt;fieldlen&gt;10,30,30,10,10,10&lt;/fieldlen&gt;&lt;bfilename&gt;ZHOBTCODE&lt;/bfilename&gt;&lt;efilename&gt;HYCZ&lt;/efilename&gt;&lt;outpath&gt;/idcdata/dmindata&lt;/outpath&gt;&lt;timeout&gt;30&lt;/timeout&gt;&lt;pname&gt;dminingmysql_ZHOBTCODE&lt;/pname&gt;\&quot;\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;       /project/tools1/bin/procctl   30 /project/tools1/bin/dminingmysql /log/idc/dminingmysql_ZHOBTMIND.log \&quot;&lt;connstr&gt;127.0.0.1,root,mysqlpwd,mysql,3306&lt;/connstr&gt;&lt;charset&gt;gbk&lt;/charset&gt;&lt;selectsql&gt;select obtid,date_format(ddatetime,&#x27;%%%%Y-%%%%m-%%%%d %%%%H:%%%%i:%%%%s&#x27;),t,p,u,wd,wf,r,vis,keyid from t_zhobtmind where keyid&gt;:1 and ddatetime&gt;timestampadd(minute,-120,now())&lt;/selectsql&gt;&lt;fieldstr&gt;obtid,ddatetime,t,p,u,wd,wf,r,vis,keyid&lt;/fieldstr&gt;&lt;fieldlen&gt;10,19,8,8,8,8,8,8,8,15&lt;/fieldlen&gt;&lt;bfilename&gt;ZHOBTMIND&lt;/bfilename&gt;&lt;efilename&gt;HYCZ&lt;/efilename&gt;&lt;outpath&gt;/idcdata/dmindata&lt;/outpath&gt;&lt;starttime&gt;&lt;/starttime&gt;&lt;incfield&gt;keyid&lt;/incfield&gt;&lt;incfilename&gt;/idcdata/dmining/dminingmysql_ZHOBTMIND_HYCZ.list&lt;/incfilename&gt;&lt;timeout&gt;30&lt;/timeout&gt;&lt;pname&gt;dminingmysql_ZHOBTMIND_HYCZ&lt;/pname&gt;\&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;本程序是数据中心的公共功能模块，用于从mysql数据库源表抽取数据，生成xml文件。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;logfilename 本程序运行的日志文件。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;xmlbuffer   本程序运行的参数，用xml表示，具体如下：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;connstr     数据库的连接参数，格式：ip,username,password,dbname,port。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;charset     数据库的字符集，这个参数要与数据源数据库保持一致，否则会出现中文乱码的情况。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;selectsql   从数据源数据库抽取数据的SQL语句，注意：时间函数的百分号%需要四个，显示出来才有两个，被prepare之后将剩一个。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fieldstr    抽取数据的SQL语句输出结果集字段名，中间用逗号分隔，将作为xml文件的字段名。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fieldlen    抽取数据的SQL语句输出结果集字段的长度，中间用逗号分隔。fieldstr与fieldlen的字段必须一一对应。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bfilename   输出xml文件的前缀。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;efilename   输出xml文件的后缀。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;outpath     输出xml文件存放的目录。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;starttime   程序运行的时间区间，例如02,13表示：如果程序启动时，踏中02时和13时则运行，其它时间不运行。&quot;</span>\</span><br><span class="line">			<span class="string">&quot;如果starttime为空，那么starttime参数将失效，只要本程序启动就会执行数据抽取，为了减少数据源&quot;</span>\</span><br><span class="line">			<span class="string">&quot;的压力，从数据库抽取数据的时候，一般在对方数据库最闲的时候时进行。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;incfield    递增字段名，它必须是fieldstr中的字段名，并且只能是整型，一般为自增字段。&quot;</span>\</span><br><span class="line">			<span class="string">&quot;如果incfield为空，表示不采用增量抽取方案。&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;incfilename 已抽取数据的递增字段最大值存放的文件，如果该文件丢失，将重新抽取全部的数据。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;timeout     本程序的超时时间，单位：秒。\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pname       进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>​        这里主要体现最核心的改动，是基于宏结构体新加入的结果段而制作的，因为我们现在要做的是一个通用的模块，所以我们必须考虑兼容的情况，就会多花一些功夫</p>
<p>主要功能是：</p>
<ul>
<li>获取字段数量</li>
<li>获取每一个字段的name</li>
<li>核查字段数量是否一一对应</li>
<li>得到想要字段的索引</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> _xmltoarg(<span class="keyword">char</span> *strxmlbuffer)&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;starg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_arg));</span><br><span class="line">	....................</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1、把starg.fieldlen解析到ifieldlen数组中；</span></span><br><span class="line">	CCmdStr CmdStr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1、把starg.fieldlen解析到ifieldlen数组中；</span></span><br><span class="line">    <span class="comment">// ifieldlen为CCmdStr自带的容器，当切断变量时，处理过的数据默认保存在内</span></span><br><span class="line">	CmdStr.<span class="built_in">SplitToCmd</span>(starg.fieldlen,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断字段数是否超出MAXFIELDCOUNT的限制。</span></span><br><span class="line">	<span class="keyword">if</span> (CmdStr.<span class="built_in">CmdCount</span>()&gt;MAXFIELDCOUNT)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;fieldlen的字段数太多，超出了最大限制%d。\n&quot;</span>,MAXFIELDCOUNT); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;CmdStr.<span class="built_in">CmdCount</span>();ii++)&#123;</span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(ii,&amp;ifieldlen[ii]);</span><br><span class="line">		<span class="comment">// if (ifieldlen[ii]&gt;MAXFIELDLEN) ifieldlen[ii]=MAXFIELDLEN;   // 字段的长度不能超过MAXFIELDLEN。</span></span><br><span class="line">         <span class="comment">// 这里将MAXFIELDLEN从宏改为了变量，一旦出现溢出情况，方便扩容，不存在切断字段的风险。</span></span><br><span class="line">		<span class="keyword">if</span> (ifieldlen[ii]&gt;MAXFIELDLEN) MAXFIELDLEN=ifieldlen[ii];   <span class="comment">// 得到字段长度的最大值。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifieldcount=CmdStr.<span class="built_in">CmdCount</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2、把starg.fieldstr解析到strfieldname数组中；</span></span><br><span class="line">	CmdStr.<span class="built_in">SplitToCmd</span>(starg.fieldstr,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断字段数是否超出MAXFIELDCOUNT的限制。</span></span><br><span class="line">	<span class="keyword">if</span> (CmdStr.<span class="built_in">CmdCount</span>()&gt;MAXFIELDCOUNT)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;fieldstr的字段数太多，超出了最大限制%d。\n&quot;</span>,MAXFIELDCOUNT); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;CmdStr.<span class="built_in">CmdCount</span>();ii++)&#123;</span><br><span class="line">		CmdStr.<span class="built_in">GetValue</span>(ii,strfieldname[ii],<span class="number">30</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断strfieldname和ifieldlen两个数组中的字段是否一致。</span></span><br><span class="line">	<span class="keyword">if</span> (ifieldcount!=CmdStr.<span class="built_in">CmdCount</span>())&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;fieldstr和fieldlen的元素数量不一致。\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3、获取自增字段在结果集中的位置。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.incfield)!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;ifieldcount;ii++)</span><br><span class="line">         <span class="comment">// strcmp用于判断想要检测的索引是否在当前容器中，若在则返回0，并用incfieldpos记录此时的索引</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(starg.incfield,strfieldname[ii])==<span class="number">0</span>) &#123; incfieldpos=ii; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (incfieldpos==<span class="number">-1</span>)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;递增字段名%s不在列表%s中。\n&quot;</span>,starg.incfield,starg.fieldstr); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全量抽取数据主功能"><a href="#全量抽取数据主功能" class="headerlink" title="全量抽取数据主功能"></a>全量抽取数据主功能</h4><p>​        全量抽取就是原封不动的抽取数据，比较适合全国站点参数表，因为毕竟站点可能就几千个。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220727152302517.png" alt="image-20220727152302517"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传文件功能的主函数</span></span><br><span class="line"><span class="keyword">bool</span> _dminingmysql()&#123;</span><br><span class="line">	<span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>;</span><br><span class="line">	stmt.<span class="built_in">prepare</span>(starg.selectsql);</span><br><span class="line">	<span class="keyword">char</span> strfieldvalue[ifieldcount][MAXFIELDLEN+<span class="number">1</span>];  <span class="comment">// 抽取数据的SQL执行后，存放结果集字段值的数组。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=ifieldcount;ii++)&#123;</span><br><span class="line">		<span class="comment">// 这里为了防止绑定的字段长度大于MAXFIELDLEN，所以对宏做了处理，</span></span><br><span class="line">		<span class="comment">// 改为变量，利用if语句，一旦出现超过的，那么就赋值max为该值</span></span><br><span class="line">		stmt.<span class="built_in">bindout</span>(ii,strfieldvalue[ii<span class="number">-1</span>],ifieldlen[ii<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 执行sql语句</span></span><br><span class="line">	<span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CFile File;  <span class="comment">// 用于操作xml文件。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(strfieldvalue,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strfieldvalue));</span><br><span class="line">		</span><br><span class="line">         <span class="comment">// 从sql的执行语句获得一条记录</span></span><br><span class="line">		<span class="keyword">if</span> (stmt.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打开文件放在循环内，就避免生成空文件的情况</span></span><br><span class="line">		<span class="keyword">if</span>(File.<span class="built_in">IsOpened</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">             <span class="comment">// 这个函数在下面有  // 生成xml文件名</span></span><br><span class="line">			<span class="built_in">crtxmlfilename</span>();</span><br><span class="line">			</span><br><span class="line">             <span class="comment">// 设置写入权限</span></span><br><span class="line">			<span class="keyword">if</span>(File.<span class="built_in">OpenForRename</span>(strxmlfilename, <span class="string">&quot;w+&quot;</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">				logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.OpenForRename(%s) failed. \n&quot;</span>, strxmlfilename);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 打开一个文件，在行首加&lt;data&gt;\n</span></span><br><span class="line">			File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;data&gt;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将一句转化为xml格式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=ifieldcount;ii++)</span><br><span class="line">			<span class="comment">// 使得转变为xml格式</span></span><br><span class="line">			File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>,strfieldname[ii<span class="number">-1</span>],strfieldvalue[ii<span class="number">-1</span>],strfieldname[ii<span class="number">-1</span>]);</span><br><span class="line">		<span class="comment">// 在这一句后面添加&lt;end/&gt;</span></span><br><span class="line">		File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;endl/&gt;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 行尾加&lt;/data&gt;\n</span></span><br><span class="line">	<span class="keyword">if</span>(File.<span class="built_in">IsOpened</span>() == <span class="literal">true</span>)&#123;</span><br><span class="line">		File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭失败，记录原因</span></span><br><span class="line">		<span class="keyword">if</span>(File.<span class="built_in">CloseAndRename</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.CloseAndRename(%s) failed.\n&quot;</span>, strxmlfilename);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭成功，写日志</span></span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;生成文件%s(%d). \n&quot;</span>, strxmlfilename, stmt.m_cda.rpc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crtxmlfilename</span><span class="params">()</span></span>&#123;	<span class="comment">// 生成xml文件名</span></span><br><span class="line">	<span class="comment">// xml全路径文件名=start.outpath + starg.bfilename + 当前时间 + starg.efilename + .xml</span></span><br><span class="line">	<span class="comment">// char strxmlfilename[301]  xml文件名</span></span><br><span class="line">	<span class="keyword">char</span> strLocalTime[<span class="number">21</span>];</span><br><span class="line">	<span class="built_in">memset</span>(strLocalTime, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strLocalTime));</span><br><span class="line">	<span class="built_in">LocalTime</span>(strLocalTime, <span class="string">&quot;yyyymmddhh24miss&quot;</span>);</span><br><span class="line">	<span class="built_in">SNPRINTF</span>(strxmlfilename, <span class="number">300</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strxmlfilename), <span class="string">&quot;%s/%s_%s_%s.xml&quot;</span>, starg.outpath, starg.bfilename, strLocalTime, starg.efilename);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h5><p>​        我们的上传文件模块虽然能成功的上传标准xml格式模块，但是在实际开发中，可能会涉及数据条数很多，从而导致，如果一次性上传，会对数据库造成一定时间内不小的冲击压力，因此我们使用分块的思想，这里设定每次只上传1000条</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220727143804780.png" alt="image-20220727143804780"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">修改点<span class="number">1</span>：</span><br><span class="line">		<span class="comment">// 在这一句后面添加&lt;end/&gt;</span></span><br><span class="line">		File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;endl/&gt;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">		File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;endl/&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (stmt.m_cda.rpc%<span class="number">1000</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 关闭失败，记录原因</span></span><br><span class="line">			<span class="keyword">if</span>(File.<span class="built_in">CloseAndRename</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">				logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.CloseAndRename(%s) failed.\n&quot;</span>, strxmlfilename);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 关闭成功，写日志</span></span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;生成文件%s(1000). \n&quot;</span>, strxmlfilename);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">修改点<span class="number">2</span>：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crtxmlfilename</span><span class="params">()</span></span>&#123;	<span class="comment">// 生成xml文件名</span></span><br><span class="line">    由于命名方式有时间，并且最多只精确到s，如果同一秒内生成多个文件就会重复，所以我们新添加一个序号</span><br><span class="line">    --&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crtxmlfilename</span><span class="params">()</span></span>&#123;	<span class="comment">// 生成xml文件名</span></span><br><span class="line">	<span class="comment">// xml全路径文件名=start.outpath + starg.bfilename + 当前时间 + starg.efilename + 序号.xml</span></span><br><span class="line">	<span class="comment">// char strxmlfilename[301]  xml文件名，序号可用全局可用静态</span></span><br><span class="line">	<span class="keyword">char</span> strLocalTime[<span class="number">21</span>];</span><br><span class="line">	<span class="built_in">memset</span>(strLocalTime, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strLocalTime));</span><br><span class="line">	<span class="built_in">LocalTime</span>(strLocalTime, <span class="string">&quot;yyyymmddhh24miss&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> iseq = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">SNPRINTF</span>(strxmlfilename, <span class="number">300</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(strxmlfilename), <span class="string">&quot;%s/%s_%s_%s_%d.xml&quot;</span>, starg.outpath, starg.bfilename, strLocalTime, starg.efilename, iseq++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增量抽取"><a href="#增量抽取" class="headerlink" title="增量抽取"></a>增量抽取</h4><p>这里的增量抽取和百度的不太一样,但增量抽取就是为了记住位置，方便下一步的操作</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220727152424176.png" alt="image-20220727152424176"></p>
<h5 id="业务逻辑-1"><a href="#业务逻辑-1" class="headerlink" title="业务逻辑"></a>业务逻辑</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> _dminingmysql()&#123;</span><br><span class="line">	<span class="comment">// 从starg.incfilename文件中获取已抽取数据的最大id</span></span><br><span class="line">    <span class="built_in">readincfile</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 如果是增量抽取，绑定输入参数（已抽取数据的最大id）。</span></span><br><span class="line">	<span class="comment">// imaxincvalue为全局变量。</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(starg.incfield) != <span class="number">0</span>) stmt.<span class="built_in">bindin</span>(<span class="number">1</span>, &amp;imaxincvalue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 更新自增字段的最大值。</span></span><br><span class="line">		<span class="comment">// 如果没有自增字段，就不需要这样判断</span></span><br><span class="line">		<span class="comment">// if (imaxincvalue&lt;atol(strfieldvalue[incfieldpos])) imaxincvalue=atol(strfieldvalue[incfieldpos]);</span></span><br><span class="line">	    <span class="keyword">if</span> ( (<span class="built_in">strlen</span>(starg.incfield)!=<span class="number">0</span>) &amp;&amp; (imaxincvalue&lt;<span class="built_in">atol</span>(strfieldvalue[incfieldpos])) )</span><br><span class="line">       imaxincvalue=<span class="built_in">atol</span>(strfieldvalue[incfieldpos]);	</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把最大的自增字段的值写入starg.incfilename文件中。</span></span><br><span class="line">     <span class="keyword">if</span> (stmt.m_cda.rpc&gt;<span class="number">0</span>) <span class="built_in">writeincfile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readincfile</span><span class="params">()</span></span>&#123;   <span class="comment">// 从starg.incfilename文件中获取已抽取数据的最大id。</span></span><br><span class="line">	imaxincvalue=<span class="number">0</span>;	  <span class="comment">// 自增字段最大值</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果starg.incfield参数为空，表示不是增量抽取。</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(starg.incfield)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	CFile File;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果打开starg.incfilename文件失败，表示是第一次运行程序，也不必返回失败。</span></span><br><span class="line">	<span class="comment">// 也可能是文件丢了，那也没办法，只能重新抽取。</span></span><br><span class="line">	<span class="keyword">if</span> (File.<span class="built_in">Open</span>(starg.incfilename,<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">true</span>;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从文件中读取已抽取数据的最大id。</span></span><br><span class="line">	<span class="keyword">char</span> strtemp[<span class="number">31</span>];</span><br><span class="line">	File.<span class="built_in">FFGETS</span>(strtemp, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	imaxincvalue = <span class="built_in">atol</span>(strtemp);</span><br><span class="line"></span><br><span class="line">	logfile.<span class="built_in">Write</span>(<span class="string">&quot;上次已抽取数据的位置 （%s=%ld)。\n&quot;</span>, starg.incfield, imaxincvalue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">writeincfile</span><span class="params">()</span></span>&#123;  <span class="comment">// 把已抽取数据的最大id写入starg.incfilename文件。</span></span><br><span class="line">	<span class="comment">// 如果starg.incfield参数为空，表示不是增量抽取。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.incfield)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	CFile File;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (File.<span class="built_in">Open</span>(starg.incfilename,<span class="string">&quot;w+&quot;</span>)==<span class="literal">false</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.Open(%s) failed.\n&quot;</span>,starg.incfilename); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把已抽取数据的最大id写入文件。</span></span><br><span class="line">	File.<span class="built_in">Fprintf</span>(<span class="string">&quot;%ld&quot;</span>,imaxincvalue);</span><br><span class="line"></span><br><span class="line">	File.<span class="built_in">Close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据抽取的优化"><a href="#数据抽取的优化" class="headerlink" title="数据抽取的优化"></a>数据抽取的优化</h4><ul>
<li>目标</li>
</ul>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220727160505736.png" alt="image-20220727160505736"></p>
<p>​        第一个问题：现在给出的xml批量是1000一次，之前我们的理由是文件数目不能太大，否则不好处理，但也不绝对，就比如，如果数目比较小，我们使用一起插入，只需要先把表中的全部删掉，然后直接一锅端就好，但如果分成了多个文件，反而复杂，因为入库程序不知道我们有多少个文件，也不知道文件是否完整</p>
<p>​        第二个问题：我们现在的程序，自增字段是保存在logfile文件中，我们实际上可以保存到数据库中，不过也不是说保存在文件中不好，因为万一到了别的服务器，根本就没有数据库环境，就又会出现大麻烦，最好的办法就是都支持。</p>
<p>这里我们先修改储存的结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_arg</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> connstr[<span class="number">101</span>];     <span class="comment">// 数据库的连接参数。</span></span><br><span class="line">  <span class="keyword">char</span> charset[<span class="number">51</span>];      <span class="comment">// 数据库的字符集。</span></span><br><span class="line">  <span class="keyword">char</span> selectsql[<span class="number">1024</span>];  <span class="comment">// 从数据源数据库抽取数据的SQL语句。</span></span><br><span class="line">  <span class="keyword">char</span> fieldstr[<span class="number">501</span>];    <span class="comment">// 抽取数据的SQL语句输出结果集字段名，字段名之间用逗号分隔。</span></span><br><span class="line">  <span class="keyword">char</span> fieldlen[<span class="number">501</span>];    <span class="comment">// 抽取数据的SQL语句输出结果集字段的长度，用逗号分隔。</span></span><br><span class="line">  <span class="keyword">char</span> bfilename[<span class="number">31</span>];    <span class="comment">// 输出xml文件的前缀。</span></span><br><span class="line">  <span class="keyword">char</span> efilename[<span class="number">31</span>];    <span class="comment">// 输出xml文件的后缀。</span></span><br><span class="line">  <span class="keyword">char</span> outpath[<span class="number">301</span>];     <span class="comment">// 输出xml文件存放的目录。</span></span><br><span class="line">  <span class="keyword">int</span>  maxcount;         <span class="comment">// 输出xml文件最大记录数，0表示无限制。</span></span><br><span class="line">  <span class="keyword">char</span> starttime[<span class="number">52</span>];    <span class="comment">// 程序运行的时间区间</span></span><br><span class="line">  <span class="keyword">char</span> incfield[<span class="number">31</span>];     <span class="comment">// 递增字段名。</span></span><br><span class="line">  <span class="keyword">char</span> incfilename[<span class="number">301</span>]; <span class="comment">// 已抽取数据的递增字段最大值存放的文件。</span></span><br><span class="line">  <span class="keyword">char</span> connstr1[<span class="number">101</span>];    <span class="comment">// 已抽取数据的递增字段最大值存放的数据库的连接参数。</span></span><br><span class="line">  <span class="keyword">int</span>  timeout;          <span class="comment">// 进程心跳的超时时间。</span></span><br><span class="line">  <span class="keyword">char</span> pname[<span class="number">51</span>];        <span class="comment">// 进程名，建议用&quot;dminingmysql_后缀&quot;的方式。</span></span><br><span class="line">&#125; starg;</span><br></pre></td></tr></table></figure>

<p>增加了maxcount和connstr1</p>
<p>两点注意：</p>
<ol>
<li>connstr1是我们自己的数据库、connstr是别人的数据库</li>
<li>剩下的说明文档，xml解析啥的，要准备改了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、获取自增字段在结果集中的位置。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.incfield)!=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;ifieldcount;ii++)</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(starg.incfield,strfieldname[ii])==<span class="number">0</span>) &#123; incfieldpos=ii; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (incfieldpos==<span class="number">-1</span>)&#123;</span><br><span class="line">	logfile.<span class="built_in">Write</span>(<span class="string">&quot;递增字段名%s不在列表%s中。\n&quot;</span>,starg.incfield,starg.fieldstr); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strlen</span>(starg.incfilename) == <span class="number">0</span>) &amp;&amp; (<span class="built_in">strlen</span>(starg.connstr1) == <span class="number">0</span>))&#123;</span><br><span class="line">	logfile.<span class="built_in">Write</span>(<span class="string">&quot;incfilename和connstr1参数必须二选一 \n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前设置一千行的地方，将一千替换为maxcount，并且有的地方注意限制maxcount必须大于0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (starg.maxcount == <span class="number">0</span>)&#123;</span><br><span class="line">    --&gt;</span><br><span class="line"><span class="keyword">if</span> ((starg.maxcount&gt;<span class="number">0</span>) &amp;&amp; (stmt.m_cda.rpc%starg.maxcount == <span class="number">0</span>) )&#123;</span><br><span class="line">			File.<span class="built_in">Fprintf</span>(<span class="string">&quot;&lt;/data&gt;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 关闭成功，写日志</span></span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;生成文件%s(%d). \n&quot;</span>, strxmlfilename, stmt.m_cda.rpc%starg.maxcount);</span><br><span class="line">---&gt;</span><br><span class="line">    <span class="comment">// 关闭成功，写日志,等于0，写结果集，大于0，写余数</span></span><br><span class="line">		<span class="keyword">if</span> (starg.maxcount == <span class="number">0</span>)</span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;生成文件%s(%d). \n&quot;</span>, strxmlfilename, stmt.m_cda.rpc);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;生成文件%s(%d). \n&quot;</span>, strxmlfilename, stmt.m_cda.rpc%starg.maxcount);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试的时候，修改<maxcount></maxcount>里面的文字，另外需要删掉<incfilename></incfilename>再试</p>
<p>​        接下来增加，使得自增字段加入数据库功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接数据源的数据库。</span></span><br><span class="line">	<span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(starg.connstr,starg.charset)!=<span class="number">0</span>)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) failed.\n%s\n&quot;</span>,starg.connstr,conn.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 连接本地的数据库，用于存放已抽取数据的自增字段的最大值。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.connstr1)!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (conn1.<span class="built_in">connecttodb</span>(starg.connstr1,starg.charset)!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) failed.\n%s\n&quot;</span>,starg.connstr1,conn1.m_cda.message); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) ok.\n&quot;</span>,starg.connstr1);</span><br><span class="line">	&#125;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) ok.\n&quot;</span>,starg.connstr);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readincfield</span><span class="params">()</span></span>&#123;   <span class="comment">// 从数据库表中或starg.incfilename文件中获取已抽取数据的最大id。</span></span><br><span class="line">	imaxincvalue=<span class="number">0</span>;	  <span class="comment">// 自增字段最大值</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果starg.incfield参数为空，表示不是增量抽取。</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(starg.incfield) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(starg.connstr1) != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 从数据库表中加载自增字段的最大值。</span></span><br><span class="line">		<span class="comment">// create table T_MAXINCVALUE(pname varchar(50),maxincvalue numeric(15),primary key(pname));</span></span><br><span class="line">		<span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn1)</span></span>;</span><br><span class="line">		stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select maxincvalue from T_MAXINCVALUE where pname=:1&quot;</span>);</span><br><span class="line">		stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,starg.pname,<span class="number">50</span>);</span><br><span class="line">		stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;imaxincvalue);</span><br><span class="line">		<span class="comment">// 处理结果不用管它</span></span><br><span class="line">		stmt.<span class="built_in">execute</span>();</span><br><span class="line">		stmt.<span class="built_in">next</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		CFile File;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果打开starg.incfilename文件失败，表示是第一次运行程序，也不必返回失败。</span></span><br><span class="line">		<span class="comment">// 也可能是文件丢了，那也没办法，只能重新抽取。</span></span><br><span class="line">		<span class="keyword">if</span> (File.<span class="built_in">Open</span>(starg.incfilename,<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">true</span>;	</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从文件中读取已抽取数据的最大id。</span></span><br><span class="line">		<span class="keyword">char</span> strtemp[<span class="number">31</span>];</span><br><span class="line">		File.<span class="built_in">FFGETS</span>(strtemp, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">		imaxincvalue = <span class="built_in">atol</span>(strtemp);</span><br><span class="line">	&#125;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;上次已抽取数据的位置 (%s=%ld)。\n&quot;</span>, starg.incfield, imaxincvalue);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">writeincfield</span><span class="params">()</span></span>&#123;  <span class="comment">// 把已抽取数据的最大id写入数据库表或starg.incfilename文件。</span></span><br><span class="line">	<span class="comment">// 如果starg.incfield参数为空，表示不是增量抽取。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.incfield)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(starg.connstr1) != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 把自增字段的最大值写入数据库的表。</span></span><br><span class="line">		<span class="comment">// create table T_MAXINCVALUE(pname varchar(50),maxincvalue numeric(15),primary key(pname));</span></span><br><span class="line">		<span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn1)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (stmt.m_cda.rc == <span class="number">1146</span>)&#123;</span><br><span class="line">		<span class="comment">// 如果表不存在，就创建表。</span></span><br><span class="line">		conn1.<span class="built_in">execute</span>(<span class="string">&quot;create table T_MAXINCVALUE(pname varchar(50),maxincvalue numeric(15),primary key(pname))&quot;</span>);</span><br><span class="line">		conn1.<span class="built_in">execute</span>(<span class="string">&quot;insert into T_MAXINCVALUE values(&#x27;%s&#x27;,%ld)&quot;</span>,starg.pname,imaxincvalue);</span><br><span class="line">		conn1.<span class="built_in">commit</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;imaxincvalue);</span><br><span class="line">		stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,starg.pname,<span class="number">50</span>);</span><br><span class="line">		<span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">		logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (stmt.m_cda.rpc==<span class="number">0</span>)&#123;</span><br><span class="line">		conn1.<span class="built_in">execute</span>(<span class="string">&quot;insert into T_MAXINCVALUE values(&#x27;%s&#x27;,%ld)&quot;</span>,starg.pname,imaxincvalue);</span><br><span class="line">		&#125;</span><br><span class="line">		conn1.<span class="built_in">commit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		CFile File;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (File.<span class="built_in">Open</span>(starg.incfilename,<span class="string">&quot;w+&quot;</span>)==<span class="literal">false</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.Open(%s) failed.\n&quot;</span>,starg.incfilename); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 把已抽取数据的最大id写入文件。</span></span><br><span class="line">		File.<span class="built_in">Fprintf</span>(<span class="string">&quot;%ld&quot;</span>,imaxincvalue);</span><br><span class="line"></span><br><span class="line">		File.<span class="built_in">Close</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="学习总结-2"><a href="#学习总结-2" class="headerlink" title="学习总结"></a>学习总结</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220727170447271.png" alt="image-20220727170447271"></p>
<p>数据处理对象一般有几种类型。</p>
<ol>
<li>网点信息，一般数据量不多</li>
<li>账户信息，数据量比较大，超过千万的级别</li>
<li>流水，数据量特别大，超过亿的级别</li>
</ol>
<p>​        在我们这节课中，气象站点数据属于第一种，气象观测数据属于第三种，气象行业没有第二种数据</p>
<p>处理经验</p>
<ol>
<li>对于第一个表，我们通常采用全量抽取，每次抽取全部的数据</li>
<li>第二个表，采用全量抽取，他有更新时间的字段，假设一小时更新一次，可以把抽取数据的条件设置为两个小时，肯定不会漏掉数据</li>
<li>第三个表，是自增字段，采用增量抽取的方法，每次抽取新增数据也很容易</li>
</ol>
<p>可，这些都只是理想情况，实际项目开发，最根本的问题是<strong>数据源表的操作不规范</strong></p>
<p>我们要注意的原则</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220727171111183.png" alt="image-20220727171111183"></p>
<h2 id="七、数据入库子系统"><a href="#七、数据入库子系统" class="headerlink" title="七、数据入库子系统"></a>七、数据入库子系统</h2><h3 id="数据入库的三种方式"><a href="#数据入库的三种方式" class="headerlink" title="数据入库的三种方式"></a>数据入库的三种方式</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731142137482.png" alt="image-20220731142137482"></p>
<p>​        如果只是获取数据，再传入数据中心，那么数据类型不同，就需要开发不同的入库代码，这样是十分繁琐的，因此我们想的是将获取到的数据都转化为不同的xml文件，然后通过数据入库模块来智能选择如何入库</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731142255297.png" alt="image-20220731142255297"></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731142443146.png" alt="image-20220731142443146"></p>
<p><strong>拓展-MySQL数据字典</strong></p>
<p>​        INFORMATION_SCHEMA是<strong>信息数据库</strong>，其中保存着关于MySQL服务器所维护的所有其他数据库的信息。在INFORMATION_SCHEMA中，有数个只读表。它们实际上<strong>是视图</strong>，而不是基本表，因此，你将<strong>无法看到与之相关的任何文件</strong>。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731143449733.png" alt="image-20220731143449733"></p>
<h3 id="入库设计要求"><a href="#入库设计要求" class="headerlink" title="入库设计要求"></a>入库设计要求</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731143910541.png" alt="image-20220731143910541"></p>
<p>我们的设计是这样的，可以理解一下理论是否能做到。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731144030336.png" alt="image-20220731144030336"></p>
<h3 id="数据入库基本流程"><a href="#数据入库基本流程" class="headerlink" title="数据入库基本流程"></a>数据入库基本流程</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731144639957.png" alt="image-20220731144639957"></p>
<p><strong>声明参数</strong></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731145030635.png" alt="image-20220731145030635"></p>
<h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把数据入库的参数配置文件starg.inifilename加载到vxmltotable容器中。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadxmltotable</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vxmltotable.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  CFile File;</span><br><span class="line">  <span class="keyword">if</span> (File.<span class="built_in">Open</span>(starg.inifilename,<span class="string">&quot;r&quot;</span>)==<span class="literal">false</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;File.Open(%s) 失败。\n&quot;</span>,starg.inifilename); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> strBuffer[<span class="number">501</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">FFGETS</span>(strBuffer,<span class="number">500</span>,<span class="string">&quot;&lt;endl/&gt;&quot;</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;stxmltotable,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_xmltotable));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetXMLBuffer</span>(strBuffer,<span class="string">&quot;filename&quot;</span>,stxmltotable.filename,<span class="number">100</span>); <span class="comment">// xml文件的匹配规则，用逗号分隔。</span></span><br><span class="line">    <span class="built_in">GetXMLBuffer</span>(strBuffer,<span class="string">&quot;tname&quot;</span>,stxmltotable.tname,<span class="number">30</span>);        <span class="comment">// 待入库的表名。</span></span><br><span class="line">    <span class="built_in">GetXMLBuffer</span>(strBuffer,<span class="string">&quot;uptbz&quot;</span>,&amp;stxmltotable.uptbz);          <span class="comment">// 更新标志：1-更新；2-不更新。</span></span><br><span class="line">    <span class="built_in">GetXMLBuffer</span>(strBuffer,<span class="string">&quot;execsql&quot;</span>,stxmltotable.execsql,<span class="number">300</span>);   <span class="comment">// 处理xml文件之前，执行的SQL语句。</span></span><br><span class="line">   </span><br><span class="line">    vxmltotable.<span class="built_in">push_back</span>(stxmltotable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;loadxmltotable(%s) ok.\n&quot;</span>,starg.inifilename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从vxmltotable容器中查找xmlfilename的入库参数，存放在stxmltotable结构体中。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findxmltotable</span><span class="params">(<span class="keyword">char</span> *xmlfilename)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;vxmltotable.<span class="built_in">size</span>();ii++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MatchStr</span>(xmlfilename,vxmltotable[ii].filename)==<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(&amp;stxmltotable,&amp;vxmltotable[ii],<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_xmltotable));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载频率"><a href="#加载频率" class="headerlink" title="加载频率"></a>加载频率</h4><p>​        我们可以思考一下loadxmltotable应该放在程序主流程的哪里，如果放在程序开头，意味着只加载一次，后面无法变动，如果直接放在while里，也意味着每次程序运行都要加载，过于频繁，因此我们可以定义一个<strong>计数器</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _xmltodb()&#123;</span><br><span class="line">  <span class="keyword">int</span> counter=<span class="number">50</span>;  <span class="comment">// 加载入库参数的计数器，初始化为50是为了在第一次进入循环的时候就加载参数。</span></span><br><span class="line"></span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter++&gt;<span class="number">30</span>)&#123;</span><br><span class="line">      counter=<span class="number">0</span>;   <span class="comment">// 重新计数。</span></span><br><span class="line">      <span class="comment">// 把数据入库的参数配置文件starg.inifilename加载到vxmltotable容器中。</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">loadxmltotable</span>()==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        入库的参数文件会修改，但是修改的频率也不是很高。这样每循环三十次，再重新加载，就相对来说节省内存，又能及时加载，也是经典折中处理。</p>
<h4 id="流程补充"><a href="#流程补充" class="headerlink" title="流程补充"></a>流程补充</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _xmltodb()&#123;</span><br><span class="line">  <span class="keyword">int</span> counter=<span class="number">50</span>;  <span class="comment">// 加载入库参数的计数器，初始化为50是为了在第一次进入循环的时候就加载参数。</span></span><br><span class="line"></span><br><span class="line">  CDir Dir;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter++&gt;<span class="number">30</span>)&#123;</span><br><span class="line">      counter=<span class="number">0</span>;   <span class="comment">// 重新计数。</span></span><br><span class="line">      <span class="comment">// 把数据入库的参数配置文件starg.inifilename加载到vxmltotable容器中。</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">loadxmltotable</span>()==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开starg.xmlpath目录，为了保证先生成的数据入库，打开目录的时候，应该按文件名排序。</span></span><br><span class="line">    <span class="keyword">if</span> (Dir.<span class="built_in">OpenDir</span>(starg.xmlpath,<span class="string">&quot;*.XML&quot;</span>,<span class="number">10000</span>,<span class="literal">false</span>,<span class="literal">true</span>)==<span class="literal">false</span>)&#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;Dir.OpenDir(%s) failed.\n&quot;</span>,starg.xmlpath); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="comment">// 读取目录，得到一个xml文件。</span></span><br><span class="line">      <span class="keyword">if</span> (Dir.<span class="built_in">ReadDir</span>()==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;处理文件%s...&quot;</span>,Dir.m_FullFileName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用处理xml文件的子函数。</span></span><br><span class="line">      <span class="keyword">int</span> iret=_xmltodb(Dir.m_FullFileName,Dir.m_FileName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理xml文件成功，写日志，备份文件。</span></span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">0</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;ok.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 把xml文件移动到starg.xmlpathbak参数指定的目录中，一般不会发生错误，如果真发生了，程序将退出。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">xmltobakerr</span>(Dir.m_FullFileName,starg.xmlpath,starg.xmlpathbak)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果处理xml文件失败，分多种情况。</span></span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">1</span>)&#123;    <span class="comment">// iret==1，找不到入库参数。暂时先一种</span></span><br><span class="line">          </span><br><span class="line">        logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed，没有配置入库参数。\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 把xml文件移动到starg.xmlpatherr参数指定的目录中，一般不会发生错误，如果真发生了，程序将退出。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">xmltobakerr</span>(Dir.m_FullFileName,starg.xmlpath,starg.xmlpatherr)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">// 测试时只循环一次</span></span><br><span class="line">    <span class="built_in">sleep</span>(starg.timetvl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把xml文件移动到备份目录或错误目录。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xmltobakerr</span><span class="params">(<span class="keyword">char</span> *fullfilename,<span class="keyword">char</span> *srcpath,<span class="keyword">char</span> *dstpath)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dstfilename[<span class="number">301</span>];   <span class="comment">// 目标文件名。</span></span><br><span class="line">  <span class="built_in">STRCPY</span>(dstfilename,<span class="built_in"><span class="keyword">sizeof</span></span>(dstfilename),fullfilename);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UpdateStr</span>(dstfilename,srcpath,dstpath,<span class="literal">false</span>);    <span class="comment">// 小心第四个参数，一定要填false。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">RENAME</span>(fullfilename,dstfilename)==<span class="literal">false</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;RENAME(%s,%s) failed.\n&quot;</span>,fullfilename,dstfilename); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="核心入库过程框架"><a href="#核心入库过程框架" class="headerlink" title="核心入库过程框架"></a>核心入库过程框架</h4><p>请注意，这里返回值是int，是bool _xmltodb的子函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理xml文件的子函数，返回值：0-成功，其它的都是失败，失败的情况有很多种，暂时不确定。</span></span><br><span class="line"><span class="keyword">int</span> _xmltodb(<span class="keyword">char</span> *fullfilename,<span class="keyword">char</span> *filename)&#123;</span><br><span class="line">  <span class="comment">// 从vxmltotable容器中查找filename的入库参数，存放在stxmltotable结构体中。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">findxmltotable</span>(filename)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">  CTABCOLS TABCOLS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取表全部的字段和主键信息，如果获取失败，应该是数据库连接已失效。</span></span><br><span class="line">  <span class="comment">// 在本程序运行的过程中，如果数据库出现异常，一定会在这里发现。</span></span><br><span class="line">  <span class="keyword">if</span> (TABCOLS.<span class="built_in">allcols</span>(&amp;conn,stxmltotable.tname)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (TABCOLS.<span class="built_in">pkcols</span>(&amp;conn,stxmltotable.tname)==<span class="literal">false</span>)  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果TABCOLS.m_allcount为0，说明表根本不存在，返回2。</span></span><br><span class="line">  <span class="keyword">if</span> (TABCOLS.m_allcount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 待入库的表不存在。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接生成插入和更新表数据的SQL。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare插入和更新的sql语句，绑定输入变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在处理xml文件之前，如果stxmltotable.execsql不为空，就执行它。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开xml文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  while (true)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    // 从xml文件中读取一行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 解析xml，存放在已绑定的输入变量中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 执行插入和更新的SQL。</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="新增结构体定义"><a href="#新增结构体定义" class="headerlink" title="新增结构体定义"></a>新增结构体定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表的列(字段)信息的结构体。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_columns</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span>  colname[<span class="number">31</span>];  <span class="comment">// 列名。为了便捷和兼容，mysql其实可以放下64位，oracle是30</span></span><br><span class="line">  <span class="keyword">char</span>  datatype[<span class="number">31</span>]; <span class="comment">// 列的数据类型，分为number、date和char三大类。</span></span><br><span class="line">  <span class="keyword">int</span>   collen;       <span class="comment">// 列的长度，number固定20，date固定19，char的长度由表结构决定。</span></span><br><span class="line">  <span class="keyword">int</span>   pkseq;        <span class="comment">// 如果列是主键的字段，存放主键字段的顺序，从1开始，不是主键取值0。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取表全部的列和主键列信息的类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTABCOLS</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CTABCOLS</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> m_allcount;   <span class="comment">// 全部字段的个数。</span></span><br><span class="line">  <span class="keyword">int</span> m_pkcount;    <span class="comment">// 主键字段的个数。</span></span><br><span class="line"></span><br><span class="line">  vector&lt;struct st_columns&gt; m_vallcols;  <span class="comment">// 存放全部字段信息的容器。</span></span><br><span class="line">  vector&lt;struct st_columns&gt; m_vpkcols;   <span class="comment">// 存放主键字段信息的容器。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> m_allcols[<span class="number">3001</span>];  <span class="comment">// 全部的字段名列表，以字符串存放，中间用半角的逗号分隔。</span></span><br><span class="line">  <span class="keyword">char</span> m_pkcols[<span class="number">301</span>];    <span class="comment">// 主键字段名列表，以字符串存放，中间用半角的逗号分隔。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initdata</span><span class="params">()</span></span>;  <span class="comment">// 成员变量初始化。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取指定表的全部字段信息。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">allcols</span><span class="params">(connection *conn,<span class="keyword">char</span> *tablename)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取指定表的主键字段信息。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">pkcols</span><span class="params">(connection *conn,<span class="keyword">char</span> *tablename)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="allcols获取全部字段"><a href="#allcols获取全部字段" class="headerlink" title="allcols获取全部字段"></a>allcols获取全部字段</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定表的全部字段信息。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTABCOLS::allcols</span><span class="params">(connection *conn,<span class="keyword">char</span> *tablename)</span></span>&#123;</span><br><span class="line">  m_allcount=<span class="number">0</span>;</span><br><span class="line">  m_vallcols.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">memset</span>(m_allcols,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(m_allcols));</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_columns</span> <span class="title">stcolumns</span>;</span></span><br><span class="line"></span><br><span class="line">  sqlstatement stmt;</span><br><span class="line">  stmt.<span class="built_in">connect</span>(conn);</span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select lower(column_name),lower(data_type),character_maximum_length from information_schema.COLUMNS where table_name=:1&quot;</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,tablename,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>, stcolumns.colname,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">2</span>, stcolumns.datatype,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">3</span>,&amp;stcolumns.collen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;stcolumns,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_columns));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列的数据类型，分为number、date和char三大类。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;char&quot;</span>)==<span class="number">0</span>)    <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;char&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;varchar&quot;</span>)==<span class="number">0</span>) <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;char&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;datetime&quot;</span>)==<span class="number">0</span>)  <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;date&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;timestamp&quot;</span>)==<span class="number">0</span>) <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;date&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;tinyint&quot;</span>)==<span class="number">0</span>)   <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;smallint&quot;</span>)==<span class="number">0</span>)  <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;mediumint&quot;</span>)==<span class="number">0</span>) <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;int&quot;</span>)==<span class="number">0</span>)       <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;integer&quot;</span>)==<span class="number">0</span>)   <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;bigint&quot;</span>)==<span class="number">0</span>)    <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;numeric&quot;</span>)==<span class="number">0</span>)   <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;decimal&quot;</span>)==<span class="number">0</span>)   <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;float&quot;</span>)==<span class="number">0</span>)     <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;double&quot;</span>)==<span class="number">0</span>)    <span class="built_in">strcpy</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果业务有需要，可以修改上面的代码，增加对更多数据类型的支持。</span></span><br><span class="line">    <span class="comment">// 如果字段的数据类型不在上面列出来的中，忽略它。</span></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;char&quot;</span>)!=<span class="number">0</span>) &amp;&amp;</span><br><span class="line">         (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;date&quot;</span>)!=<span class="number">0</span>) &amp;&amp;</span><br><span class="line">         (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>)!=<span class="number">0</span>) ) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字段类型是date，把长度设置为19。yyyy-mm-dd hh:mi:ss</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;date&quot;</span>)==<span class="number">0</span>) stcolumns.collen=<span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字段类型是number，把长度设置为20。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(stcolumns.datatype,<span class="string">&quot;number&quot;</span>)==<span class="number">0</span>) stcolumns.collen=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(m_allcols,stcolumns.colname); <span class="built_in">strcat</span>(m_allcols,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    m_vallcols.<span class="built_in">push_back</span>(stcolumns);</span><br><span class="line"></span><br><span class="line">    m_allcount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除m_allcols最后一个多余的逗号。</span></span><br><span class="line">  <span class="keyword">if</span> (m_allcount&gt;<span class="number">0</span>) m_allcols[<span class="built_in">strlen</span>(m_allcols)<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pkcols获取指定字段同理</p>
<h5 id="拼接SQL语句"><a href="#拼接SQL语句" class="headerlink" title="拼接SQL语句"></a>拼接SQL语句</h5><p>​        实现insert和update功能，目的是组装好对应的mysql语句，然后存放到char strinsertsql[10241]和char strupdatesql[10241]中，方便</p>
<p>​        </p>
<p>主要是用于数据入库的参数配置文件的uptbz参数使用，1为更新，2是不更新</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220731173256014.png" alt="image-20220731173256014"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--该参数文件存放了数据中心入库参数。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmltodb</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filename</span>&gt;</span>ZHOBTCODE_*.XML<span class="tag">&lt;/<span class="name">filename</span>&gt;</span><span class="tag">&lt;<span class="name">tname</span>&gt;</span>T_ZHOBTCODE1<span class="tag">&lt;/<span class="name">tname</span>&gt;</span><span class="tag">&lt;<span class="name">uptbz</span>&gt;</span>1<span class="tag">&lt;/<span class="name">uptbz</span>&gt;</span><span class="tag">&lt;<span class="name">execsql</span>&gt;</span>delete from T_ZHOBTCODE1<span class="tag">&lt;/<span class="name">execsql</span>&gt;</span><span class="tag">&lt;<span class="name">endl</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filename</span>&gt;</span>ZHOBTMIND_*.XML<span class="tag">&lt;/<span class="name">filename</span>&gt;</span><span class="tag">&lt;<span class="name">tname</span>&gt;</span>T_ZHOBTMIND1<span class="tag">&lt;/<span class="name">tname</span>&gt;</span><span class="tag">&lt;<span class="name">uptbz</span>&gt;</span>2<span class="tag">&lt;/<span class="name">uptbz</span>&gt;</span><span class="tag">&lt;<span class="name">endl</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xmltodb</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼接生成插入和更新表数据的SQL。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crtsql</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(strinsertsql,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strinsertsql));    <span class="comment">// 插入表的SQL语句。</span></span><br><span class="line">  <span class="built_in">memset</span>(strupdatesql,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strupdatesql));    <span class="comment">// 更新表的SQL语句。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成插入表的SQL语句。 insert into 表名(%s) values(%s)</span></span><br><span class="line">  <span class="comment">// 更新时间和自增字段不需要出现在表的更新里，是自动完成的</span></span><br><span class="line">  <span class="keyword">char</span> strinsertp1[<span class="number">3001</span>];    <span class="comment">// insert语句的字段列表。</span></span><br><span class="line">  <span class="keyword">char</span> strinsertp2[<span class="number">3001</span>];    <span class="comment">// insert语句values后的内容。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(strinsertp1,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strinsertp1));</span><br><span class="line">  <span class="built_in">memset</span>(strinsertp2,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strinsertp2));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> colseq=<span class="number">1</span>;   <span class="comment">// values部分字段的序号。</span></span><br><span class="line">                  <span class="comment">// 设置在循环外面，没有直接用i，就是因为upttime和keyid的存在。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="comment">// upttime和keyid这两个字段不需要处理。</span></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;upttime&quot;</span>)==<span class="number">0</span>) ||</span><br><span class="line">         (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;keyid&quot;</span>)==<span class="number">0</span>) ) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拼接strinsertp1</span></span><br><span class="line">    <span class="built_in">strcat</span>(strinsertp1,TABCOLS.m_vallcols[i].colname); <span class="built_in">strcat</span>(strinsertp1,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接strinsertp2，需要区分date字段和非date字段。</span></span><br><span class="line">    <span class="keyword">char</span> strtemp[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].datatype,<span class="string">&quot;date&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot;:%d&quot;</span>,colseq);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot;str_to_date(:%d,&#x27;%%%%Y%%%%m%%%%d%%%%H%%%%i%%%%s&#x27;)&quot;</span>,colseq);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(strinsertp2,strtemp);  <span class="built_in">strcat</span>(strinsertp2,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    colseq++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  strinsertp1[<span class="built_in">strlen</span>(strinsertp1)<span class="number">-1</span>]=<span class="number">0</span>;  <span class="comment">// 把最后一个多余的逗号删除。</span></span><br><span class="line">  strinsertp2[<span class="built_in">strlen</span>(strinsertp2)<span class="number">-1</span>]=<span class="number">0</span>;  <span class="comment">// 把最后一个多余的逗号删除。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SNPRINTF</span>(strinsertsql,<span class="number">10240</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strinsertsql),\</span><br><span class="line">           <span class="string">&quot;insert into %s(%s) values(%s)&quot;</span>,stxmltotable.tname,strinsertp1,strinsertp2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logfile.Write(&quot;strinsertsql=%s=\n&quot;,strinsertsql);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果入库参数中指定了表数据不需要更新，就不生成update语句了，函数返回。</span></span><br><span class="line">  <span class="keyword">if</span> (stxmltotable.uptbz!=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成修改表的SQL语句。</span></span><br><span class="line">  <span class="comment">// update T_ZHOBTMIND1 set t=:1,p=:2,u=:3,wd=:4,wf=:5,r=:6,vis=:7,upttime=now(),mint=:8,minttime=str_to_date(:9,&#x27;%Y%m%d%H%i%s&#x27;) where obtid=:10 and ddatetime=str_to_date(:11,&#x27;%Y%m%d%H%i%s&#x27;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新TABCOLS.m_vallcols中的pkseq字段，在拼接update语句的时候要用到它。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TABCOLS.m_vpkcols.<span class="built_in">size</span>();i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>();jj++)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vpkcols[i].colname,TABCOLS.m_vallcols[jj].colname)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 更新m_vallcols容器中的pkseq。</span></span><br><span class="line">        TABCOLS.m_vallcols[jj].pkseq=TABCOLS.m_vpkcols[i].pkseq; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先拼接update语句开始的部分。</span></span><br><span class="line">   <span class="built_in">sprintf</span>(strupdatesql,<span class="string">&quot;update %s set &quot;</span>,stxmltotable.tname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接update语句set后面的部分。</span></span><br><span class="line">  colseq=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="comment">// keyid字段不需要处理。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;keyid&quot;</span>)==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是主键字段，也不需要拼接在set的后面。</span></span><br><span class="line">    <span class="comment">// 主键部分不允许修改，避免主记录被删除和重复使用主记录</span></span><br><span class="line">    <span class="keyword">if</span> (TABCOLS.m_vallcols[i].pkseq!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// upttime字段直接等于now()，这么做是为了考虑数据库的兼容性。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;upttime&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">strcat</span>(strupdatesql,<span class="string">&quot;upttime=now(),&quot;</span>); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它字段需要区分date字段和非date字段。</span></span><br><span class="line">    <span class="keyword">char</span> strtemp[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].datatype,<span class="string">&quot;date&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot;%s=:%d&quot;</span>,TABCOLS.m_vallcols[i].colname,colseq);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot;%s=str_to_date(:%d,&#x27;%%%%Y%%%%m%%%%d%%%%H%%%%i%%%%s&#x27;)&quot;</span>,TABCOLS.m_vallcols[i].colname,colseq);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(strupdatesql,strtemp);  <span class="built_in">strcat</span>(strupdatesql,<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    colseq++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  strupdatesql[<span class="built_in">strlen</span>(strupdatesql)<span class="number">-1</span>]=<span class="number">0</span>;    <span class="comment">// 删除最后一个多余的逗号。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后再拼接update语句where后面的部分。</span></span><br><span class="line">  <span class="built_in">strcat</span>(strupdatesql,<span class="string">&quot; where 1=1 &quot;</span>);      <span class="comment">// 用1=1是为了后面的拼接方便，这是常用的处理方法。</span></span><br><span class="line">                                           <span class="comment">// 后面如果有判断条件，就一个接一个就可以了，因为where后面必须有值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (TABCOLS.m_vallcols[i].pkseq==<span class="number">0</span>) <span class="keyword">continue</span>;   <span class="comment">// 如果不是主键字段，跳过。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把主键字段拼接到update语句中，需要区分date字段和非date字段。</span></span><br><span class="line">    <span class="keyword">char</span> strtemp[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].datatype,<span class="string">&quot;date&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot; and %s=:%d&quot;</span>,TABCOLS.m_vallcols[i].colname,colseq);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot; and %s=str_to_date(:%d,&#x27;%%%%Y%%%%m%%%%d%%%%H%%%%i%%%%s&#x27;)&quot;</span>,TABCOLS.m_vallcols[i].colname,colseq);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(strupdatesql,strtemp);  </span><br><span class="line"></span><br><span class="line">    colseq++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logfile.Write(&quot;strupdatesql=%s\n&quot;,strupdatesql);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="绑定SQL语句参数"><a href="#绑定SQL语句参数" class="headerlink" title="绑定SQL语句参数"></a>绑定SQL语句参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prepare插入和更新的sql语句，绑定输入变量。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXCOLCOUNT  300                    <span class="comment">// 每个表字段的最大数。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXCOLLEN    100                    <span class="comment">// 表字段值的最大长度。</span></span></span><br><span class="line"><span class="keyword">char</span> strcolvalue[MAXCOLCOUNT][MAXCOLLEN+<span class="number">1</span>]; <span class="comment">// 存放从xml每一行中解析出来的值。</span></span><br><span class="line">sqlstatement stmtins,stmtupt;               <span class="comment">// 插入和更新表的sqlstatement对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preparesql</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>连接数据库，将之前生成的sql语句用prepare方法，绑定在sqlstatement对象中，并跳过掉比如upttime、keyid、pkseq主键等字段，利用bindin函数绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prepare插入和更新的sql语句，绑定输入变量。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preparesql</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 绑定插入sql语句的输入变量。</span></span><br><span class="line">  stmtins.<span class="built_in">connect</span>(&amp;conn);</span><br><span class="line">  stmtins.<span class="built_in">prepare</span>(strinsertsql);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> colseq=<span class="number">1</span>;        <span class="comment">// values部分字段的序号。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="comment">// upttime和keyid这两个字段不需要处理。</span></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;upttime&quot;</span>)==<span class="number">0</span>) ||</span><br><span class="line">         (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;keyid&quot;</span>)==<span class="number">0</span>) ) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注意，strcolvalue数组的使用不是连续的，是和TABCOLS.m_vallcols的下标是一一对应的。</span></span><br><span class="line">    stmtins.<span class="built_in">bindin</span>(colseq,strcolvalue[i],TABCOLS.m_vallcols[i].collen);</span><br><span class="line"></span><br><span class="line">    colseq++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 绑定更新sql语句的输入变量。</span></span><br><span class="line">  <span class="comment">// 如果入库参数中指定了表数据不需要更新，就不处理update语句了，函数返回。</span></span><br><span class="line">  <span class="keyword">if</span> (stxmltotable.uptbz!=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  stmtupt.<span class="built_in">connect</span>(&amp;conn);</span><br><span class="line">  stmtupt.<span class="built_in">prepare</span>(strupdatesql);</span><br><span class="line"></span><br><span class="line">  colseq=<span class="number">1</span>;        <span class="comment">// set和where部分字段的序号。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定set部分的输入参数。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="comment">// upttime和keyid这两个字段不需要处理。</span></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;upttime&quot;</span>)==<span class="number">0</span>) ||</span><br><span class="line">         (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].colname,<span class="string">&quot;keyid&quot;</span>)==<span class="number">0</span>) ) <span class="keyword">continue</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果是主键字段，也不需要拼接在set的后面。</span></span><br><span class="line">    <span class="keyword">if</span> (TABCOLS.m_vallcols[i].pkseq!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，strcolvalue数组的使用不是连续的，是和TABCOLS.m_vallcols的下标是一一对应的。</span></span><br><span class="line">    stmtupt.<span class="built_in">bindin</span>(colseq,strcolvalue[i],TABCOLS.m_vallcols[i].collen);</span><br><span class="line"></span><br><span class="line">    colseq++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定where部分的输入参数。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="comment">// 如果不是主键字段，跳过，只有主键字段才拼接在where的后面。</span></span><br><span class="line">    <span class="keyword">if</span> (TABCOLS.m_vallcols[i].pkseq==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意，strcolvalue数组的使用不是连续的，是和TABCOLS.m_vallcols的下标是一一对应的。</span></span><br><span class="line">    stmtupt.<span class="built_in">bindin</span>(colseq,strcolvalue[i],TABCOLS.m_vallcols[i].collen);</span><br><span class="line"></span><br><span class="line">    colseq++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h5><p>执行主要是<strong>插入和更新</strong>操作。</p>
<p>解析XML，将内部语句存放在已绑定的输入变量，方便直接execute()执行命令，execute后全都是判断错误代码，也就是万一发生意外时，能在日志保存下痕迹。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 从xml文件中读取一行。</span></span><br><span class="line">    <span class="keyword">if</span> (File.<span class="built_in">FFGETS</span>(strBuffer,<span class="number">10240</span>,<span class="string">&quot;&lt;endl/&gt;&quot;</span>)==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    totalcount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析xml，存放在已绑定的输入变量strcolvalue数组中。</span></span><br><span class="line">    <span class="built_in">splitbuffer</span>(strBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行插入和更新的SQL。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtins.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (stmtins.m_cda.rc==<span class="number">1062</span>)&#123;  <span class="comment">// 违反唯一性约束，表示记录已存在。</span></span><br><span class="line">        <span class="comment">// 判断入库参数的更新标志。</span></span><br><span class="line">        <span class="keyword">if</span> (stxmltotable.uptbz==<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (stmtupt.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 数据入库程序是一个通用的模块，不会因为某一行报错就停止，不要停下啊！</span></span><br><span class="line">            <span class="comment">// 如果update失败，记录出错的行和错误内容，函数不返回，继续处理数据，也就是说，不理这一行。</span></span><br><span class="line">            logfile.<span class="built_in">Write</span>(<span class="string">&quot;%s&quot;</span>,strBuffer);</span><br><span class="line">            logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtupt.execute() failed.\n%s\n%s\n&quot;</span>,stmtupt.m_sql,stmtupt.m_cda.message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据库连接已失效，无法继续，只能返回。 </span></span><br><span class="line">            <span class="comment">// 1053-在操作过程中服务器关闭。2013-查询过程中丢失了与MySQL服务器的连接。</span></span><br><span class="line">            <span class="keyword">if</span> ( (stmtupt.m_cda.rc==<span class="number">1053</span>) || (stmtupt.m_cda.rc==<span class="number">2013</span>) ) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> uptcount++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果insert失败，记录出错的行和错误内容，函数不返回，继续处理数据，也就是说，不理这一行。</span></span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;%s&quot;</span>,strBuffer);</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtins.execute() failed.\n%s\n%s\n&quot;</span>,stmtins.m_sql,stmtins.m_cda.message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据库连接已失效，无法继续，只能返回。</span></span><br><span class="line">        <span class="comment">// 1053-在操作过程中服务器关闭。2013-查询过程中丢失了与MySQL服务器的连接。</span></span><br><span class="line">        <span class="keyword">if</span> ( (stmtins.m_cda.rc==<span class="number">1053</span>) || (stmtins.m_cda.rc==<span class="number">2013</span>) ) <span class="keyword">return</span> <span class="number">4</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> inscount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  conn.<span class="built_in">commit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析XML</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析xml，存放在已绑定的输入变量strcolvalue数组中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitbuffer</span><span class="params">(<span class="keyword">char</span> *strBuffer)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化strcolvalue数组。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;TABCOLS.m_allcount; i++) </span><br><span class="line">    <span class="built_in">memset</span>(strcolvalue[i],<span class="number">0</span>,TABCOLS.m_vallcols[i].collen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> strtemp[<span class="number">31</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;TABCOLS.m_vallcols.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="comment">// 如果是日期时间字段，提取数值就可以了。</span></span><br><span class="line">    <span class="comment">// 解析就是指将xml解析成字符串</span></span><br><span class="line">    <span class="comment">// 也就是说，xml文件中的日期时间只要包含了yyyymmddhh24miss就行，可以是任意分隔符。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].datatype,<span class="string">&quot;date&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 这感觉应该是解析结果存放在strtemp里面,因为strBuffer是文件的一行</span></span><br><span class="line">      <span class="built_in">GetXMLBuffer</span>(strBuffer,TABCOLS.m_vallcols[i].colname,strtemp,TABCOLS.m_vallcols[i].collen);</span><br><span class="line">      <span class="comment">// 将时间格式中的数字提取出来存好，不需要+-，圆点。</span></span><br><span class="line">      <span class="built_in">PickNumber</span>(strtemp,strcolvalue[i],<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是数值字段，只提取数字、+-符号和圆点。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[i].datatype,<span class="string">&quot;number&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">GetXMLBuffer</span>(strBuffer,TABCOLS.m_vallcols[i].colname,strtemp,TABCOLS.m_vallcols[i].collen);</span><br><span class="line">      <span class="built_in">PickNumber</span>(strtemp,strcolvalue[i],<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是字符字段，直接提取。</span></span><br><span class="line">    <span class="built_in">GetXMLBuffer</span>(strBuffer,TABCOLS.m_vallcols[i].colname,strcolvalue[i],TABCOLS.m_vallcols[i].collen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="完善与优化"><a href="#完善与优化" class="headerlink" title="完善与优化"></a>完善与优化</h4><p>问题一：我们首先观察，入库文件太单调了，正常的程序而言，应该反映出插入多少，删除多少这些虽然不必要但是也应该有的数据。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801212504895.png" alt="image-20220801212504895"></p>
<p>解决方案：在合适的位置，记录对应指标。（记得初始化）<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801212612982.png" alt="image-20220801212612982"></p>
<p>问题二：<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801212856401.png" alt="image-20220801212856401"></p>
<p>解决方案：</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801212942976.png" alt="image-20220801212942976"></p>
<p>问题三：长时间没有数据文件处理</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801213112080.png" alt="image-20220801213112080"></p>
<p>​        我们来梳理一下结构，一般来说，如果只开启一个隧道，那么可能就会出现数据堵塞的情况，造成延迟upttime，因此可以采取开启多条传输通道，但每种数据的特点不同，因此要分开处理，另外，也有可能数据库长时间未连接断开，所以这个判断语句应该放在while里定期检测，而不是放在开头只检测一次</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801213326290.png" alt="image-20220801213326290"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801213855223.png" alt="image-20220801213855223"></p>
<p>问题四：字符串的大小和长度都是用宏处理，如果表的字段和长度大于定义的宏，那么就会出现<code>内存溢出</code>的问题。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801214255347.png" alt="image-20220801214255347"></p>
<p>解决方案：动态内存处理</p>
<p>MAXCOLCOUNT调整为500个字段，（实际开发连300个字段基本上都没见到过），并将char二维数组变成char指针数组</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801214426526.png" alt="image-20220801214426526"></p>
<p>在int _xmltodb中动态的分配内存（要记得使用之前，splitbuffer内初始化）<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801214847720.png" alt="image-20220801214847720"></p>
<p>释放内存放在int _xmltodb的靠前部分，因为我们每次使用该函数，都需要将上次使用的痕迹清空，也就是把上次读取到的字段啥的都清空呗，并且指针也置为空。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801215212673.png" alt="image-20220801215212673"></p>
<p>最后一个地方就是进程的心跳。在程序中，每处理一次文件，增加一个心跳。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801215535943.png" alt="image-20220801215535943"></p>
<h4 id="执行错误提示"><a href="#执行错误提示" class="headerlink" title="执行错误提示"></a>执行错误提示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理xml文件成功，写日志，备份文件。</span></span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">0</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;ok(%s,total=%d,insert=%d,update=%d).\n&quot;</span>,stxmltotable.tname,totalcount,inscount,uptcount);</span><br><span class="line">        <span class="comment">// 把xml文件移动到starg.xmlpathbak参数指定的目录中，一般不会发生错误，如果真发生了，程序将退出。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">xmltobakerr</span>(Dir.m_FullFileName,starg.xmlpath,starg.xmlpathbak)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1-没有配置入库参数；2-待入库的表不存在；5-表的字段数太多。</span></span><br><span class="line">      <span class="keyword">if</span> ( (iret==<span class="number">1</span>) || (iret==<span class="number">2</span>) || (iret==<span class="number">5</span>) )&#123;</span><br><span class="line">        <span class="keyword">if</span> (iret==<span class="number">1</span>) logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed，没有配置入库参数。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (iret==<span class="number">2</span>) logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed，待入库的表（%s）不存在。\n&quot;</span>,stxmltotable.tname);</span><br><span class="line">        <span class="keyword">if</span> (iret==<span class="number">5</span>) logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed，待入库的表（%s）字段数太多。\n&quot;</span>,stxmltotable.tname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把xml文件移动到starg.xmlpatherr参数指定的目录中，一般不会发生错误，如果真发生了，程序将退出。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">xmltobakerr</span>(Dir.m_FullFileName,starg.xmlpath,starg.xmlpatherr)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 打开xml文件错误，这种错误一般不会发生，如果真发生了，程序将退出。</span></span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">3</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed，打开xml文件失败。\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 数据库错误，函数返回，程序将退出。</span></span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">4</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed，数据库错误。\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在处理xml文件之前，如果执行stxmltotable.execsql失败，函数返回，程序将退出。</span></span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">6</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot;failed，执行execsql失败。\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果刚才这次扫描到了有文件，表示不空闲，可能不断的有文件生成，就不sleep了。</span></span><br><span class="line">    <span class="keyword">if</span> (Dir.m_vFileName.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="built_in">sleep</span>(starg.timetvl);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="大量数据入库的方案"><a href="#大量数据入库的方案" class="headerlink" title="大量数据入库的方案"></a>大量数据入库的方案</h3><p>这个系统能够满足95%以上的业务需求，但业务总是复杂的，总有很多特殊的需求。这里举一个例子说明，车主服务。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801221628042.png" alt="image-20220801221628042"></p>
<p>​        然而公安局肯定不会提供他自己的数据库给你 连接，而是提供视图<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801221725665.png" alt="image-20220801221725665"></p>
<p>未处理就是还没有交罚款的，这种数据有两个特点：</p>
<ol>
<li>数据是视图，没有时间戳，也没有自增字段</li>
<li>数据量非常大，通常超百万</li>
</ol>
<p>这种数据，怎么采撷，用数据抽取程序，每次采用全量抽取，每次放在一个文件中，再把文件传回来，那么，数据拿回来之后，如何入库？</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801222026988.png" alt="image-20220801222026988"></p>
<p>因此我们还是采用和创建文件类似的方法，注意是删除表，不是删除表中的数据，这种方法也会有延迟，延迟在于删除到改名那0.00几秒，正常情况不会影响业务。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220801222242318.png" alt="image-20220801222242318"></p>
<h2 id="八、数据处理和统计"><a href="#八、数据处理和统计" class="headerlink" title="八、数据处理和统计"></a>八、数据处理和统计</h2><h3 id="数据中心总体结构图"><a href="#数据中心总体结构图" class="headerlink" title="数据中心总体结构图"></a>数据中心总体结构图</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802103648774.png" alt="image-20220802103648774"></p>
<p>​        我们之前开发的TCP传输，FTP传输，数据抽取模块都是用于数据采集，为了解决从数据源取数据的问题，如果是xml或者json格式，直接入库，如果不是，则转化为xml和json，这个工作称为<code>数据处理</code>。</p>
<p>​        数据入库到数据库中，可能要进行统计分析，再加工成新的业务产品，这个工作看业务需求。   </p>
<h3 id="数据处理的工作内容"><a href="#数据处理的工作内容" class="headerlink" title="数据处理的工作内容"></a>数据处理的工作内容</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802104150286.png" alt="image-20220802104150286"></p>
<p>不管怎么复杂，我们做的只有<strong>三步</strong></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802104546733.png" alt="image-20220802104546733"></p>
<h3 id="数据统计的工作内容"><a href="#数据统计的工作内容" class="headerlink" title="数据统计的工作内容"></a>数据统计的工作内容</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802104632149.png" alt="image-20220802104632149"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802104922612.png" alt="image-20220802104922612"></p>
<h2 id="九、数据同步子系统"><a href="#九、数据同步子系统" class="headerlink" title="九、数据同步子系统"></a>九、数据同步子系统</h2><h3 id="mysql高可用"><a href="#mysql高可用" class="headerlink" title="mysql高可用"></a>mysql高可用</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39959236/article/details/113691851">(18条消息) 什么是mysql的高可用_如何做到数据库高可用？_weixin_39959236的博客-CSDN博客</a></p>
</blockquote>
<p><em>那么什么是数据库高可用？</em></p>
<p>​        高可用(High Availability)是系统架构设计中必须考虑的因素之一，它通常是指，<strong>通过设计减少系统不能提供服务的时间</strong>。</p>
<p>​        如果一台系统能够不间断的提供服务，那么这台系统的可用性据说100%。那如果系统每运行100个时间单位，就会出现1个时间单位无法提供服务，那么该台系统的可用性是99%。</p>
<p>​        目前大部分企业的高可用目标是4个9，也就是99.99%，也就是允许这台系统的年停机时间为52.56分钟。</p>
<p>为实现系统高可用，其架构设计的核心准则是：<code>冗余</code>。</p>
<p>​        系统需要全天候24销售不间断运行，则需要相应的冗余机制，以防某台机器宕掉时无法访问，而冗余则可以通过部署至少两台服务器构成一个集群实现服务高可用。数据库除了定期备份还需要实现冷热备份。甚至可以在全球范围内部署灾备数据中心。</p>
<p><em>容灾就等价于高可用？</em></p>
<p>​        有人说容灾所说的“灾难”指的大范围，高烈度的故障，例如火灾、地震、洪水、大范围的停电，所以往往还会有个限定词叫异地容灾。而高可用只要做到硬件冗余，实现单点故障时的业务接管就行了。这个观点只对了一半。</p>
<p>​        现如今，<strong>企业真正关心的“灾难”可以泛指非正常情况下的故障停机</strong>，而高可用则还应当应对由于IT运维工作等原因带来的计划内停机，因为无论是计划内还是计划外的停机都会对企业业务连续性造成损失。并且灾难故障往往是十年一遇甚至百年一遇，而维护停机工作才是无可避免经常会对业务连续性造成威胁的停机事件。</p>
<p>mysql的高可用没什么特别，如果数据量不大，一个master，一个slave（从属），如果读需求很大，那就多加几个slave，如果一个master不能满足写的需求，那就创造多个master，再带多个slave。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802110627840.png" alt="image-20220802110627840"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802110637292.png" alt="image-20220802110637292"></p>
<h4 id="三点不足"><a href="#三点不足" class="headerlink" title="三点不足"></a>三点不足</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802110716853.png" alt="image-20220802110716853"></p>
<p>虽然有第三方的软件可以解决部分问题，但是要给钱，我们可以自己做数据复制，也叫数据同步，弥补mysql高可用方案的不足。</p>
<p>​        mysql的高可用只是简单的提供多个副本，数据库中有很多个数据，很多个表，不管你是否需要，它都给你复制过去。</p>
<h3 id="数据架构"><a href="#数据架构" class="headerlink" title="数据架构"></a>数据架构</h3><p>​        在我们这个课程中，数据架构是这样的，上面那几个数据库可以称为核心数据库，负责数据的入库，统计，加工和管理，如果一个数据库忙不过来，那就增加几个，这也是最理想的解决方案。有多少数据就增加几个。</p>
<p>​        核心数据库采用一主一备的方案，是为了处理<strong>单点故障</strong></p>
<blockquote>
<p>单点故障 （英语：single point of failure，缩写 SPOF ）是指 <strong>系统 中一点失效，就会让整个系统无法运作的部件</strong>，换句话说，单点故障即会整体故障。</p>
</blockquote>
<p>​        下面那层数据库是应用数据库，就是把数据提供给别人的库，向其他的系统提供数据支撑服务。应用数据库没有主备之分，但是有冗余，如果某一个应用数据库出现了问题，切换到另一个就行了。</p>
<p>​        数据同步子系统负责把核心数据库中的数据同步到业务数据库中，数据同步子系统就是我们要开发的内容</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802111358482.png" alt="image-20220802111358482"></p>
<p>​        这是我们这个系统所用的架构，红色的箭头代表mysql自带的数据复制功能，下面那些密密麻麻的箭头是我们的数据同步程序，对应用数据库来说，它不需要是某个库的副本，他更关心的是他服务的对象需要什么数据。比如说预报库的数据来自于ABC三个库，他需要什么就存什么，不需要就不存，再比如说，实时数据库，他虽然核心数据库的，但是他只有最近三天的，超过三天的都不需要存，他的特点是数据很齐全，访问的效率很高，但是数据的数量不多。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802111512625.png" alt="image-20220802111512625"></p>
<h3 id="dederated引擎配置"><a href="#dederated引擎配置" class="headerlink" title="dederated引擎配置"></a>dederated引擎配置</h3><p><a target="_blank" rel="noopener" href="https://www.yisu.com/zixun/31671.html">Linux下MySQL开启Federated引擎方法 - MySQL数据库 - 亿速云 (yisu.com)</a></p>
<p>​        创建federated引擎，注意，表名字随意，字段只能比远程端那个表的字段少，属于被包含关系。另外一定要创建主键和唯一键，不然使用federated只会导致性能大幅度下降。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802114231055.png" alt="image-20220802114231055"></p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、FEDERATED 表可能会被复制到其他的slave数据库,你需要确保slave服务器也能够使用定义在connection中或mysql.servers表中的link的用户名/密码 连接上远程服务器。</span><br><span class="line"></span><br><span class="line">2、远程服务器必须是MySQL数据库，更重要是，必须要兼容不同版本的mysql，兼不兼容试了才知道。</span><br><span class="line"></span><br><span class="line">3、在访问FEDERATED表中定义的远程数据库的表前,远程数据库中必须存在这张表。</span><br><span class="line"></span><br><span class="line">***************************************最重要的第四条</span><br><span class="line">4、FEDERATED不支持普通索引（只支持主键和唯一键的快速查找），就算加了查询条件，也会进行全局扫描，从远程服务器把全部的数据拿回来，在本地进行过滤，会造成数据库性能的大幅度下降，还会增加网络IO磁盘说的压力</span><br><span class="line">***************************************</span><br><span class="line"></span><br><span class="line">5、FEDERATED表不支持ALTER TABLE语句或者任何DDL语句</span><br><span class="line">-- 所有的 DDL 语句都会导致事务隐式提交，换句话说，当你在执行 DDL 语句前，事务就已经提交了。这就意味着带有 DDL 语句的事务将来没有办法 rollback。也就是ctrl + z</span><br><span class="line"></span><br><span class="line">6、FEDERATED表不支持事务，就算支持，我们也不会使用它，因为远程事务问题很多，不稳定，oracle中也不会用。</span><br><span class="line"></span><br><span class="line">7、本地FEDERATED表无法知道远程库中表结构的改变</span><br><span class="line">-- 只是一个链接而已，不是相互奔赴，就好像这个世界上你不知道有多少人认识你一样</span><br><span class="line"></span><br><span class="line">8、任何drop语句都只是对本地库的操作,不对远程库有影响，就只是删除本地的链接而已，与远程表无关</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220802115147847.png" alt="image-20220802115147847"></p>
<h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220803222315306.png" alt="image-20220803222315306"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table LK_ZHOBTCODE1</span><br><span class="line">(</span><br><span class="line">   obtid                varchar(10) not null comment &#x27;站点代码&#x27;,</span><br><span class="line">   cityname             varchar(30) not null comment &#x27;城市名称&#x27;,</span><br><span class="line">   provname             varchar(30) not null comment &#x27;省名称&#x27;,</span><br><span class="line">   lat                  int not null comment &#x27;纬度，单位：0.01度&#x27;,</span><br><span class="line">   lon                  int not null comment &#x27;经度，单位：0.01度&#x27;,</span><br><span class="line">   height               int not null comment &#x27;海拔高度，单位：0.1米&#x27;,</span><br><span class="line">   upttime              timestamp not null comment &#x27;更新时间&#x27;,</span><br><span class="line">   keyid                int not null auto_increment comment &#x27;记录编号，自动增长列&#x27;,</span><br><span class="line">   primary key (obtid),</span><br><span class="line">   unique key ZHOBTCODE1_KEYID (keyid)</span><br><span class="line">)ENGINE=FEDERATED CONNECTION=&#x27;mysql://root:123456@192.168.198.128:3306/mysql/T_ZHOBTCODE1&#x27; DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>注意：我是在同一台虚拟机上做实验，所以不能都放在3306端口，另外3307默认没有打开，因此需要输入指令<code>nc -lp3307&amp;</code>打开端口。</p>
<p>在打开指令之前，可以先输入<code>netstat -an| grep 3307</code>检测是否打开，另外<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_29608291/article/details/113233063">(18条消息) mysql开启多个端口_mysql单个实例开启多个端口_三金乐了的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39866817/article/details/113206921?spm=1001.2101.3001.6661.1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-113206921-blog-113233063.pc_relevant_default">(18条消息) mysql多端口配置_mysql多端口配置及其启动方法_weixin_39866817的博客-CSDN博客</a></p>
<p>算了，还是放弃了，理解思路就行hhc</p>
<p>最后还是解决了，将mysql root 的localhost改为%就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;; </span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>



<h3 id="全表刷新功能"><a href="#全表刷新功能" class="headerlink" title="全表刷新功能"></a>全表刷新功能</h3><p>只需要一行sql语句就能搞定，要按照这个写法写</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220804121224987.png" alt="image-20220804121224987"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220804121243384.png" alt="image-20220804121243384"></p>
<h3 id="分批刷新功能"><a href="#分批刷新功能" class="headerlink" title="分批刷新功能"></a>分批刷新功能</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220804121537292.png" alt="image-20220804121537292"></p>
<p><strong>两个注意点</strong></p>
<ol>
<li>分批操作的流程需要一个循环，在循环里面执行2、3步，直到全部的数据被处理完。</li>
<li>从远程表查询需要的数据，为什么不在federated表，原因有两个<ol>
<li>federated不支持普通索引，如果同步的条件不是主键，也不是唯一键，就会进行全表扫描。</li>
<li>就算federated表支持同步索引，也没有直接访问远程表来得好，因为传给federated需要经过一次中转，肯定没有不中转好<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220805152354891.png" alt="image-20220805152354891"> </li>
</ol>
</li>
</ol>
<h4 id="不同步分批"><a href="#不同步分批" class="headerlink" title="不同步分批"></a>不同步分批</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是不分批同步，表示需要同步的数据量比较少，执行一次SQL语句就可以搞定。</span></span><br><span class="line"><span class="keyword">if</span> (starg.synctype==<span class="number">1</span>)&#123;</span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;sync %s to %s ...&quot;</span>,starg.fedtname,starg.localtname);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先删除starg.localtname表中满足where条件的记录。</span></span><br><span class="line">  stmtdel.<span class="built_in">prepare</span>(<span class="string">&quot;delete from %s %s&quot;</span>,starg.localtname,starg.where);</span><br><span class="line">  <span class="keyword">if</span> (stmtdel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtdel.execute() failed.\n%s\n%s\n&quot;</span>,stmtdel.m_sql,stmtdel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再把starg.fedtname表中满足where条件的记录插入到starg.localtname表中。</span></span><br><span class="line">  stmtins.<span class="built_in">prepare</span>(<span class="string">&quot;insert into %s(%s) select %s from %s %s&quot;</span>,starg.localtname,starg.localcols,starg.remotecols,starg.fedtname,starg.where);</span><br><span class="line">  <span class="keyword">if</span> (stmtins.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtins.execute() failed.\n%s\n%s\n&quot;</span>,stmtins.m_sql,stmtins.m_cda.message); </span><br><span class="line">    connloc.<span class="built_in">rollback</span>();   <span class="comment">// 如果这里失败了，可以不用回滚事务，connection类的析构函数会回滚。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">WriteEx</span>(<span class="string">&quot; %d rows in %.2fsec.\n&quot;</span>,stmtins.m_cda.rpc,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line"></span><br><span class="line">  connloc.<span class="built_in">commit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要定义条件查询<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220805155019909.png" alt="image-20220805155019909"></p>
<p>有两个注意点，</p>
<p>​    一、为了解决federated表和本地表字段不同的问题，可以用两个while函数，一个用于federated表的查询，一个用于本地表的删除，实际项目中通常是字段相同的，但我们这个项目可以试试不同</p>
<p>​    二、系统时间可能存在读取数据的延迟，导致数据残缺。不过通常不分批同步数据量都很小（1w以下）所以无所谓，有两个解决办法，第一是写语句的时候就设置好时间<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220805155355071.png" alt="image-20220805155355071"></p>
<p>替换成<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220805155412141.png" alt="image-20220805155412141"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把connrem的连数据库的代码放在这里，如果synctype==1，根本就不用以下代码了。</span></span><br><span class="line">  <span class="keyword">if</span> (connrem.<span class="built_in">connecttodb</span>(starg.remoteconnstr,starg.charset) != <span class="number">0</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) failed.\n%s\n&quot;</span>,starg.remoteconnstr,connrem.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logfile.Write(&quot;connect database(%s) ok.\n&quot;,starg.remoteconnstr);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从远程表查找的需要同步记录的key字段的值。</span></span><br><span class="line">  <span class="keyword">char</span> remkeyvalue[<span class="number">51</span>];    <span class="comment">// 从远程表查到的需要同步记录的key字段的值。</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmtsel</span><span class="params">(&amp;connrem)</span></span>;</span><br><span class="line">  stmtsel.<span class="built_in">prepare</span>(<span class="string">&quot;select %s from %s %s&quot;</span>,starg.remotekeycol,starg.remotetname,starg.where);</span><br><span class="line">  stmtsel.<span class="built_in">bindout</span>(<span class="number">1</span>,remkeyvalue,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接绑定同步SQL语句参数的字符串（:1,:2,:3,...,:starg.maxcount）。</span></span><br><span class="line">  <span class="keyword">char</span> bindstr[<span class="number">2001</span>];    <span class="comment">// 绑定同步SQL语句参数的字符串。</span></span><br><span class="line">  <span class="keyword">char</span> strtemp[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(bindstr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(bindstr));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;starg.maxcount;ii++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(strtemp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp));</span><br><span class="line">    <span class="built_in">sprintf</span>(strtemp,<span class="string">&quot;:%lu,&quot;</span>,ii+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(bindstr,strtemp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bindstr[<span class="built_in">strlen</span>(bindstr)<span class="number">-1</span>]=<span class="number">0</span>;    <span class="comment">// 最后一个逗号是多余的。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> keyvalues[starg.maxcount][<span class="number">51</span>]; <span class="comment">// 存放key字段的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备删除本地表数据的SQL语句，一次删除starg.maxcount条记录。</span></span><br><span class="line">  <span class="comment">// delete from T_ZHOBTCODE3 where stid in (:1,:2,:3,...,:starg.maxcount);</span></span><br><span class="line">  stmtdel.<span class="built_in">prepare</span>(<span class="string">&quot;delete from %s where %s in (%s)&quot;</span>,starg.localtname,starg.localkeycol,bindstr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;starg.maxcount;ii++)&#123;</span><br><span class="line">    stmtdel.<span class="built_in">bindin</span>(ii+<span class="number">1</span>,keyvalues[ii],<span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入本地表数据的SQL语句，一次插入starg.maxcount条记录。</span></span><br><span class="line">  <span class="comment">// insert into T_ZHOBTCODE3(stid ,cityname,provname,lat,lon,altitude,upttime,keyid)</span></span><br><span class="line">  <span class="comment">//                   select obtid,cityname,provname,lat,lon,height/10,upttime,keyid from LK_ZHOBTCODE1 </span></span><br><span class="line">  <span class="comment">//                    where obtid in (:1,:2,:3);</span></span><br><span class="line">  stmtins.<span class="built_in">prepare</span>(<span class="string">&quot;insert into %s(%s) select %s from %s where %s in (%s)&quot;</span>,starg.localtname,starg.localcols,starg.remotecols,starg.fedtname,starg.remotekeycol,bindstr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;starg.maxcount;ii++)&#123;</span><br><span class="line">    stmtins.<span class="built_in">bindin</span>(ii+<span class="number">1</span>,keyvalues[ii],<span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ccount=<span class="number">0</span>;    <span class="comment">// 记录从结果集中已获取记录的计数器。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(keyvalues,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(keyvalues));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stmtsel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtsel.execute() failed.\n%s\n%s\n&quot;</span>,stmtsel.m_sql,stmtsel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 获取需要同步数据的结果集。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtsel.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(keyvalues[ccount],remkeyvalue);</span><br><span class="line"></span><br><span class="line">    ccount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每starg.maxcount条记录执行一次同步。</span></span><br><span class="line">    <span class="keyword">if</span> (ccount==starg.maxcount)&#123;</span><br><span class="line">      <span class="comment">// 从本地表中删除记录。</span></span><br><span class="line">      <span class="keyword">if</span> (stmtdel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 执行从本地表中删除记录的操作一般不会出错。</span></span><br><span class="line">        <span class="comment">// 如果报错，就肯定是数据库的问题或同步的参数配置不正确，流程不必继续。</span></span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtdel.execute() failed.\n%s\n%s\n&quot;</span>,stmtdel.m_sql,stmtdel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向本地表中插入记录。</span></span><br><span class="line">      <span class="keyword">if</span> (stmtins.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 执行向本地表中插入记录的操作一般不会出错。</span></span><br><span class="line">        <span class="comment">// 如果报错，就肯定是数据库的问题或同步的参数配置不正确，流程不必继续。</span></span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtins.execute() failed.\n%s\n%s\n&quot;</span>,stmtins.m_sql,stmtins.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;sync %s to %s(%d rows) in %.2fsec.\n&quot;</span>,starg.fedtname,starg.localtname,ccount,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line"></span><br><span class="line">      connloc.<span class="built_in">commit</span>();</span><br><span class="line">  </span><br><span class="line">      ccount=<span class="number">0</span>;    <span class="comment">// 记录从结果集中已获取记录的计数器。</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memset</span>(keyvalues,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(keyvalues));</span><br><span class="line"></span><br><span class="line">      PActive.<span class="built_in">UptATime</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ccount&gt;0，表示还有没同步的记录，再执行一次同步。</span></span><br><span class="line">  <span class="keyword">if</span> (ccount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 从本地表中删除记录。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtdel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtdel.execute() failed.\n%s\n%s\n&quot;</span>,stmtdel.m_sql,stmtdel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向本地表中插入记录。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtins.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtins.execute() failed.\n%s\n%s\n&quot;</span>,stmtins.m_sql,stmtins.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;sync %s to %s(%d rows) in %.2fsec.\n&quot;</span>,starg.fedtname,starg.localtname,ccount,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line"></span><br><span class="line">    connloc.<span class="built_in">commit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="增量同步数据模块"><a href="#增量同步数据模块" class="headerlink" title="增量同步数据模块"></a>增量同步数据模块</h3><p>​        开发了刷新同步之后，增量同步只需在此基础改就行。首先，增量同步肯定是分批的，我们删掉不分批的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _syncincrement(<span class="keyword">bool</span> &amp;bcontinue)&#123;</span><br><span class="line">  CTimer Timer;</span><br><span class="line"></span><br><span class="line">  bcontinue=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从本地表starg.localtname获取自增字段的最大值，存放在maxkeyvalue全局变量中。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">findmaxkey</span>()==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从远程表查找自增字段的值大于maxkeyvalue的记录。</span></span><br><span class="line">  <span class="keyword">char</span> remkeyvalue[<span class="number">51</span>];    <span class="comment">// 从远程表查到的需要同步记录的key字段的值。</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmtsel</span><span class="params">(&amp;connrem)</span></span>;</span><br><span class="line">  stmtsel.<span class="built_in">prepare</span>(<span class="string">&quot;select %s from %s where %s&gt;:1 %s order by %s&quot;</span>,starg.remotekeycol,starg.remotetname,starg.remotekeycol,starg.where,starg.remotekeycol);</span><br><span class="line">  stmtsel.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;maxkeyvalue);</span><br><span class="line">  stmtsel.<span class="built_in">bindout</span>(<span class="number">1</span>,remkeyvalue,<span class="number">50</span>);</span><br><span class="line">   <span class="comment">// 剩下的就是同步刷新功能已经展示过的</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220805180924250.png" alt="image-20220805180924250"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行同步的时间间隔，单位：秒，取值1-30。</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;timetvl&quot;</span>,&amp;starg.timetvl);</span><br><span class="line"><span class="keyword">if</span> (starg.timetvl&lt;=<span class="number">0</span>) &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;timetvl is null.\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (starg.timetvl&gt;<span class="number">30</span>) starg.timetvl=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本程序的超时时间，单位：秒，视数据量的大小而定，建议设置30以上。</span></span><br><span class="line"><span class="built_in">GetXMLBuffer</span>(strxmlbuffer,<span class="string">&quot;timeout&quot;</span>,&amp;starg.timeout);</span><br><span class="line"><span class="keyword">if</span> (starg.timeout==<span class="number">0</span>) &#123; logfile.<span class="built_in">Write</span>(<span class="string">&quot;timeout is null.\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下处理timetvl和timeout的方法虽然有点随意，但也问题不大，不让程序超时就可以了。</span></span><br><span class="line"><span class="keyword">if</span> (starg.timeout&lt;starg.timetvl+<span class="number">10</span>) starg.timeout=starg.timetvl+<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h4 id="获取自增字段最大值"><a href="#获取自增字段最大值" class="headerlink" title="获取自增字段最大值"></a>获取自增字段最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从本地表starg.localtname获取自增字段的最大值，存放在maxkeyvalue全局变量中。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findmaxkey</span><span class="params">()</span></span>&#123;</span><br><span class="line">  maxkeyvalue=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;connloc)</span></span>;</span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select max(%s) from %s&quot;</span>,starg.localkeycol,starg.localtname);</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;maxkeyvalue);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 用于将执行查询结果的返回值传入bindout的maxkeyvalue中</span></span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logfile.Write(&quot;maxkeyvalue=%ld\n&quot;,maxkeyvalue);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 业务处理主函数。一种优化</span></span><br><span class="line">  <span class="comment">// bcontinue在_syncincrement方法中先默认设为false，有数据则改为true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span>  bcontinue;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (_syncincrement(bcontinue)==<span class="literal">false</span>) <span class="built_in">EXIT</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bcontinue==<span class="literal">false</span>) <span class="built_in">sleep</span>(starg.timetvl);</span><br><span class="line"></span><br><span class="line">    PActive.<span class="built_in">UptATime</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> _syncincrement(<span class="keyword">bool</span> &amp;bcontinue)&#123;</span><br><span class="line"> ...................</span><br><span class="line">     <span class="comment">//  logfile.Write(&quot;sync %s to %s(%d rows) in %.2fsec.\n&quot;,starg.fedtname,starg.localtname,stmtsel.m_cda.rpc,Timer.Elapsed());</span></span><br><span class="line"> 	<span class="comment">// 程序正式启用采用这个</span></span><br><span class="line">     <span class="keyword">if</span> (stmtsel.m_cda.rpc&gt;<span class="number">0</span>) bcontinue=<span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不启用FEDERATED引擎"><a href="#不启用FEDERATED引擎" class="headerlink" title="不启用FEDERATED引擎"></a>不启用FEDERATED引擎</h4><p>直接从远程表提取到数据同步程序，后执行语句储存到本地表</p>
<p>在这里只实现增量功能用来举例</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807172525242.png" alt="image-20220807172525242"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _syncincrementex(<span class="keyword">bool</span> &amp;bcontinue) &#123;</span><br><span class="line">  CTimer Timer;</span><br><span class="line"></span><br><span class="line">  bcontinue=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从本地表starg.localtname获取自增字段的最大值，存放在maxkeyvalue全局变量中。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">findmaxkey</span>()==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拆分starg.localcols参数，得到本地表字段的个数。</span></span><br><span class="line">  CCmdStr CmdStr;</span><br><span class="line">  CmdStr.<span class="built_in">SplitToCmd</span>(starg.localcols,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> colcount=CmdStr.<span class="built_in">CmdCount</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从远程表查找自增字段的值大于maxkeyvalue的记录，存放在colvalues数组中。</span></span><br><span class="line">  <span class="keyword">char</span> colvalues[colcount][TABCOLS.m_maxcollen+<span class="number">1</span>];</span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmtsel</span><span class="params">(&amp;connrem)</span></span>;</span><br><span class="line">  stmtsel.<span class="built_in">prepare</span>(<span class="string">&quot;select %s from %s where %s&gt;:1 %s order by %s&quot;</span>,starg.remotecols,starg.remotetname,starg.remotekeycol,starg.where,starg.remotekeycol);</span><br><span class="line">  stmtsel.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;maxkeyvalue);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;colcount;ii++)</span><br><span class="line">    stmtsel.<span class="built_in">bindout</span>(ii+<span class="number">1</span>,colvalues[ii],TABCOLS.m_maxcollen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接插入SQL语句绑定参数的字符串 insert ... into starg.localtname values(:1,:2,...:colcount)</span></span><br><span class="line">  <span class="keyword">char</span> bindstr[<span class="number">2001</span>];    <span class="comment">// 绑定同步SQL语句参数的字符串。</span></span><br><span class="line">  <span class="keyword">char</span> strtemp[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(bindstr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(bindstr));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;colcount;ii++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(strtemp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp));</span><br><span class="line">    <span class="built_in">sprintf</span>(strtemp,<span class="string">&quot;:%lu,&quot;</span>,ii+<span class="number">1</span>);       <span class="comment">// 这里可以处理一下时间字段。</span></span><br><span class="line">    <span class="built_in">strcat</span>(bindstr,strtemp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bindstr[<span class="built_in">strlen</span>(bindstr)<span class="number">-1</span>]=<span class="number">0</span>;    <span class="comment">// 最后一个逗号是多余的。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备插入本地表数据的SQL语句。</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmtins</span><span class="params">(&amp;connloc)</span></span>;    <span class="comment">// 向本地表中插入数据的SQL语句。</span></span><br><span class="line">  stmtins.<span class="built_in">prepare</span>(<span class="string">&quot;insert into %s(%s) values(%s)&quot;</span>,starg.localtname,starg.localcols,bindstr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;colcount;ii++)&#123;</span><br><span class="line">    stmtins.<span class="built_in">bindin</span>(ii+<span class="number">1</span>,colvalues[ii],TABCOLS.m_maxcollen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stmtsel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtsel.execute() failed.\n%s\n%s\n&quot;</span>,stmtsel.m_sql,stmtsel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(colvalues,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(colvalues));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取需要同步数据的结果集。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtsel.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向本地表中插入记录。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtins.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 执行向本地表中插入记录的操作一般不会出错。</span></span><br><span class="line">      <span class="comment">// 如果报错，就肯定是数据库的问题或同步的参数配置不正确，流程不必继续。</span></span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtins.execute() failed.\n%s\n%s\n&quot;</span>,stmtins.m_sql,stmtins.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每1000条提交一次。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtsel.m_cda.rpc%<span class="number">1000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      connloc.<span class="built_in">commit</span>(); PActive.<span class="built_in">UptATime</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理最后未提交的数据。</span></span><br><span class="line">  <span class="keyword">if</span> (stmtsel.m_cda.rpc&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;sync %s to %s(%d rows) in %.2fsec.\n&quot;</span>,starg.remotetname,starg.localtname,stmtsel.m_cda.rpc,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line">    </span><br><span class="line">    connloc.<span class="built_in">commit</span>();</span><br><span class="line"></span><br><span class="line">    bcontinue=<span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="学习总结-3"><a href="#学习总结-3" class="headerlink" title="学习总结"></a>学习总结</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807174128810.png" alt="image-20220807174128810"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807174250259.png" alt="image-20220807174250259"></p>
<h4 id="mysql触发器"><a href="#mysql触发器" class="headerlink" title="mysql触发器"></a>mysql触发器</h4><p><strong>1、触发器的概念</strong></p>
<blockquote>
<p>[MySQL触发器概念、原理与用法详解_Mysql_脚本之家 (jb51.net)](<a target="_blank" rel="noopener" href="https://www.jb51.net/article/164675.htm#:~:text=">https://www.jb51.net/article/164675.htm#:~:text=</a> 触发器（trigger）是MySQL提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。.,——百度百科. 上面是百度给的触发器的概念，我理解的触发器的概念，就是你执行一条sql语句，这条sql语句的执行会自动去触发执行其他的sql语句，就这么简单。. 超简说明：sql1-&gt;触发-&gt;sqlN，一条sql触发多个sql.)</p>
</blockquote>
<blockquote>
<p>触发器（trigger）是MySQL提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。——百度百科</p>
</blockquote>
<p>上面是百度给的触发器的概念，我理解的触发器的概念，就是你执行一条sql语句，这条sql语句的执行会自动去触发执行其他的sql语句，就这么简单。</p>
<p>超简说明：sql1-&gt;触发-&gt;sqlN，<strong>一条sql触发多个sql</strong></p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>为何需要避免删除操作？</p>
<pre><code>     delete物理删除既不能释放磁盘空间，而且会**产生大量的碎片**，导**致索引频繁断裂**，**影响**SQL执行计划的**稳定性**，同时，在碎片回收时，**会耗用大量的CPU，磁盘空间**，影响表的正常DML操作。
</code></pre>
<p>​        在业务代码层面，应该做<strong>逻辑标记删除</strong>，避免物理删除，为了实现归档需求，可以采用MSQL分区特性来实现，都是DDL操作，没有碎片产生。</p>
<p>我们这个程序需要避免删除操作，但是如果表不是我们设计的怎么办？</p>
<p>​        用触发器同步，创建操作日志表，在账户基本信息表创建触发器，把对这个表的各种操作记录在日志表中</p>
<p>采用触发器同步的效率比较高，最大的问题是要在远程数据库表上创建触发器，会增加负担，另外也会对业务系统产生影响，出了问题不好归责，但是如果两个数据库都是自己的，那完全可以用<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807175334298.png" alt="image-20220807175334298"></p>
<p>​        第二个方法，增加一个程序，定期扫描远程表本地表，反正检查到不一样就删除。</p>
<p>​        第三个方法，就是数据抽取程序+数据入库程序</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807175837401.png" alt="image-20220807175837401"></p>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>第一个缺点不能说完全怪我们，因为大家都有这个困扰，第二个确实是我们的缺点，因为我们要去读取远程表的数据</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807180106519.png" alt="image-20220807180106519"></p>
<h4 id="mysql的binlog"><a href="#mysql的binlog" class="headerlink" title="mysql的binlog"></a>mysql的binlog</h4><p>使用binlog，可以让我们远程访问程序核实正确的时候只需要查询日志，不需要进入表中减缓系统运行速度。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807180304624.png" alt="image-20220807180304624"></p>
<p>一、初步了解binlog</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Presley-lpc/p/9619571.html">mysql binlog详解 - Presley - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>　　1、MySQL的二进制日志binlog可以说是MySQL最重要的日志，它记录了所有的DDL和DML语句（除了数据查询语句select）,以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。</p>
<p>　　　　a、DDL</p>
<p>　　　　　　—-Data Definition Language 数据库定义语言 </p>
<p>　　　　　　主要的命令有create、alter、drop等，ddl主要是用在定义或改变表(table)的结构,数据类型，表之间的连接和约束等初始工作上，他们大多在建表时候使用。</p>
<p>　　　　b、DML</p>
<p>　　　　　　—-Data Manipulation Language 数据操纵语言</p>
<p>　　　　　　主要命令是slect,update,insert,delete,就像它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</p>
<p>　　2、mysqlbinlog常见的选项有一下几个：</p>
<p>　　　　a、–start-datetime：从二进制日志中读取指定等于时间戳或者晚于本地计算机的时间</p>
<p>　　　　b、–stop-datetime：从二进制日志中读取指定小于时间戳或者等于本地计算机的时间 取值和上述一样</p>
<p>　　　　c、–start-position：从二进制日志中读取指定position 事件位置作为开始。</p>
<p>　　　　d、–stop-position：从二进制日志中读取指定position 事件位置作为事件截至</p>
<p>　　3、一般来说开启binlog日志大概会有1%的性能损耗。</p>
<p>　　4、binlog日志有两个最重要的使用场景。</p>
<p>　　　　a、mysql<strong>主从复制</strong>：mysql replication在<strong>master端开启binlog,master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</strong></p>
<p>​                     MySQL之间<strong>数据复制的基础</strong>是<strong>二进制日志文件</strong>（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p>
<p>　　　　<strong>b、数</strong>据恢复**：通过mysqlbinlog工具来恢复数据。</p>
<p>　　　　　　binlog日志包括两类文件：</p>
<p>　　　　　　1)、二进制日志索引文件(文件名后缀为.index)用于记录所有的二进制文件。</p>
<p>　　　　　　2)、二进制日志文件(文件名后缀为.00000*)记录数据库所有的DDL和DML(除了数据查询语句select)语句事件。</p>
<h2 id="十、数据管理子系统"><a href="#十、数据管理子系统" class="headerlink" title="十、数据管理子系统"></a>十、数据管理子系统</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807182011063.png" alt="image-20220807182011063"></p>
<p>数据清理是指：数据没有价值了，需要删除。</p>
<p>数据迁移是指：出于性能与内存的考虑，把价值没这么大的数据移动一个位置。</p>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807182132178.png" alt="image-20220807182132178"></p>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><p>sqlstatement对象一个时间只能执行一条语句是mysql的缺点，别的数据库没有</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220807182349554.png" alt="image-20220807182349554"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理主函数。</span></span><br><span class="line"><span class="keyword">bool</span> _deletetable()&#123;</span><br><span class="line">  CTimer Timer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> tmpvalue[<span class="number">51</span>];    <span class="comment">// 存放从表提取待删除记录的唯一键的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从表提取待删除记录的唯一键。</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmtsel</span><span class="params">(&amp;conn1)</span></span>;</span><br><span class="line">  stmtsel.<span class="built_in">prepare</span>(<span class="string">&quot;select %s from %s %s&quot;</span>,starg.keycol,starg.tname,starg.where);</span><br><span class="line">  stmtsel.<span class="built_in">bindout</span>(<span class="number">1</span>,tmpvalue,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接绑定删除SQL语句where 唯一键 in (...)的字符串。</span></span><br><span class="line">  <span class="keyword">char</span> bindstr[<span class="number">2001</span>];    </span><br><span class="line">  <span class="keyword">char</span> strtemp[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(bindstr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(bindstr));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;MAXPARAMS;ii++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(strtemp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp));</span><br><span class="line">    <span class="built_in">sprintf</span>(strtemp,<span class="string">&quot;:%lu,&quot;</span>,ii+<span class="number">1</span>);       </span><br><span class="line">    <span class="built_in">strcat</span>(bindstr,strtemp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bindstr[<span class="built_in">strlen</span>(bindstr)<span class="number">-1</span>]=<span class="number">0</span>;    <span class="comment">// 最后一个逗号是多余的。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> keyvalues[MAXPARAMS][<span class="number">51</span>];   <span class="comment">// 存放唯一键字段的值。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备删除数据的SQL，一次删除MAXPARAMS条记录。</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmtdel</span><span class="params">(&amp;conn2)</span></span>;</span><br><span class="line">  stmtdel.<span class="built_in">prepare</span>(<span class="string">&quot;delete from %s where %s in (%s)&quot;</span>,starg.tname,starg.keycol,bindstr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;MAXPARAMS;ii++)</span><br><span class="line">    stmtdel.<span class="built_in">bindin</span>(ii+<span class="number">1</span>,keyvalues[ii],<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ccount=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(keyvalues,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(keyvalues));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stmtsel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtsel.execute() failed.\n%s\n%s\n&quot;</span>,stmtsel.m_sql,stmtsel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tmpvalue,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tmpvalue));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果集。</span></span><br><span class="line">    <span class="keyword">if</span> (stmtsel.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(keyvalues[ccount],tmpvalue);</span><br><span class="line">    ccount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每MAXPARAMS条记录执行一次删除语句。</span></span><br><span class="line">    <span class="keyword">if</span> (ccount==MAXPARAMS)&#123;</span><br><span class="line">      <span class="keyword">if</span> (stmtdel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtdel.execute() failed.\n%s\n%s\n&quot;</span>,stmtdel.m_sql,stmtdel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ccount=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(keyvalues,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(keyvalues));</span><br><span class="line">    </span><br><span class="line">      PActive.<span class="built_in">UptATime</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不足MAXPARAMS条记录，再执行一次删除。</span></span><br><span class="line">  <span class="keyword">if</span> (ccount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (stmtdel.<span class="built_in">execute</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmtdel.execute() failed.\n%s\n%s\n&quot;</span>,stmtdel.m_sql,stmtdel.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stmtsel.m_cda.rpc&gt;<span class="number">0</span>) logfile.<span class="built_in">Write</span>(<span class="string">&quot;delete from %s %d rows in %.02fsec.\n&quot;</span>,starg.tname,stmtsel.m_cda.rpc,Timer.<span class="built_in">Elapsed</span>());</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>仅仅只多了中间那个步骤， 再删除以前先备份</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备插入和删除表数据的sql，一次迁移starg.maxcount条记录。</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmtins</span><span class="params">(&amp;conn2)</span></span>;</span><br><span class="line">  stmtins.<span class="built_in">prepare</span>(<span class="string">&quot;insert into %s(%s) select %s from %s where %s in (%s)&quot;</span>,starg.dsttname,TABCOLS.m_allcols,TABCOLS.m_allcols,starg.srctname,starg.keycol,bindstr);</span><br></pre></td></tr></table></figure>



<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220808111708002.png" alt="image-20220808111708002"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220808111939610.png" alt="image-20220808111939610"></p>
<p>这个每批次的数量会根据情况改变，例如，如果迁移表中有BLOB字段，那么每批迁移数就不能太多，因为BLOB字段占用的空间可能会很大。如果有可能会出现唯一键冲突，那么会导致一批次都迁移失败，所以有的时候会考虑一批只传送一个数据，出错了就不理他，写日志继续迁移其他的记录。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220808112140210.png" alt="image-20220808112140210"></p>
<h2 id="十一、Oracle数据库开发"><a href="#十一、Oracle数据库开发" class="headerlink" title="十一、Oracle数据库开发"></a>十一、Oracle数据库开发</h2><blockquote>
<p>Oracle用户的DBA登录sqlplus / as sysdba</p>
</blockquote>
<blockquote>
<p>用oracle用户登录，执行<code>lsnrctl start</code>启动网络监听服务，执行<code>dbstart</code>启动数据库系统。</p>
<p>用oracle用户登录，执行<code>lsnrctl stop</code>关闭网络监听服务，执行<code>dbshut</code>关闭数据库系统。</p>
</blockquote>
<p>配置数据库地址</p>
<blockquote>
<p>vi /oracle/home/network/admin/tnsnames.ora  </p>
</blockquote>
<p>oci头文件</p>
<blockquote>
<p>$ORACLE_HOME/rdbms/public</p>
</blockquote>
<h3 id="mysql和oracle的区别"><a href="#mysql和oracle的区别" class="headerlink" title="mysql和oracle的区别"></a>mysql和oracle的区别</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>其他区别：用到时，网上自行查找工具就行了</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815170446435.png" alt="image-20220815170446435"></p>
<p>​        MySQL可以称为数据库服务，在一个服务中，可以创建多个数据库，在多个数据库中再创建表，索引，视图等对象。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815170555370.png" alt="image-20220815170555370"></p>
<p>​        Oracle不用数据库这个名词，用实例，在一个实例中可以创建多个用户，在用户中再创建表，索引，视图等对象</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815170755629.png" alt="image-20220815170755629"></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815171117415.png" alt="image-20220815171117415"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815171131130.png" alt="image-20220815171131130"></p>
<p>MySQL中自增字段只有一个，并且还需要设置为唯一键，Oracle没有这个限制，一个表可以有多个自增字段，甚至没有自增字段，可以采用<code>序列生成器</code>，Oracle也不要求把自增字段设置为唯一键，但我们一般也会设置。</p>
<h3 id="Oracle开发基础"><a href="#Oracle开发基础" class="headerlink" title="Oracle开发基础"></a>Oracle开发基础</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815194029387.png" alt="image-20220815194029387"></p>
<p>connection和sqlstatement基本上和mysql没啥区别。</p>
<p>错误代码也是一一对应就是了不需要记忆</p>
<p>但是注意事项。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815194122451.png" alt="image-20220815194122451"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220815194239284.png" alt="image-20220815194239284"></p>
<h3 id="Oracle故障排除的方法"><a href="#Oracle故障排除的方法" class="headerlink" title="Oracle故障排除的方法"></a>Oracle故障排除的方法</h3><p>​        如果对方服务器没有启动，网络不通，没有开通防火墙，会提示<code>无法连接目标主机</code>，如果对方程序已经启动，并且开启了防火墙，那么就会提示<code>无监听程序</code>，也就是说对方的监听服务没有启动。</p>
<p>​        如果可以telnet xxx.xxx.xxx.xxx port(1521)  说明网络没问题，防火墙也没问题，这个时候如果提示<code>监听程序当前无法识别连接描述符所给出的SID</code>, 也就是说你想连接的数据库还没有启动，用dbstart启动。如果这样还不行，说明数据库的SID设置那里出错了，指定的SID根本就不存在</p>
<h3 id="用户和权限管理基本知识"><a href="#用户和权限管理基本知识" class="headerlink" title="用户和权限管理基本知识"></a>用户和权限管理基本知识</h3><blockquote>
<p>J:\11Projectc++\课程文档(1)\oracle数据库\28.Oracle用户和权限管理.docx</p>
</blockquote>
<h3 id="序列生成器基本知识"><a href="#序列生成器基本知识" class="headerlink" title="序列生成器基本知识"></a>序列生成器基本知识</h3><blockquote>
<p>J:\11Projectc++\课程文档(1)\oracle数据库\11.Oracle序列生成器.docx</p>
</blockquote>
<h3 id="Oracle双引号单引号"><a href="#Oracle双引号单引号" class="headerlink" title="Oracle双引号单引号"></a>Oracle双引号单引号</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Ninewind/article/details/89816284">(18条消息) Oracle数据库中单引号’ ‘ 和双引号” “的区别_Ninewind的博客-CSDN博客_数据库中单引号是什么意思</a></p>
</blockquote>
<p>呜呜呜呜呜呜，利用PowerDesigner造表的时候一定要注意，引号要去掉啊！！！！这点差点把我干碎！</p>
<p>在Oracle数据库中,单引号’ ‘和双引号” “两者都是可以表示字符串的，但是在使用时会有所区别。</p>
<p>在双引号” “中，一般在如下场合使用</p>
<ol>
<li>表示其内部的字符串严格区分大小写  （比如用作字段别名时区分大小写）</li>
<li>用于特殊字符或关键字  （比如包含空格，#或&amp;时）</li>
<li>不受标识符规则限制</li>
<li>会被当成一个列来处理</li>
<li>当出现在to_char的格式字符串中时，双引号有特殊的作用，就是将非法的格式符包装起</li>
</ol>
<p>而在单引号’ ‘中,一般在如下场合使用</p>
<ol>
<li>表示字符串常量  （比如用于条件限定时where=’aa’，单引号用于条件限定时对大小写敏感）</li>
<li>字符串中的双引号仅仅当作一个字符串”处理，可以在单引号’ ‘中使用双引号”</li>
<li>如果字符串常量中包含了单引号’ ‘，那么需要使用两个单引号 ‘’ 表示一个单引号常量</li>
</ol>
<h3 id="数据入库子系统修改"><a href="#数据入库子系统修改" class="headerlink" title="数据入库子系统修改"></a>数据入库子系统修改</h3><p>从MySQL的版本改过来大致这样。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220817195154604.png" alt="image-20220817195154604"></p>
<p>这个错误代码应该熟记（mysql是1062）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220817195329586.png" alt="image-20220817195329586"></p>
<p>MYSQL版本，keyid字段无需处理，Oracle版本，keyid需要处理，upttime仍然不需要。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220817195543233.png" alt="image-20220817195543233"></p>
<p>在我们这个项目有个约定，序列名和表名除了前缀，其他是一样的，所以我们可以用<code>SEQ_序列名</code>的方式来得到序列名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// keyid字段需要特殊处理。</span></span><br><span class="line"><span class="comment">// 最下面的colseq是sql语句绑定参数的计数器，由于SEQ语句并不需要，所以要从if语句的外面，加入else里面。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[ii].colname,<span class="string">&quot;keyid&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot;SEQ_%s.nextval&quot;</span>,stxmltotable.tname+<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">strcmp</span>(TABCOLS.m_vallcols[ii].datatype,<span class="string">&quot;date&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot;:%d&quot;</span>,colseq);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">SNPRINTF</span>(strtemp,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp),<span class="string">&quot;to_date(:%d,&#x27;yyyymmddhh24miss&#x27;)&quot;</span>,colseq);</span><br><span class="line"></span><br><span class="line">     colseq++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>时间格式修改：</p>
<p>将mysql这种讨厌的格式<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220817200324931.png" alt="image-20220817200324931"></p>
<p>改为这样的格式：<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220817200356218.png" alt="image-20220817200356218"></p>
<p>另外就是SQL语句中的<code>now()</code>改为<code>sysdate</code>，Oracle没有now()</p>
<h3 id="数据清理子系统修改"><a href="#数据清理子系统修改" class="headerlink" title="数据清理子系统修改"></a>数据清理子系统修改</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818140437935.png" alt="image-20220818140437935"></p>
<p>​        数据清理不用考虑2、3、4三个问题，不过需要注意还有更多需要修改的地方。</p>
<p>​        就比如mysql需要为每一种操作都创造一个数据库连接，否则会串线，Oracle就可以兼容，实现一个对象操纵多种命令。</p>
<p>​        Oracle不需要MAXPARMS这个宏，我们直接定义就好了。</p>
<p>我们直接使用，这样的效率不是最高的，为什么这么说</p>
<blockquote>
<p>J:\11Projectc++\课程文档(1)\oracle数据库\17.Oracle伪列.docx</p>
<p>可以看看Oracle的伪列，非常重要</p>
</blockquote>
<p>​        我们只需要将查找的条件keycol中的<code>keyid</code>替换为<code>rowid</code>就行，rowid是直接记录了这条记录在硬盘里的物理位置，肯定比任何索引都来的快，不过他是oracle所特有，用在别的数据库会有兼容问题，并且rowid不是固定的，会随着资源的移动而发生变化。</p>
<h3 id="数据迁移子系统修改"><a href="#数据迁移子系统修改" class="headerlink" title="数据迁移子系统修改"></a>数据迁移子系统修改</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818144341798.png" alt="image-20220818144341798"></p>
<h3 id="数据抽取子系统修改"><a href="#数据抽取子系统修改" class="headerlink" title="数据抽取子系统修改"></a>数据抽取子系统修改</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818153244601.png" alt="image-20220818153244601"></p>
<p>​        如果Mysql语句有语法错误，prepare会返回错误提示，但是oracle不会。</p>
<p>​        为了程序兼容性考虑，不要去判断prepare的返回值，错误代码943那行语句不能放在执行之前，应该在执行之后判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(starg.connstr1)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 把自增字段的最大值写入数据库的表。</span></span><br><span class="line">  <span class="comment">// create table T_MAXINCVALUE(pname varchar(50),maxincvalue numeric(15),primary key(pname));</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn1)</span></span>;</span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;update T_MAXINCVALUE set maxincvalue=:1 where pname=:2&quot;</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,&amp;imaxincvalue);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,starg.pname,<span class="number">50</span>);</span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">execute</span>()!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt.m_cda.rc==<span class="number">942</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果表不存在，就创建表。</span></span><br><span class="line">      conn1.<span class="built_in">execute</span>(<span class="string">&quot;create table T_MAXINCVALUE(pname varchar2(50),maxincvalue number(15),primary key(pname))&quot;</span>);</span><br><span class="line">      conn1.<span class="built_in">execute</span>(<span class="string">&quot;insert into T_MAXINCVALUE values(&#x27;%s&#x27;,%ld)&quot;</span>,starg.pname,imaxincvalue);</span><br><span class="line">      conn1.<span class="built_in">commit</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;stmt.execute() failed.\n%s\n%s\n&quot;</span>,stmt.m_sql,stmt.m_cda.message); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="数据同步子系统修改"><a href="#数据同步子系统修改" class="headerlink" title="数据同步子系统修改"></a>数据同步子系统修改</h3><p>Oracle并没有federated引擎，但是有更强大的DBlink，关于它的使用可以看这篇文章。</p>
<blockquote>
<p>J:\11Projectc++\课程文档(1)\oracle数据库\20.Oracle数据库链路.docx</p>
</blockquote>
<p>​        数据库链路（database link），简称dblink，它是一个通道，是本地数据库与远程数据库之间的通道，通过dblink，在本地数据库中可以直接访问远程数据库的对象。</p>
<p>dblink不是应用程序与数据库之间的通道，而是数据库之间的通道</p>
<p><strong>应用经验</strong></p>
<p>​        dblink的知识很容易掌握，用dblink访问远程数据库的对象很方便，但是，如果在程序中采用dblink对远程数据库的表进行增、删、改、查操作时一定要遵守一个原则：<strong>尽可能不要产生远程事务，因为数据库对远程的事务难以控制</strong>，也就是说，尽可能不要对远程数据库的表进行增、删、改操作，查询是没有问题的。</p>
<p>先创建dblink</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqlplus <span class="operator">/</span> <span class="keyword">as</span> sysdba</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">create</span> database link <span class="keyword">to</span> qxidc;</span><br><span class="line">#<span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">create</span> database link <span class="keyword">to</span> scott;</span><br><span class="line"># 原本应该给远程服务器的这个授权权限</span><br><span class="line">授权成功。</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> exit;</span><br><span class="line">sqlplus scott<span class="operator">/</span>tiger</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">create</span> database link db128 <span class="keyword">connect</span> <span class="keyword">to</span> qxidc identified <span class="keyword">by</span> qxidcpwd <span class="keyword">using</span> <span class="string">&#x27;snorcl11g_128&#x27;</span>;</span><br><span class="line"></span><br><span class="line">数据库链接已创建。</span><br></pre></td></tr></table></figure>

<p>​        通过dblink访问远程数据库的权限是由dblink所采用的用户决定的，就像你拿着别人的员工卡进入公司大楼一样。</p>
<p>就比如qxidc用户没有访问这个表的权限，提示视图不存在，其实是他无法看到而已。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818174233287.png" alt="image-20220818174233287"></p>
<p>另外一台虚拟机上用dblink访问也是一样的意思</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818174330829.png" alt="image-20220818174330829"></p>
<p>syncupdate_oracle.cpp、syncincrement_oracle.cpp解决方案，仅需要修改这两处</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXPARAMS 256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、程序的帮助；</span></span><br><span class="line"><span class="comment">6、oracle不需要MAXPARAMS宏。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        对于syncincrementex_oracle.cpp而言，存在MAXPARAMS宏的问题，这个程序取出远程表的数据放入内存中，再插入本地表，需要绑定输入和输出变量，只要绑定变量，肯定会涉及到<strong>绑定参数个数最大值</strong>的问题，不过这个问题，也只是对mysql版本，因为oracle封装的方法，无需限制有多大，可以不需要这个宏。</p>
<p>​        第二个问题，在绑定语句中，如果有时间字段，需要在程序中先转化为字符串，插入本地表的时候，再用to_date将字符串转化为时间，这样是很麻烦的，一种解决方法是数据库的时间缺省方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># oracle用户状态下命令行输入</span></span><br><span class="line"><span class="built_in">export</span> NLS_DATE_FORMAT=<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818194143527.png" alt="image-20220818194143527"></p>
<p>我们来做一个测试：采用DBlink和不采用DBlink的增量同步程序</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818211333238.png" alt="image-20220818211333238"></p>
<p>这是Dblink的程序maxcount采用1、10、100的情况</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818211524213.png" alt="image-20220818211524213"></p>
<p>因此我们得出结论，Dblink和批量处理的效率是非常高的，比FEDERATED的效率要高得多。</p>
<h3 id="数据库集群方案"><a href="#数据库集群方案" class="headerlink" title="数据库集群方案"></a>数据库集群方案</h3><p>​        作为一个能搭建数据中心的程序员，数据库集群是避不开的问题，我们作为程序员，需要了解概念和原理，不需要动手实践。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818211930613.png" alt="image-20220818211930613"></p>
<h4 id="RAC"><a href="#RAC" class="headerlink" title="RAC"></a>RAC</h4><p>​        每个结点都安装了oracle数据库和操作系统，他们共享存储，共享存储有容错机制，稳定性比服务器都要好很多，也很贵，如果一般结点坏了，不影响系统工作，共享存储坏了就玩完了。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818212058390.png" alt="image-20220818212058390"></p>
<p>​        上面是单实例的数据库，服务器发生故障的时候，客户端的connection会断开，但是对于RAC集群来说，他能使得并列的服务端，接管错误的那个服务端的connection，保证了持续连接，对应用程序来说是没有感觉的，业务也不会受到影响。RAC是<strong>高可用</strong>的解决方案，不是高性能的解决方案，他能保持服务器永远在线(足够多结点)，但是对性能没有提升，因为RAC共享一个存储设备，存储设备的性能决定了整体性能。</p>
<p>​        虽然只有一份文件，不能提高读写效率，但是却有办法提高查询效率，因为每个结点都有可能能保存账本的信息，直接反馈给客户端。这种处理方法对某些行业非常重要，比如说银行，证券，便利等行业，还有政府部门。它的代价也显而易见，烧硬件。<strong>IBM3850</strong>是一个最好的选择，一般来说5w块钱的就可以了。如果觉得这个不够好，可以试试IBM小型机。用它的分区就可以了，每个分区相当于一台独立的服务器。</p>
<p>​        软件方面也特别的昂贵，这么说吧，搭建一个RAC要100w，RAC的服务端可以搭建很多，但实际中一般两个就够了，再多也没啥太大的意义。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220818212229709.png" alt="image-20220818212229709"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819155332258.png" alt="image-20220819155332258"></p>
<p>​        RAC把数据写入共享内存时，多个节点之间需要协调，所以写速度低一些，不如单实例的数据库，读就因为都有备份，所以快一些。MYSQL也有RAC的功能，但是很脆弱，在几十万的硬件上运行MYSQL也会让人难以理解。</p>
<h4 id="Data-Guard"><a href="#Data-Guard" class="headerlink" title="Data Guard"></a>Data Guard</h4><p>​        Data Guard是Oracle自带的集群方案，类似于MySQL的主从复制，只不过这里是Primary site的数据，定期保存到Standby site，对应MySQL的master slave。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819155449059.png" alt="image-20220819155449059"></p>
<blockquote>
<p> Data Guard的，primary写，standby读，是可以做的，但这样也显得有些笨，Oracle有更好的办法</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819155651435.png" alt="image-20220819155651435"></p>
<h4 id="OGG"><a href="#OGG" class="headerlink" title="OGG"></a>OGG</h4><p>​        OGG主要有三个进程，源端的数据抽取进程，网络的文件传输进程，目标端的数据复制进程。最慢的地方就是将解析的数据插入目标端这个步骤，插入需要一点点来，确实是没办法的事情。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819155931506.png" alt="image-20220819155931506"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819160105313.png" alt="image-20220819160105313"></p>
<h5 id="OGG-vs-数据同步子系统"><a href="#OGG-vs-数据同步子系统" class="headerlink" title="OGG vs 数据同步子系统"></a>OGG vs 数据同步子系统</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819160213220.png" alt="image-20220819160213220"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819160329794.png" alt="image-20220819160329794"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819160435745.png" alt="image-20220819160435745"></p>
<h4 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h4><p>有可能面试会被问到。</p>
<p>存储设备又叫存储服务器，它的容量一般都很大，具体看业务需求，EMC是专门做这个的公司，比IBM做得要好</p>
<p>IBM3850+EMC是一个方案，IBM P750小型机分成四个区也是一个方案，一个区的性能比IBM3850还要好。如果用的是小型机，操作系统肯定是AIX，是UNIX的一种。</p>
<p>​        备份的服务器(Standby)不用太好，3650都可以，价格在2w多，内存也不用大，64G足够。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819160601955.png" alt="image-20220819160601955"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819160824332.png" alt="image-20220819160824332"></p>
<blockquote>
<p>一个槽可以挂一个硬盘。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819161056092.png" alt="image-20220819161056092"></p>
<h3 id="Oracle-DBA"><a href="#Oracle-DBA" class="headerlink" title="Oracle DBA"></a>Oracle DBA</h3><p>​        这是一个专门的岗位</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819161222325.png" alt="image-20220819161222325"></p>
<h3 id="Oracle新特性"><a href="#Oracle新特性" class="headerlink" title="Oracle新特性"></a>Oracle新特性</h3><p>​        inmemory不能提升写数据的性能，但是能提升读数据（几十倍）。Oracle12才有的</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819161555762.png" alt="image-20220819161555762"></p>
<p>​        可能我们以后会见到这个框架，但如果有Oracle就不需要这么做了，新版本的Oracle自带这个功能，不再需要redis做缓存，使用起来也更方便。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819161702895.png" alt="image-20220819161702895"></p>
<p><strong>区块链相关知识</strong></p>
<p>等等等等……………….</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819161813047.png" alt="image-20220819161813047"></p>
<h3 id="MySQL何去何从"><a href="#MySQL何去何从" class="headerlink" title="MySQL何去何从"></a>MySQL何去何从</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819161908960.png" alt="image-20220819161908960"></p>
<h3 id="PostgreSQL及更多"><a href="#PostgreSQL及更多" class="headerlink" title="PostgreSQL及更多"></a>PostgreSQL及更多</h3><p>它的性能比mysql强大的多，但因为没人维护，所以没人敢用</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819162005197.png" alt="image-20220819162005197"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819162143370.png" alt="image-20220819162143370"></p>
<h2 id="十二、linux线程"><a href="#十二、linux线程" class="headerlink" title="十二、linux线程"></a>十二、linux线程</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>​        对程序员来说，调用进程和调用线程的代码不一样。但是，操作系统底层，都是调用同一个类层函数<code>clone</code>，把进程复制一份。对类和函数来说，如果创建的是进程，还需要复制地址空间，如果创建的是线程，就不复制地址空间，让他和原来的进程共享地址空间。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810111255803.png" alt="image-20220810111255803"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810141330592.png" alt="image-20220810141330592"></p>
<blockquote>
<p>注意：所谓的多线程都是指同一个进程下的多个线程。</p>
</blockquote>
<h4 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810141532248.png" alt="image-20220810141532248"></p>
<h3 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810141622111.png" alt="image-20220810141622111"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810141652324.png" alt="image-20220810141652324"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810141721239.png" alt="image-20220810141721239"></p>
<h3 id="创建简单线程"><a href="#创建简单线程" class="headerlink" title="创建简单线程"></a>创建简单线程</h3><blockquote>
<p>提前说明，在这里我们把main函数叫做主线程，或者主进程。被创建的线程叫做线程或者子线程，子线程运行的函数叫线程主函数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Test01.cpp</span></span><br><span class="line"><span class="comment">// 本程序演示线程的创建</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程主函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid = <span class="number">0</span>;     <span class="comment">// 线程id typedef unsigned long pthread_t</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;thid, <span class="literal">NULL</span>, thmain, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 一般失败只有操作系统有问题或者创建的线程太多了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子线程的退出。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(thid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;     <span class="comment">// 线程主函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthmain sleep(%d) ok.\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要查看进程运行，先查看进程编号这里就是：<code>ps -ef |grep Test01</code></p>
<p>找到<code>./test01</code>使用<code>ps -Lf 19526</code>来查看，上面那个的LWP和PID一样，所以他是主线程，下面那个是子线程</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810145536477.png" alt="image-20220810145536477"></p>
<p>在多线程程序中，他们的LWP（PCB）是不同的，但是他们的地址空间是一样的</p>
<h3 id="线程非正常终止"><a href="#线程非正常终止" class="headerlink" title="线程非正常终止"></a>线程非正常终止</h3><p>在多线程中，切记主线程不能退出，因为他们同处一室，如果他提前退出了，子线程没有机会把该干的事干完，如果主线程实在没事干，可以就在主线程中join()等待子线程结束</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810150139060.png" alt="image-20220810150139060"></p>
<p>对于第三种情况，想要表达的重点是：</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810150903002.png" alt="image-20220810150903002"></p>
<h4 id="Core-dump"><a href="#Core-dump" class="headerlink" title="Core dump"></a>Core dump</h4><p>​        当程序运行的过程中<strong>异常终止或崩溃</strong>，<strong>操作系统会将程序当时的内存状态记录下来</strong>，<strong>保存在</strong>一个<strong>文件</strong>中，这种<strong>行为</strong>就叫做Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。</p>
<h3 id="终止线程的三种办法"><a href="#终止线程的三种办法" class="headerlink" title="终止线程的三种办法"></a>终止线程的三种办法</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151416365.png" alt="image-20220810151416365"></p>
<p>return 0 代表的是NULL，本身就是地址，所以return 0可以直接写，return别的需要转换为void *地址</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151441269.png" alt="image-20220810151441269"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151551077.png" alt="image-20220810151551077"></p>
<blockquote>
<p>任意一个线程都可以。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151542016.png" alt="image-20220810151542016"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151627285.png" alt="image-20220810151627285"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151721073.png" alt="image-20220810151721073"></p>
<blockquote>
<p>exit里面放的值效果和return一样，如果不是写0，范回别的都需要提前转变量类型</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151804043.png" alt="image-20220810151804043"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810151820279.png" alt="image-20220810151820279"></p>
<p>既然这样，那么第一种和第三种方法又有什么区别呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain1</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    var=ii+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;pthmain1 sleep(%d) ok.\n&quot;</span>,var);</span><br><span class="line">    <span class="keyword">if</span> (ii==<span class="number">2</span>) <span class="built_in">fun1</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">pthread_exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain2</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">5</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;pthmain2 sleep(%d) ok.\n&quot;</span>,var);</span><br><span class="line">    <span class="keyword">if</span> (ii==<span class="number">2</span>) <span class="built_in">fun2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        答案便是，如果在子线程中，exit能终止这个线程，return只会又范回这个线程，这个一般程序的exit(0)与return 0一样的道理。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810152249851.png" alt="image-20220810152249851"></p>
<h3 id="线程参数的传递"><a href="#线程参数的传递" class="headerlink" title="线程参数的传递"></a>线程参数的传递</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810152404084.png" alt="image-20220810152404084"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810152423987.png" alt="image-20220810152423987"></p>
<p>对于第一个问题：</p>
<p>为什么会出现的原因，可以归结于，先创建的线程不一定先运行。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810154100990.png" alt="image-20220810154100990"></p>
<p>我们可以考虑采用sleep来使得结果不再紊乱</p>
<p><strong><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810154158098.png" alt="image-20220810154158098"></strong></p>
<p>但是实际开发中，不可能采用sleep这种方法，会被别人笑话。TAT</p>
<p>正确的方法是，创建线程的时候，把create的第四个参数传递给线程主函数。</p>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>​        在下图中，前四行是用本来存放地址的pv存放了ii的值，也就是pv输出即0xa(10)。后三行是用本来存放数字的jj存放地址的值，并且由于指针占用内存空间八字节，所以不允许直接转换为int，编译器只允许小转大，对此我们可以采用先转化为long，再转化为int的方法处理。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810155005836.png" alt="image-20220810155005836"></p>
<p>​        在日常开发中一般不会使用，但是在多线程中却常常使用。</p>
<p>​        注意品位下面的强制转换。我们传入的不是地址，而是整数类型值的地址，也就是类似于0x1,0x2这种，如果直接传var的地址，如果直接通过参数传入是不正确的，本质上和全局变量var别无二致。</p>
<p>​        这个程序类似于已经完成了前四个目标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程参数的传递（用强制转换的方法传变量的值）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程1的主函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程2的主函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain3</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程3的主函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain4</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程4的主函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain5</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程5的主函数。</span></span><br><span class="line"><span class="keyword">int</span> var;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> thid1=<span class="number">0</span>,thid2=<span class="number">0</span>,thid3=<span class="number">0</span>,thid4=<span class="number">0</span>,thid5=<span class="number">0</span>;   <span class="comment">// 线程id typedef unsigned long pthread_t</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  var=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain1,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)var)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  var=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain2,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)var)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  var=<span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid3,<span class="literal">NULL</span>,thmain3,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)var)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  var=<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid4,<span class="literal">NULL</span>,thmain4,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)var)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  var=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid5,<span class="literal">NULL</span>,thmain5,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)var)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid1,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid2,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid3,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid4,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid5,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain1</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var1=%d\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线程1开始运行。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain2</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var2=%d\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线程2开始运行。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain3</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var3=%d\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线程3开始运行。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain4</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var4=%d\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线程4开始运行。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain5</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var5=%d\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线程5开始运行。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何正确传递地址参数"><a href="#如何正确传递地址参数" class="headerlink" title="如何正确传递地址参数"></a>如何正确传递地址参数</h4><p>如果要给线程传地址，一定要保证给每一个线程传不同的地址，而不能都传同一个地址。</p>
<p>并且要注意，如果我们新创建了很多的内存空间，那么一定要在子函数中把这块区域关闭。如果在主函数关闭，那就和在主函数关闭程序一个道理，根本无法判断子函数是否执行完！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程。</span></span><br><span class="line"><span class="keyword">int</span> *var1=<span class="keyword">new</span> <span class="keyword">int</span>; *var1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain1,var1)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *var2=<span class="keyword">new</span> <span class="keyword">int</span>; *var2=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain2,var2)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *var3=<span class="keyword">new</span> <span class="keyword">int</span>; *var3=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid3,<span class="literal">NULL</span>,thmain3,var3)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *var4=<span class="keyword">new</span> <span class="keyword">int</span>; *var4=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid4,<span class="literal">NULL</span>,thmain4,var4)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *var5=<span class="keyword">new</span> <span class="keyword">int</span>; *var5=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid5,<span class="literal">NULL</span>,thmain5,var5)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br></pre></td></tr></table></figure>

<h4 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h4><p>线程的参数，如果传值，只能传一个，如果传地址，传入一个包含多个参数的结构体的地址，那就没问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程参数的传递（用结构体的地址传递多个参数）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程的主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>  no;        <span class="comment">// 线程编号。</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">51</span>];  <span class="comment">// 线程名。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> thid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_args</span> *<span class="title">stargs</span>=</span><span class="keyword">new</span> struct st_args;</span><br><span class="line">  stargs-&gt;no=<span class="number">15</span>;   <span class="built_in">strcpy</span>(stargs-&gt;name,<span class="string">&quot;测试线程&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid,<span class="literal">NULL</span>,thmain,stargs)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_args</span> *<span class="title">pst</span>=</span>(struct st_args *)arg;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;no=%d,name=%s\n&quot;</span>,pst-&gt;no,pst-&gt;name);</span><br><span class="line">  <span class="keyword">delete</span> pst;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线程开始运行。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程退出状态"><a href="#线程退出状态" class="headerlink" title="线程退出状态"></a>线程退出状态</h4><p>实际开发中其实我们往往不关心这个，但是作为学习我们也必须了解，通常子线程的退出就是伴随着join函数的终止。我们先一起来了解一下join函数</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810162132666.png" alt="image-20220810162132666"></p>
<p>join函数的第二个变量是一个二级指针，也就是<code>指针变量的地址</code>。还记得我们的thmain函数返回值类型是void *吗？这个就是指，指向这个类型的指针。也就是能取得返回值地址的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程线程退出（终止）的状态。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程的主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_ret</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>  retcode;          <span class="comment">// 返回代码。</span></span><br><span class="line">  <span class="keyword">char</span> message[<span class="number">1024</span>];    <span class="comment">// 返回内容。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> thid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_ret</span> *<span class="title">pst</span>=</span><span class="number">0</span>;</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid,(<span class="keyword">void</span> **)&amp;pst);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;retcode=%d,message=%s\n&quot;</span>,pst-&gt;retcode,pst-&gt;message);</span><br><span class="line">  <span class="keyword">delete</span> pst;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线程开始运行。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，如果用结构体的地址作为线程的返回值，必须保存在线程主函数结束后地址仍是有效的。</span></span><br><span class="line">  <span class="comment">// 所以，要采用动态分配内存的方法，不能用局部变量。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_ret</span> *<span class="title">ret</span>=</span><span class="keyword">new</span> struct st_ret;</span><br><span class="line">  ret-&gt;retcode=<span class="number">1121</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(ret-&gt;message,<span class="string">&quot;测试内容。&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_exit</span>((<span class="keyword">void</span> *)ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程资源的回收"><a href="#线程资源的回收" class="headerlink" title="线程资源的回收"></a>线程资源的回收</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810165846123.png" alt="image-20220810165846123"></p>
<p>先来复习复习进程资源的回收</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810165959212.png" alt="image-20220810165959212"></p>
<h4 id="线程未分离"><a href="#线程未分离" class="headerlink" title="线程未分离"></a>线程未分离</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810170129829.png" alt="image-20220810170129829"></p>
<p>​        我们先让它sleep10s，也就是子线程都执行完以后再join</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain1,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain2,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">void</span> *ret;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">  result=<span class="built_in">pthread_join</span>(thid2,&amp;ret);   <span class="built_in">printf</span>(<span class="string">&quot;thid2 result=%d,ret=%ld\n&quot;</span>,result,ret);</span><br><span class="line">  result=<span class="built_in">pthread_join</span>(thid1,&amp;ret);   <span class="built_in">printf</span>(<span class="string">&quot;thid1 result=%d,ret=%ld\n&quot;</span>,result,ret);</span><br><span class="line">  ret=<span class="number">0</span>;</span><br><span class="line">  result=<span class="built_in">pthread_join</span>(thid2,&amp;ret);   <span class="built_in">printf</span>(<span class="string">&quot;thid2 result=%d,ret=%ld\n&quot;</span>,result,ret);</span><br><span class="line">  result=<span class="built_in">pthread_join</span>(thid1,&amp;ret);   <span class="built_in">printf</span>(<span class="string">&quot;thid1 result=%d,ret=%ld\n&quot;</span>,result,ret);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​        可以发现，函数仍然能捕捉到ret，也就是证明了资源并没完全退出，和租房子的确也是一个道理，但是第二次join就不行了，类似于第一次join就把子函数赶走了。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810170635392.png" alt="image-20220810170635392"></p>
<h4 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h4><p>主要用这两种方法分离。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810170818476.png" alt="image-20220810170818476"></p>
<h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h5><p>只有一个参数，就把线程名输进去就可以了，大概意思就是指，用了这个不需要用join回收了，并且只有返回值为0即函数执行成功。</p>
<p>这个函数可以放在主函数中（需要留给足够的时间让子进程执行完）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810171006764.png" alt="image-20220810171006764"></p>
<p>也可以放在线程的主函数中，这个时候用<code>pthread_self()</code>得到自己的ID</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810171411379.png" alt="image-20220810171411379"></p>
<p>实际开发中更倾向于放在线程主函数中，因为更简单。</p>
<h5 id="设置线程属性"><a href="#设置线程属性" class="headerlink" title="设置线程属性"></a>设置线程属性</h5><p>太麻烦了，所以基本不用</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810171606994.png" alt="image-20220810171606994"></p>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>​        偶尔也会用到。tryjoin和join用法一样，不过，如果子线程没有终止，他不会等待，他立即返回。下面那个就是限制多久没终止，就返回。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810171706281.png" alt="image-20220810171706281"></p>
<h4 id="线程清理函数"><a href="#线程清理函数" class="headerlink" title="线程清理函数"></a>线程清理函数</h4><p><strong>入栈和出站必须成对出现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pthread_cleanup_push</span>(thcleanup1,<span class="literal">NULL</span>);  <span class="comment">// 把线程清理函数1入栈（关闭文件指针）。</span></span><br><span class="line">  <span class="built_in">pthread_cleanup_push</span>(thcleanup2,<span class="literal">NULL</span>);  <span class="comment">// 把线程清理函数2入栈（关闭socket）。</span></span><br><span class="line">  <span class="built_in">pthread_cleanup_push</span>(thcleanup3,<span class="literal">NULL</span>);  <span class="comment">// 把线程清理函数3入栈（回滚数据库事务）。 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">3</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;pthmain sleep(%d) ok.\n&quot;</span>,ii+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cleanup_pop</span>(<span class="number">3</span>);  <span class="comment">// 把线程清理函数3出栈。</span></span><br><span class="line">  <span class="built_in">pthread_cleanup_pop</span>(<span class="number">2</span>);  <span class="comment">// 把线程清理函数2出栈。</span></span><br><span class="line">  <span class="built_in">pthread_cleanup_pop</span>(<span class="number">1</span>);  <span class="comment">// 把线程清理函数1出栈。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在thcleanup1,2,3中释放资源。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810172619601.png" alt="image-20220810172619601"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810172714371.png" alt="image-20220810172714371"></p>
<p>只要清理函数已经入栈了，那么肯定会执行。</p>
<p>​        现在我们来研究一下这个清理函数的参数</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810172845514.png" alt="image-20220810172845514"></p>
<p><code>execute</code>的取值如果为0，表示让这个函数出栈，并且不执行，反之传入别的任意值，都是执行</p>
<h4 id="进程终止函数"><a href="#进程终止函数" class="headerlink" title="进程终止函数"></a>进程终止函数</h4><p><strong>声明</strong></p>
<p>下面是 atexit() 函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int atexit(void (*func)(void))</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><strong>func</strong> – 在程序终止时被调用的函数。</li>
</ul>
<p><strong>返回值</strong></p>
<p>如果函数成功注册，则该函数返回零，否则返回一个非零值。</p>
<p><strong>实例</strong></p>
<p>下面的实例演示了 atexit() 函数的用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;这是函数A\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 注册终止函数 */</span></span><br><span class="line">   <span class="built_in">atexit</span>(functionA );</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;启动主程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;退出主程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们编译并运行上面的程序，这将产生以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动主程序...</span><br><span class="line">退出主程序...</span><br><span class="line">这是函数A</span><br></pre></td></tr></table></figure>

<h4 id="线程的取消"><a href="#线程的取消" class="headerlink" title="线程的取消"></a>线程的取消</h4><blockquote>
<p> 取消不意味着终止，只是取消这次执行操作，线程并未结束。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810173538612.png" alt="image-20220810173538612"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810173606506.png" alt="image-20220810173606506"></p>
<p>使用方法很简单。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810175852388.png" alt="image-20220810175852388"></p>
<p>对于取消状态而言，其实没啥用，因为只有取消和不取消两种选择，缺省是取消，所以不用管它</p>
<p>另外，我们还可以设置线程的取消方式</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810175933056.png" alt="image-20220810175933056"></p>
<p>DEFERRED是延迟取消，就你指定多久之后取消，可以理解为，你告诉它你该取消了，它说它知道了，但是他要运行到下一个能取消的地方才取消。ASYNCHRONOUS是立即取消（异步好诶）线程在任何时候都可以被取消</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810180134033.png" alt="image-20220810180134033"></p>
<p>​        那么什么是取消点呢？我们来看看帮助文档（<code>man 7 pthreads</code>）后按/points搜索定位</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810180653639.png" alt="image-20220810180653639"></p>
<p>只要线程的代码中出现了这一堆（未显示完）函数，则叫做取消点</p>
<p>在实际开发中，如果线程中的代码没有取消点，那我们可以调用下面这个函数设置取消点，这是规范的做法。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810180803738.png" alt="image-20220810180803738"></p>
<p>应该这样</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810180857741.png" alt="image-20220810180857741"></p>
<h3 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h3><p>不管是进程还是线程，信号都比较复杂，可对于我们的开发而言，这个东西需要掌握的知识是比较简单的。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810181012666.png" alt="image-20220810181012666"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810181545465.png" alt="image-20220810181545465"></p>
<blockquote>
<p>对于信号的执行，如果对同一个信号有多个执行函数，那么我们以<strong>最后被执行的那串代码</strong>为准。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810181900990.png" alt="image-20220810181900990"></p>
<h4 id="进程送达函数"><a href="#进程送达函数" class="headerlink" title="进程送达函数"></a>进程送达函数</h4><p>pthread_kill():向指定的函数发送信号，和多进程的相似</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810182019544.png" alt="image-20220810182019544"></p>
<h4 id="信号的更多知识"><a href="#信号的更多知识" class="headerlink" title="信号的更多知识"></a>信号的更多知识</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810181626425.png" alt="image-20220810181626425"></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42719755">什么是线程安全，你真的了解吗？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h4 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h4><p>既然是线程安全问题，那么毫无疑问所有的隐患都是出现在多个线程访问的情况下产生的，也就是我们要确保在多条线程访问的时候，我们的程序还能按照我们预期的行为去执行，我们看一下下面的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    count ++;</span><br><span class="line">    System.out.<span class="built_in">println</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的一段代码，我们就来统计一下这个方法的访问次数，多个线程同时访问会不会出现什么问题，我开启的3条线程每个线程循环10次，得到一下结果</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/v2-6e08c408e56f27252fe06369a280765e_1440w.jpg" alt="img"></p>
<p>我们可以看到，这里出现了两个26，为什么会出现这种情况，出现这种情况显然表明我们这个方法根本就不是线程安全的，出现这种问题的原因有很多，我们说最常见的一种，就是我们A线程在进入方法后，拿到了count的值，刚把这个值读取出来还没有改变count的值的时候，结果线程B也进来的，那么导致线程A和线程B拿到的count值是一样的。</p>
<p>那么由此我们可以了解这确实不是一个线程安全的类，因为他们都需要操作这个共享的变量，其实要对线程安全问题给出一个明确的定义还是蛮复杂的，我们根据我们这个程序来总结下什么是线程安全。</p>
<p><strong>当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。</strong></p>
<h4 id="线程安全相关定义"><a href="#线程安全相关定义" class="headerlink" title="线程安全相关定义"></a>线程安全相关定义</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810182954131.png" alt="image-20220810182954131"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183002920.png" alt="image-20220810183002920"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183015609.png" alt="image-20220810183015609"></p>
<blockquote>
<p> 在多线程程序中，i++ i+1 写入结果这些可能不是原子操作，你读我也读</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183115468.png" alt="image-20220810183115468"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183212903.png" alt="image-20220810183212903"></p>
<blockquote>
<p>volatile关键字也不能解决问题，因为它不是原子的</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183328447.png" alt="image-20220810183328447"></p>
<h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><blockquote>
<p> 原子锁，了解即可</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183440197.png" alt="image-20220810183440197"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183518560.png" alt="image-20220810183518560"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183535798.png" alt="image-20220810183535798"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183556921.png" alt="image-20220810183556921"></p>
<p>两条线程一起执行同一个全局变量var</p>
<p>这个和上面那个区别并不大</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183654106.png" alt="image-20220810183654106"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183733770.png" alt="image-20220810183733770"></p>
<h5 id="C11原子类型"><a href="#C11原子类型" class="headerlink" title="C11原子类型"></a>C11原子类型</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810183845389.png" alt="image-20220810183845389"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程安全。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; var;		<span class="comment">// 创建一个原子int对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> thid1,thid2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid1,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid2,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;var=%d\n&quot;,var);</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;var=&quot;</span> &lt;&lt; var &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">1000000</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    var++;</span><br><span class="line">    <span class="comment">// __sync_fetch_and_add(&amp;var,1);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原子操作只支持整数，效率高，但是应用场景非常有限，实际开发中，锁住对象和一串代码是无法做到的，只能用<code>线程同步</code></p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步的三属性彻底解决了线程安全的问题。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810184119509.png" alt="image-20220810184119509"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810185537249.png" alt="image-20220810185537249"></p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810185624359.png" alt="image-20220810185624359"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810185634361.png" alt="image-20220810185634361"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程同步-互斥锁。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;      <span class="comment">// 声明互斥锁。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// pthread_mutex_init(&amp;mutex,NULL);   // 初始化互斥锁。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">pthread_t</span> thid1,thid2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid1,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid2,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var=%d\n&quot;</span>,var);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);  <span class="comment">// 销毁锁。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">1000000</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);    <span class="comment">// 加锁。</span></span><br><span class="line">    var++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 解锁。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><p>了解即可</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810185849860.png" alt="image-20220810185849860"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810185923982.png" alt="image-20220810185923982"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810185941683.png" alt="image-20220810185941683"></p>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>和互斥锁几乎一样，唯一不同的就是自旋锁它会在等待的时候不断地消耗cpu，而互斥锁不会。</p>
<p>​        但也不能说谁好谁不好，各有应用的场景。</p>
<p>==自旋锁==适用等待时间比较==短==的场景，而==互斥锁==适用于等待时间可能会比较==长==的场景</p>
<p>自旋锁没有等待超时的函数，因为他默认使用场景就是等待时间很短的</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190019130.png" alt="image-20220810190019130"></p>
<p>自旋锁的参数和互斥锁的区别是多了一个共享标志</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190340529.png" alt="image-20220810190340529"></p>
<p>​        这个share和private是这样的，在开发中，我们可以在进程中创建线程，线程中创建进程，但是实际开发的时候这样没有必要，毕竟程序搞得这么复杂，以后也看不懂，这个参数就是如果在多进程中创建多线程，不同进程中的线程是否能够共享锁而设计的，一般也填写priave<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190509690.png" alt="image-20220810190509690"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程同步-自旋锁。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> spin;      <span class="comment">// 声明自旋锁。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pthread_spin_init</span>(&amp;spin,PTHREAD_PROCESS_PRIVATE);   <span class="comment">// 初始化自旋锁。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">pthread_t</span> thid1,thid2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid1,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid2,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var=%d\n&quot;</span>,var);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_spin_destroy</span>(&amp;spin);  <span class="comment">// 销毁锁。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">1000000</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">pthread_spin_lock</span>(&amp;spin);    <span class="comment">// 加锁。</span></span><br><span class="line">    var++;</span><br><span class="line">    <span class="built_in">pthread_spin_unlock</span>(&amp;spin);  <span class="comment">// 解锁。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190724465.png" alt="image-20220810190724465"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190748426.png" alt="image-20220810190748426"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190824426.png" alt="image-20220810190824426"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190850126.png" alt="image-20220810190850126"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190907308.png" alt="image-20220810190907308"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810190918019.png" alt="image-20220810190918019"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810191002906.png" alt="image-20220810191002906"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810191016011.png" alt="image-20220810191016011"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程同步-读写锁。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock=PTHREAD_RWLOCK_INITIALIZER;   <span class="comment">// 声明读写锁并初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;       <span class="comment">// 信号15的处理函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">signal</span>(<span class="number">15</span>,handle);       <span class="comment">// 设置信号15的处理函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">pthread_t</span> thid1,thid2,thid3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid3,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">pthread_join</span>(thid1,<span class="literal">NULL</span>);  <span class="built_in">pthread_join</span>(thid2,<span class="literal">NULL</span>);  <span class="built_in">pthread_join</span>(thid3,<span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);  <span class="comment">// 销毁锁。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">100</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程%lu开始申请读锁...\n&quot;</span>,<span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);    <span class="comment">// 加锁。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程%lu开始申请读锁成功。\n\n&quot;</span>,<span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);    <span class="comment">// 解锁。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程%lu已释放读锁。\n\n&quot;</span>,<span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ii==<span class="number">3</span>) <span class="built_in">sleep</span>(<span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> sig)</span>       <span class="comment">// 信号15的处理函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;开始申请写锁...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);    <span class="comment">// 加锁。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;申请写锁成功。\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);    <span class="comment">// 解锁。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;写锁已释放。\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>条件变量给多线程提供了复活的机制</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810191653761.png" alt="image-20220810191653761"></p>
<blockquote>
<p>API</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810191703809.png" alt="image-20220810191703809"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810191725487.png" alt="image-20220810191725487"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810191736210.png" alt="image-20220810191736210"></p>
<p>在信号处理中，发送15信号，唤醒他一次（线程主函数中应该用wait使得它沉睡，等待被唤醒）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192111448.png" alt="image-20220810192111448"></p>
<p>暂时先介绍到这里</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192307109.png" alt="image-20220810192307109"></p>
<blockquote>
<p>API</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192401088.png" alt="image-20220810192401088"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192416123.png" alt="image-20220810192416123"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192425126.png" alt="image-20220810192425126"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192433594.png" alt="image-20220810192433594"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示线程同步-信号量。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> sem;      <span class="comment">// 声明信号量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;    <span class="comment">// 线程主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">sem_init</span>(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);   <span class="comment">// 初始化信号量。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">pthread_t</span> thid1,thid2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建线程。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,thmain,<span class="literal">NULL</span>)!=<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed.\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子线程退出。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid1,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">pthread_join</span>(thid2,<span class="literal">NULL</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;join ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var=%d\n&quot;</span>,var);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sem_destroy</span>(&amp;sem);  <span class="comment">// 销毁信号量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">1000000</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);    <span class="comment">// 加锁。</span></span><br><span class="line">    var++;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sem);  <span class="comment">// 解锁。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a>细节说明</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192636785.png" alt="image-20220810192636785"></p>
<p>互斥锁有两种竞争机制，1、形成等待队列 2、重新竞争</p>
<p>读写锁比较特别，其余几个都是形成等待队列</p>
<p>既然是排队，可能我们会以为是绝对公平的，但实际上并不是这样</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192827011.png" alt="image-20220810192827011"></p>
<p>这可能与CPU时间片或者操作系统的调度有关系，比如说当前线程虽然释放了锁，但他的时间片并没有用完，就是说本来该轮到下一个线程，但是这个线程还没有被调度，所以刚刚执行过的线程又得到了锁</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810192957768.png" alt="image-20220810192957768"></p>
<p>那我们加一行，让cpu放弃时间片的代码，再来运行。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810193023876.png" alt="image-20220810193023876"></p>
<p>现在的情况好一些了</p>
<p>这些例子证明了等待机制没有绝对的公平，但是对应用开发没有任何影响，这里举例也只是因为怕钻牛角尖</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810193152271.png" alt="image-20220810193152271"></p>
<p>我们有一个原则，锁的持有时间越短越好，所以实际开发中是不会出现饿死的情况。</p>
<p>读写锁读优先肯定有他的应用场景，如果不合适，不用就行了，不应该说这是读写锁的缺陷，而是物尽其用，都要分清场合。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220810193306777.png" alt="image-20220810193306777"></p>
<p>linux没有提供，可以自己做一个！</p>
<h5 id="生产消费者模型"><a href="#生产消费者模型" class="headerlink" title="生产消费者模型"></a>生产消费者模型</h5><h6 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h6><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811112554857.png" alt="image-20220811112554857"></p>
<h6 id="条件变量-互斥锁实现"><a href="#条件变量-互斥锁实现" class="headerlink" title="条件变量+互斥锁实现"></a>条件变量+互斥锁实现</h6><p>我们先来搞清楚条件变量的wait做了什么</p>
<p>第三个步骤的两个操作是<strong>原子操作</strong>，只有在都成功的情况下才返回。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811112949273.png" alt="image-20220811112949273"></p>
<p>为何条件变量一定要跟着一把互斥锁，就是因为条件变量就是为了生产消费者模型而设计的，没有其他的用途。</p>
<p>细节都写在代码里了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本程序演示用互斥锁和条件变量实现高速缓存。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存队列消息的结构体。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_message</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>  mesgid;          <span class="comment">// 消息的id。</span></span><br><span class="line">  <span class="keyword">char</span> message[<span class="number">1024</span>];   <span class="comment">// 消息的内容。</span></span><br><span class="line">&#125;stmesg;</span><br><span class="line"></span><br><span class="line">vector&lt;struct st_message&gt; vcache;  <span class="comment">// 用vector容器做缓存。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span>  cond=PTHREAD_COND_INITIALIZER;     <span class="comment">// 声明并初始化条件变量。</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;   <span class="comment">// 声明并初始化互斥锁。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">incache</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;      <span class="comment">// 生产者、数据入队。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">outcache</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;   <span class="comment">// 消费者、数据出队线程的主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">signal</span>(<span class="number">15</span>,incache);  <span class="comment">// 接收15的信号，调用生产者函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建三个消费者线程。</span></span><br><span class="line">  <span class="keyword">pthread_t</span> thid1,thid2,thid3;</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;thid1,<span class="literal">NULL</span>,outcache,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;thid2,<span class="literal">NULL</span>,outcache,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">pthread_create</span>(&amp;thid3,<span class="literal">NULL</span>,outcache,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_join</span>(thid1,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">pthread_join</span>(thid3,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">  <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incache</span><span class="params">(<span class="keyword">int</span> sig)</span>       <span class="comment">// 生产者、数据入队。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> mesgid=<span class="number">1</span>;  <span class="comment">// 消息的计数器。</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_message</span> <span class="title">stmesg</span>;</span>      <span class="comment">// 消息内容。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;stmesg,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_message));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);    <span class="comment">// 给缓存队列加锁。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  生产数据，放入缓存队列。</span></span><br><span class="line">  stmesg.mesgid=mesgid++; vcache.<span class="built_in">push_back</span>(stmesg);  </span><br><span class="line">  stmesg.mesgid=mesgid++; vcache.<span class="built_in">push_back</span>(stmesg);  </span><br><span class="line">  stmesg.mesgid=mesgid++; vcache.<span class="built_in">push_back</span>(stmesg);  </span><br><span class="line">  stmesg.mesgid=mesgid++; vcache.<span class="built_in">push_back</span>(stmesg);  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 给缓存队列解锁。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//pthread_cond_signal(&amp;cond);    // 发送条件信号，激活一个线程。</span></span><br><span class="line">  <span class="built_in">pthread_cond_broadcast</span>(&amp;cond); <span class="comment">// 发送条件信号，激活全部的线程。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">thcleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 在这里释放关闭文件、断开网络连接、回滚数据库事务、释放锁等等。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cleanup ok.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一定要释放锁，不然回不去主线程里</span></span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  A condition  wait  (whether  timed  or  not)  is  a  cancellation  point. When the cancelability type of a thread is set to PTHREAD_CAN_CEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in effect)  re-acquired before  calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed to execute up to the point of returning from the call to pthread_cond_timedwait() or pthread_cond_wait(), but at that point notices  the  cancellation  request  and instead  of  returning to the caller of pthread_cond_timedwait() or pthread_cond_wait(), starts the thread cancellation activities, which includes calling cancellation cleanup handlers.</span></span><br><span class="line"><span class="comment">  意思就是在pthread_cond_wait时执行pthread_cancel后，</span></span><br><span class="line"><span class="comment">  要先在线程清理函数中要先解锁已与相应条件变量绑定的mutex，</span></span><br><span class="line"><span class="comment">  这样是为了保证pthread_cond_wait可以返回到调用线程。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">outcache</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 消费者、数据出队线程的主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pthread_cleanup_push</span>(thcleanup,<span class="literal">NULL</span>);  <span class="comment">// 把线程清理函数入栈。</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_message</span> <span class="title">stmesg</span>;</span>  <span class="comment">// 用于存放出队的消息。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 给缓存队列加锁。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存队列为空，等待，用while防止条件变量虚假唤醒。</span></span><br><span class="line">    <span class="comment">// 就比如总共三个消费者，现在大家都没吃的，阻塞在wait里，</span></span><br><span class="line">    <span class="comment">// 突然生产出产品了，但只生成了两个在管道内，他们三个如果是if的话，都同时检测到</span></span><br><span class="line">    <span class="comment">// size != 0, 因此被唤醒，但是如果是while，则会不断的判断是否为0，最终肯定两个先抢到的出来</span></span><br><span class="line">    <span class="comment">// 最后一个没抢到的被拦在while里面永远无法抵达的真实。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (vcache.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存队列中获取第一条记录，然后删除该记录。</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;stmesg,&amp;vcache[<span class="number">0</span>],<span class="built_in"><span class="keyword">sizeof</span></span>(struct st_message)); <span class="comment">// 内存拷贝。</span></span><br><span class="line">    vcache.<span class="built_in">erase</span>(vcache.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">// 给缓存队列解锁。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是处理业务的代码。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;phid=%ld,mesgid=%d\n&quot;</span>,<span class="built_in">pthread_self</span>(),stmesg.mesgid);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cleanup_pop</span>(<span class="number">1</span>);  <span class="comment">// 把线程清理函数出栈。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h6><p>​        用一个信号量代替互斥锁，一个信号量代替条件变量，信号量不存在必须解锁才能返回的情况，唯一缺点是本来一个wait搞定的现在要wait前解锁，wait后加锁（也就是从原子操作变为不是原子操作，但是没有关系），不如条件变量方便，但是在<strong>多进程的程序中只能使用信号量</strong>，操作系统里，也是用信号量实现，也就是条件变量+互斥锁专用于多线程。</p>
<p>​        在线程里面，生产数据只能不断用<code>sem_post(&amp;xxxx)</code>来加一信号量，想要同时生成多个就该在代码行内冗余写这句，但是在进程里就不是，只需要调用一次v操作就可以取得已经生产好的量的数值</p>
<h4 id="多线程的网络服务端"><a href="#多线程的网络服务端" class="headerlink" title="多线程的网络服务端"></a>多线程的网络服务端</h4><p>这里先给出代码，很多细节都在代码里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：demo20.cpp，此程序演示采用开发框架的CTcpServer类实现socket通讯多线程的服务端。</span></span><br><span class="line"><span class="comment"> * 作者： jjyaoao</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../_public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CLogFile   logfile;    <span class="comment">// 服务程序的运行日志。</span></span><br><span class="line">CTcpServer TcpServer;  <span class="comment">// 创建服务端对象。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;    <span class="comment">// 进程的退出函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> vthidlock;  <span class="comment">// 用于锁定vthid的自旋锁。</span></span><br><span class="line">vector&lt;<span class="keyword">pthread_t</span>&gt; vthid;       <span class="comment">// 存放全部线程id的容器。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;       <span class="comment">// 线程主函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thcleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;     <span class="comment">// 线程清理函数。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Using:./demo20 port logfile\nExample:./demo20 5005 /tmp/demo20.log\n\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭全部的信号和输入输出。</span></span><br><span class="line">  <span class="comment">// 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程</span></span><br><span class="line">  <span class="comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span></span><br><span class="line">  <span class="built_in">CloseIOAndSignal</span>(); <span class="built_in">signal</span>(SIGINT,EXIT); <span class="built_in">signal</span>(SIGTERM,EXIT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logfile.<span class="built_in">Open</span>(argv[<span class="number">2</span>],<span class="string">&quot;a+&quot;</span>)==<span class="literal">false</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;logfile.Open(%s) failed.\n&quot;</span>,argv[<span class="number">2</span>]); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端初始化。</span></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]))==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;TcpServer.InitServer(%s) failed.\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_spin_init</span>(&amp;vthidlock,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 等待客户端的连接请求。</span></span><br><span class="line">    <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>()==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;TcpServer.Accept() failed.\n&quot;</span>); <span class="built_in">EXIT</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;客户端（%s）已连接。\n&quot;</span>,TcpServer.<span class="built_in">GetIP</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的线程，让它与客户端通讯。</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thid;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid,<span class="literal">NULL</span>,thmain,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)TcpServer.m_connfd)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;pthread_create() failed.\n&quot;</span>); TcpServer.<span class="built_in">CloseListen</span>(); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_spin_lock</span>(&amp;vthidlock);</span><br><span class="line">    vthid.<span class="built_in">push_back</span>(thid);    <span class="comment">// 把线程id放入容器。</span></span><br><span class="line">    <span class="built_in">pthread_spin_unlock</span>(&amp;vthidlock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>     <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pthread_cleanup_push</span>(thcleanup,arg);       <span class="comment">// 把线程清理函数入栈（关闭客户端的socket）。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> connfd=(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg;    <span class="comment">// 客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_setcanceltype</span>(PTHREAD_CANCEL_ASYNCHRONOUS,<span class="literal">NULL</span>);   <span class="comment">// 线程取消方式为立即取消。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());           <span class="comment">// 把线程分离出去。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子线程与客户端进行通讯，处理业务。</span></span><br><span class="line">  <span class="keyword">int</span>  ibuflen;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">102400</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与客户端通讯，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 客户端已经断开的话TcpRead和TcpWrite会跳出循环</span></span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TcpRead</span>(connfd,buffer,&amp;ibuflen,<span class="number">30</span>)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 接收客户端的请求报文。</span></span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;接收：%s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TcpWrite</span>(connfd,buffer)==<span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">// 向客户端发送响应结果。</span></span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;发送：%s\n&quot;</span>,buffer);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">close</span>(connfd);       <span class="comment">// 关闭客户端的连接。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把本线程id从存放线程id的容器中删除。</span></span><br><span class="line">  <span class="comment">// 处理客户端因为网络断开的意外退出。</span></span><br><span class="line">  <span class="built_in">pthread_spin_lock</span>(&amp;vthidlock);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;vthid.<span class="built_in">size</span>();ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 用equal函数代替pthread_self() == vthid[ii]可实现多平台兼容，因为有可能有的平台，线程的ID有的是整数，有的是结构体</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_equal</span>(<span class="built_in">pthread_self</span>(),vthid[ii])) &#123; vthid.<span class="built_in">erase</span>(vthid.<span class="built_in">begin</span>()+ii); <span class="keyword">break</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pthread_spin_unlock</span>(&amp;vthidlock);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cleanup_pop</span>(<span class="number">1</span>);         <span class="comment">// 把线程清理函数出栈。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程的退出函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;进程退出，sig=%d。\n&quot;</span>,sig);</span><br><span class="line"></span><br><span class="line">  TcpServer.<span class="built_in">CloseListen</span>();    <span class="comment">// 关闭监听的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消全部的线程。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;vthid.<span class="built_in">size</span>();ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 线程被创建后与客户端进行通信，客户端断开了网络连接，子线程就会退出。</span></span><br><span class="line">    <span class="comment">// 这个时候子线程应该把自己的ID从容器中删除。</span></span><br><span class="line">    <span class="built_in">pthread_cancel</span>(vthid[ii]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);        <span class="comment">// 让子线程有足够的时间退出。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_spin_destroy</span>(&amp;vthidlock);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thcleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span>     <span class="comment">// 线程清理函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">close</span>((<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);      <span class="comment">// 关闭客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;线程%lu退出。\n&quot;</span>,<span class="built_in">pthread_self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h5><p>​        基于多进程网络客户端的思想，主要内容是大同小异的，但是仍然有许多细节点需要注意，第一个是退出函数，考虑因客户端网络断开而意外退出的情况，第二个是线程安全，多个客户端同时启动访问，可带来多个线程，如果不加锁的话后果不堪设想，由于我们这个服务端访问之后执行时间较短，这里采用自旋锁。另外日志文件类型也不是安全的，也需要加锁，构造析构加锁解锁，写日志时加锁，写完的时候解锁，用这个方法来简单举例：<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811164246646.png" alt="image-20220811164246646"></p>
<p>linux大部分函数都是安全的，不安全的常见的就这几个。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811164355077.png" alt="image-20220811164355077"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811164508901.png" alt="image-20220811164508901"></p>
<p>在框架中用到了三个，其中localtime肯定会用到，我们框架里用到的是不安全版本的，注释里的就是安全版本的<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811164555118.png" alt="image-20220811164555118"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811164621509.png" alt="image-20220811164621509"></p>
<h3 id="拓展学习"><a href="#拓展学习" class="headerlink" title="拓展学习"></a>拓展学习</h3><p>看看就好，了解一下不是坏事</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811164830696.png" alt="image-20220811164830696"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165034110.png" alt="image-20220811165034110"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165103305.png" alt="image-20220811165103305"></p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>能做出这道题，基本上可以算是合格的程序员。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165207870.png" alt="image-20220811165207870"></p>
<h4 id="保证服务程序稳定性"><a href="#保证服务程序稳定性" class="headerlink" title="保证服务程序稳定性"></a>保证服务程序稳定性</h4><p>多线程来做有一个好处，监控，调度，程序的功能在同一个程序中，我们之前那个使用了三个程序。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165258371.png" alt="image-20220811165258371"></p>
<h4 id="异步通讯"><a href="#异步通讯" class="headerlink" title="异步通讯"></a>异步通讯</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165434593.png" alt="image-20220811165434593"></p>
<h2 id="十三、数据服务总线"><a href="#十三、数据服务总线" class="headerlink" title="十三、数据服务总线"></a>十三、数据服务总线</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165546150.png" alt="image-20220811165546150"></p>
<p>​        直连数据访问速度快，并且使用方便，通过数据服务总线(接口)，则需要按照HTTP条条框框执行，并且不是随心所欲，这两种方式都有对应的应用场景</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165822751.png" alt="image-20220811165822751"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165850806.png" alt="image-20220811165850806"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220811165909230.png" alt="image-20220811165909230"></p>
<h3 id="HTTP协议的本质"><a href="#HTTP协议的本质" class="headerlink" title="HTTP协议的本质"></a>HTTP协议的本质</h3><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>HTTP协议的通信方式是最简单直接的，客户端发起TCP连接请求，连接成功后发起请求报文，服务端响应，采用短连接的话通信一次即断开，长连接可以多次通信。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220812160732830.png" alt="image-20220812160732830"></p>
<h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p>把请求的报文按这个格式拼接成一个字符串，发送给服务端就行了。</p>
<p>另外http是不安全的链接，https是安全的，在浏览器会显示一把锁。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220812161546933.png" alt="image-20220812161546933"></p>
<p><code>GET / HTTP/1.1 </code>是请求行</p>
<p>这个例子，后面的都是请求头部，在GET方法里没有请求数据，别的方法里有些有，有些没有。</p>
<p>头部字段一般比较多，必填的是Host，Connection和Port比较有意义</p>
<h4 id="客户端判断响应是否结束"><a href="#客户端判断响应是否结束" class="headerlink" title="客户端判断响应是否结束"></a>客户端判断响应是否结束</h4><p>Content-Length可以不写，写了的话，如果长度多了或者少了，无法显示内容</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220812162657427.png" alt="image-20220812162657427"></p>
<h4 id="wget-iconv"><a href="#wget-iconv" class="headerlink" title="wget +iconv"></a>wget +iconv</h4><p>wget+地址即可拉取下来。支持http和https，我们这个demo只支持http</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220812163842876.png" alt="image-20220812163842876"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220812163922256.png" alt="image-20220812163922256"></p>
<blockquote>
<p>iconv可以将一个文件的字符集从一种格式转化为另外一种</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220812164045548.png" alt="image-20220812164045548"></p>
<h3 id="数据服务总线概念"><a href="#数据服务总线概念" class="headerlink" title="数据服务总线概念"></a>数据服务总线概念</h3><p>给HTTP的数据访问接口起一个高大上的名字，数据访问总线就是这么来的。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220812164353992.png" alt="image-20220812164353992"></p>
<h3 id="简单demo实现"><a href="#简单demo实现" class="headerlink" title="简单demo实现"></a>简单demo实现</h3><p>所要实现的框架大体是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、接收客户端的请求报文；</span></span><br><span class="line"><span class="comment">// 2、解析URL中的参数，参数中指定了查询数据的条件；</span></span><br><span class="line"><span class="comment">// 3、从T_ZHOBTMIND1表中查询数据，以xml格式返回给客户端。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受请求</span></span><br><span class="line">  CTcpServer TcpServer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务端初始化。</span></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">InitServer</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]))==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.InitServer(%s) failed.\n&quot;</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待客户端的连接请求。</span></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>()==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpServer.Accept() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;客户端（%s）已连接。\n&quot;</span>,TcpServer.<span class="built_in">GetIP</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> strget[<span class="number">102400</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strget,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strget));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收http客户端发送过来的报文。</span></span><br><span class="line">  <span class="built_in">recv</span>(TcpServer.m_connfd,strget,<span class="number">1000</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,strget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先把响应报文头部发送给客户端。</span></span><br><span class="line">  <span class="keyword">char</span> strsend[<span class="number">102400</span>];</span><br><span class="line">  <span class="built_in">memset</span>(strsend,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strsend));</span><br><span class="line">  <span class="built_in">sprintf</span>(strsend,\</span><br><span class="line">         <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>\</span><br><span class="line">         <span class="string">&quot;Server: demo28\r\n&quot;</span>\</span><br><span class="line">         <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n&quot;</span>\</span><br><span class="line">         <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">         <span class="comment">// &quot;Content-Length: 108909\r\n\r\n&quot;);</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Writen</span>(TcpServer.m_connfd,strsend,<span class="built_in">strlen</span>(strsend))== <span class="literal">false</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//logfile.Write(&quot;%s&quot;,strsend);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析GET请求中的参数，从T_ZHOBTMIND1表中查询数据，返回给客户端。</span></span><br><span class="line">  <span class="built_in">SendData</span>(TcpServer.m_connfd,strget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8080/api?username=wucz&amp;passwd=wuczpwd&amp;intetname=getZHOBTMIND1&amp;obtid=51076</span></span><br><span class="line"><span class="comment">// 从GET请求中获取参数的值：strget-GET请求报文的内容；name-参数名；value-参数值；len-参数值的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getvalue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strget,<span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">char</span> *value,<span class="keyword">const</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  value[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *start,*end;</span><br><span class="line">  start=end=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// strstr返回字符串name在strget中首次出现的地址。</span></span><br><span class="line">  start=<span class="built_in">strstr</span>((<span class="keyword">char</span> *)strget,(<span class="keyword">char</span> *)name);</span><br><span class="line">  <span class="keyword">if</span> (start==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// end为一条参数值结束的位置。</span></span><br><span class="line">  end=<span class="built_in">strstr</span>(start,<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">  <span class="comment">// &amp;和空格都是结束值，只不过空格是最后</span></span><br><span class="line">  <span class="keyword">if</span> (end==<span class="number">0</span>) end=<span class="built_in">strstr</span>(start,<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (end==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一条查询条件的长度</span></span><br><span class="line">  <span class="keyword">int</span> ilen=end-(start+<span class="built_in">strlen</span>(name)+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (ilen&gt;len) ilen=len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到这条内容保存在value中</span></span><br><span class="line">  <span class="built_in">strncpy</span>(value,start+<span class="built_in">strlen</span>(name)+<span class="number">1</span>,ilen);</span><br><span class="line"></span><br><span class="line">  value[ilen]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析GET请求中的参数，从T_ZHOBTMIND1表中查询数据，返回给客户端。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sockfd,<span class="keyword">const</span> <span class="keyword">char</span> *strget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 解析URL中的参数。</span></span><br><span class="line">  <span class="comment">// 权限控制：用户名和密码。</span></span><br><span class="line">  <span class="comment">// 接口名：访问数据的种类。</span></span><br><span class="line">  <span class="comment">// 查询条件：设计接口的时候决定。 </span></span><br><span class="line">  <span class="comment">// http://127.0.0.1:8080/api?wucz&amp;wuczpwd&amp;getZHOBTMIND1&amp;51076&amp;20211024094318&amp;20211024114020</span></span><br><span class="line">  <span class="comment">// http://127.0.0.1:8080/api?username=wucz&amp;passwd=wuczpwd&amp;intetname=getZHOBTMIND1&amp;obtid=51076&amp;begintime=20211024094318&amp;endtime=20211024114020</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> username[<span class="number">31</span>],passwd[<span class="number">31</span>],intername[<span class="number">30</span>],obtid[<span class="number">11</span>],begintime[<span class="number">21</span>],endtime[<span class="number">21</span>];</span><br><span class="line">  <span class="built_in">memset</span>(username,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(username));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似于解析xml的函数，这个是解析get的</span></span><br><span class="line">  <span class="built_in">getvalue</span>(strget,<span class="string">&quot;username&quot;</span>,username,<span class="number">30</span>);    <span class="comment">// 获取用户名。</span></span><br><span class="line">.............</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;username=%s\n&quot;</span>,username);</span><br><span class="line">.............</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断用户名/密码和接口名是否合法。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接数据库。</span></span><br><span class="line">  connection conn;</span><br><span class="line">  conn.<span class="built_in">connecttodb</span>(<span class="string">&quot;scott/tiger@snorcl11g_132&quot;</span>,<span class="string">&quot;Simplified Chinese_China.AL32UTF8&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备查询数据的SQL。</span></span><br><span class="line">  <span class="function">sqlstatement <span class="title">stmt</span><span class="params">(&amp;conn)</span></span>;</span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select &#x27;&lt;obtid&gt;&#x27;||obtid||&#x27;&lt;/obtid&gt;&#x27;||&#x27;&lt;ddatetime&gt;&#x27;||to_char(ddatetime,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;)||&#x27;&lt;/ddatetime&gt;&#x27;||&#x27;&lt;t&gt;&#x27;||t||&#x27;&lt;/t&gt;&#x27;||&#x27;&lt;p&gt;&#x27;||p||&#x27;&lt;/p&gt;&#x27;||&#x27;&lt;u&gt;&#x27;||u||&#x27;&lt;/u&gt;&#x27;||&#x27;&lt;keyid&gt;&#x27;||keyid||&#x27;&lt;/keyid&gt;&#x27;||&#x27;&lt;endl/&gt;&#x27; from T_ZHOBTMIND1 where obtid=:1 and ddatetime&gt;to_date(:2,&#x27;yyyymmddhh24miss&#x27;) and ddatetime&lt;to_date(:3,&#x27;yyyymmddhh24miss&#x27;)&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> strxml[<span class="number">1001</span>];  <span class="comment">// 存放SQL语句的结果集。</span></span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,strxml,<span class="number">1000</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,obtid,<span class="number">10</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,begintime,<span class="number">14</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">3</span>,endtime,<span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line">  stmt.<span class="built_in">execute</span>();   <span class="comment">// 执行查询数据的SQL。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Writen</span>(sockfd,<span class="string">&quot;&lt;data&gt;\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;&lt;data&gt;\n&quot;</span>));      <span class="comment">// 返回xml的头部标签。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strxml,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strxml));</span><br><span class="line">    <span class="keyword">if</span> (stmt.<span class="built_in">next</span>()!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(strxml,<span class="string">&quot;\n&quot;</span>);                           <span class="comment">// 注意加上换行符。</span></span><br><span class="line">    <span class="built_in">Writen</span>(sockfd,strxml,<span class="built_in">strlen</span>(strxml));          <span class="comment">// 返回xml的每一行。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Writen</span>(sockfd,<span class="string">&quot;&lt;/data&gt;\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;&lt;/data&gt;\n&quot;</span>));  <span class="comment">// 返回xml的尾部标签。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="url小提示"><a href="#url小提示" class="headerlink" title="url小提示"></a>url小提示</h4><p>url中不会出现空格，在语句中出现的空格，会在对方端显示为<code>%20</code></p>
<p>​        一个URL的基本组成部分包括协议(scheme),域名，端口号，路径和查询字符串（路径参数和锚点标记就暂不考虑了）。路径和查询字符串之间用问号<code>?</code>分离。例如<a target="_blank" rel="noopener" href="http://www.example.com/index?param=1%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%BAindex%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2">http://www.example.com/index?param=1，路径为index，查询字符串</a>(Query String)为param=1。URL中关于空格的编码正是与空格所在位置相关：空格被编码成加号+的情况只会在查询字符串部分出现，而被编码成%20则可以出现在路径和查询字符串中。</p>
<h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220816195102664.png" alt="image-20220816195102664"></p>
<h3 id="表的设计"><a href="#表的设计" class="headerlink" title="表的设计"></a>表的设计</h3><p>一些注意点，比如数据种类的定义那张表，外键指向自己，这种设计方式一般适用于某种具有层次关系的表</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220816201516752.png" alt="image-20220816201516752"></p>
<p>有层次的ID，取值技巧：比如说第一种类，用01,02,03,04这些来表示，第二层次就分别先带上01的ID，再后面延续，并且排序</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220816201552704.png" alt="image-20220816201552704"></p>
<h3 id="每连接每线程实现"><a href="#每连接每线程实现" class="headerlink" title="每连接每线程实现"></a>每连接每线程实现</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220817170716956.png" alt="image-20220817170716956"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819163128535.png" alt="image-20220819163128535"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>     <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pthread_cleanup_push</span>(thcleanup,arg);       <span class="comment">// 把线程清理函数入栈（关闭客户端的socket）。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> connfd=(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg;    <span class="comment">// 客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_setcanceltype</span>(PTHREAD_CANCEL_ASYNCHRONOUS,<span class="literal">NULL</span>);   <span class="comment">// 线程取消方式为立即取消。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());           <span class="comment">// 把线程分离出去。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> strrecvbuf[<span class="number">1024</span>];     <span class="comment">// 接收客户端请求报文的buffer。</span></span><br><span class="line">  <span class="built_in">memset</span>(strrecvbuf,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strrecvbuf));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取客户端的报文，如果超时或失败，线程退出。</span></span><br><span class="line">  <span class="comment">// 不能用原生的recv，因为服务端不可能一直等待（recv没有超时机制），如果一直等，恶意的客户端建立连接后什么也不干，会耗光服务器资源。</span></span><br><span class="line">  <span class="comment">// ReadT用了IO复用技术实现接受，下一章节会讲。</span></span><br><span class="line">  <span class="comment">// 正常情况下连接成功，客户端马上发送请求报文。所以设置2s或者3s延时</span></span><br><span class="line">  <span class="comment">// ReadT(const int sockfd, char *buffer, const int size, const int itimeout)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ReadT</span>(connfd,strrecvbuf,<span class="built_in"><span class="keyword">sizeof</span></span>(strrecvbuf),<span class="number">3</span>)&lt;=<span class="number">0</span>) <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是GET请求报文不处理，线程退出。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(strrecvbuf,<span class="string">&quot;GET&quot;</span>,<span class="number">3</span>)!=<span class="number">0</span>) <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;%s\n&quot;</span>,strrecvbuf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接数据库。</span></span><br><span class="line">  connection conn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (conn.<span class="built_in">connecttodb</span>(starg.connstr,starg.charset)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) failed.\n%s\n&quot;</span>,starg.connstr,conn.m_cda.message); <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断URL中用户名和密码，如果不正确，返回认证失败的响应报文，线程退出。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Login</span>(&amp;conn,strrecvbuf,connfd)==<span class="literal">false</span>) <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断用户是否有调用接口的权限，如果没有，返回没有权限的响应报文，线程退出。 </span></span><br><span class="line">  <span class="comment">// CheckPerm的提示信息和查询语句和Login有点不同，别的都是一样的。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CheckPerm</span>(&amp;conn,strrecvbuf,connfd)==<span class="literal">false</span>) <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先把响应报文头部发送给客户端。</span></span><br><span class="line">  <span class="keyword">char</span> strsendbuf[<span class="number">1024</span>];          </span><br><span class="line">  <span class="built_in">memset</span>(strsendbuf,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strsendbuf));</span><br><span class="line">  <span class="built_in">sprintf</span>(strsendbuf,\</span><br><span class="line">         <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>\</span><br><span class="line">         <span class="string">&quot;Server: webserver\r\n&quot;</span>\</span><br><span class="line">         <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>);</span><br><span class="line">  <span class="built_in">Writen</span>(connfd,strsendbuf,<span class="built_in">strlen</span>(strsendbuf));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再执行接口的sql语句，把数据返回给客户端。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ExecSQL</span>(&amp;conn,strrecvbuf,connfd)==<span class="literal">false</span>) <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cleanup_pop</span>(<span class="number">1</span>);         <span class="comment">// 把线程清理函数出栈。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Login"><a href="#Login" class="headerlink" title="Login()"></a>Login()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断URL中用户名和密码，如果不正确，返回认证失败的响应报文。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Login</span><span class="params">(connection *conn,<span class="keyword">const</span> <span class="keyword">char</span> *buffer,<span class="keyword">const</span> <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> username[<span class="number">31</span>],passwd[<span class="number">31</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getvalue</span>(buffer,<span class="string">&quot;username&quot;</span>,username,<span class="number">30</span>); <span class="comment">// 获取用户名。</span></span><br><span class="line">  <span class="built_in">getvalue</span>(buffer,<span class="string">&quot;passwd&quot;</span>,passwd,<span class="number">30</span>);     <span class="comment">// 获取密码。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询T_USERINFO表，判断用户名和密码是否存在。</span></span><br><span class="line">  sqlstatement stmt;</span><br><span class="line">  stmt.<span class="built_in">connect</span>(conn);</span><br><span class="line">  stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from T_USERINFO where username=:1 and passwd=:2 and rsts=1&quot;</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">1</span>,username,<span class="number">30</span>);</span><br><span class="line">  stmt.<span class="built_in">bindin</span>(<span class="number">2</span>,passwd,<span class="number">30</span>);</span><br><span class="line">  <span class="keyword">int</span> icount=<span class="number">0</span>;</span><br><span class="line">  stmt.<span class="built_in">bindout</span>(<span class="number">1</span>,&amp;icount);</span><br><span class="line">  stmt.<span class="built_in">execute</span>();</span><br><span class="line">  stmt.<span class="built_in">next</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (icount==<span class="number">0</span>)   <span class="comment">// 认证失败，返回认证失败的响应报文。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> strbuffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memset</span>(strbuffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strbuffer));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 客户端调用这个动作不管成功开始失败，响应都用200，也就是说调用这个动作是成功的，有其他问题在报文内容体现</span></span><br><span class="line">    <span class="comment">// 重点想说的就是不要用HTTP协议的返回码去表达失败的情况</span></span><br><span class="line">    <span class="built_in">sprintf</span>(strbuffer,\</span><br><span class="line">           <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>\</span><br><span class="line">           <span class="string">&quot;Server: webserver\r\n&quot;</span>\</span><br><span class="line">           <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>\</span><br><span class="line">           <span class="string">&quot;&lt;retcode&gt;-1&lt;/retcode&gt;&lt;message&gt;username or passwd is invailed&lt;/message&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">Writen</span>(sockfd,strbuffer,<span class="built_in">strlen</span>(strbuffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CheckPerm"><a href="#CheckPerm" class="headerlink" title="CheckPerm()"></a><strong>CheckPerm()</strong></h4><p>真的就这点点不同=-=，和Login()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt.<span class="built_in">prepare</span>(<span class="string">&quot;select count(*) from T_USERANDINTER where username=:1 and intername=:2 and intername in (select intername from T_INTERCFG where rsts=1)&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sprintf</span>(strbuffer,\</span><br><span class="line">		.......</span><br><span class="line">          <span class="string">&quot;&lt;retcode&gt;-1&lt;/retcode&gt;&lt;message&gt;permission denied&lt;/message&gt;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ExecSQL"><a href="#ExecSQL" class="headerlink" title="ExecSQL()"></a>ExecSQL()</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819165553078.png" alt="image-20220819165553078"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819165625139.png" alt="image-20220819165625139"></p>
<p>我们一段一段描述：</p>
<ol>
<li>getvalue解析接口名</li>
<li>申明几个变量，用sqlstatement stmt对象将参数拿出来（接口SQL，输出列名，接口参数）</li>
<li>prepare()准备SQL语句</li>
<li>绑定输入输出变量。</li>
<li>execute()执行，使得SQL语句good，得到应该得到的东西</li>
<li>再次用getvalue，将输从url中获取的参数绑定到对应的变量中</li>
<li>发送标签是用Writen()函数</li>
</ol>
<p>最关键的那一部分是这样做到的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取结果集，每获取一条记录，拼接xml报文，发送给客户端。</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">char</span> strtemp[<span class="number">2001</span>];        <span class="comment">// 用于拼接xml的临时变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐行获取结果集，发送给客户端。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(strsendbuffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strsendbuffer));</span><br><span class="line">  <span class="built_in">memset</span>(colvalue,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(colvalue));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stmt.<span class="built_in">next</span>() != <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">// 从结果集中取一条记录。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接每个字段的xml。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;CmdStr.<span class="built_in">CmdCount</span>();ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(strtemp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strtemp));</span><br><span class="line">    <span class="built_in">snprintf</span>(strtemp,<span class="number">2000</span>,<span class="string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>,CmdStr.m_vCmdStr[ii].<span class="built_in">c_str</span>(),colvalue[ii],CmdStr.m_vCmdStr[ii].<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcat</span>(strsendbuffer,strtemp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcat</span>(strsendbuffer,<span class="string">&quot;&lt;endl/&gt;\n&quot;</span>);   <span class="comment">// xml每行结束的标志。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Writen</span>(sockfd,strsendbuffer,<span class="built_in">strlen</span>(strsendbuffer));   <span class="comment">// 向客户端返回这行数据。 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819171203300.png" alt="image-20220819171203300"></p>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819171512530.png" alt="image-20220819171512530"></p>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819171537795.png" alt="image-20220819171537795"></p>
<blockquote>
<p>数据库连接池和公共卫生局的原理和算法是一样的。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819171618290.png" alt="image-20220819171618290"></p>
<h4 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h4><p>​        有两个注意点需要重视，数据库连接池的数组有多大，就需要声明多少把锁，而不是共用一把锁，只能用互斥锁，不能用自旋锁，因为如果数据量比较大，数据库连接占用的时间可能比较长，自旋锁不断刷新，不合适。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXCONNS 10               <span class="comment">// 数据库连接池的大小。 </span></span></span><br><span class="line">connection conns[MAXCONNS];       <span class="comment">// 数据库连接池的数组。</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex[MAXCONNS];  <span class="comment">// 数据库连接池的锁。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initconns</span><span class="params">()</span></span>;                 <span class="comment">// 初始数据库连接池。</span></span><br><span class="line"><span class="function">connection *<span class="title">getconns</span><span class="params">()</span></span>;           <span class="comment">// 从数据库连接池中获取一个空闲的连接。函数的返回值是空闲的链接的地址，并且这个函数会对已经取走的函数加上锁。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freeconns</span><span class="params">(connection *conn)</span></span>; <span class="comment">// 释放/归还数据库连接。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">destroyconns</span><span class="params">()</span></span>;              <span class="comment">// 释放数据库连接占用的资源（断开数据库连接，销毁锁）。</span></span><br></pre></td></tr></table></figure>

<h4 id="initconns"><a href="#initconns" class="headerlink" title="initconns()"></a>initconns()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initconns</span><span class="params">()</span>                 <span class="comment">// 初始数据库连接池。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;MAXCONNS;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    <span class="keyword">if</span> (conns[ii].<span class="built_in">connecttodb</span>(starg.connstr,starg.charset) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      logfile.<span class="built_in">Write</span>(<span class="string">&quot;connect database(%s) failed.\n%s\n&quot;</span>,starg.connstr,conns[ii].m_cda.message); </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁。</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex[ii],<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getconns"><a href="#getconns" class="headerlink" title="getconns()"></a>getconns()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">connection *<span class="title">getconns</span><span class="params">()</span>           <span class="comment">// 从数据库连接池中获取一个空闲的连接。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 这个代码的思路就是不断遍历所有的空间，尝试逐个加锁，如果加锁成功，则把这个空间返回出去，不然就下次一定。</span></span><br><span class="line"><span class="comment">// 用while循环是一个很笨的办法，更好的办法是connpool::get()有所体现</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;MAXCONNS;ii++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">pthread_mutex_trylock</span>(&amp;mutex[ii])==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;get conns is %d.\n&quot;</span>,ii);</span><br><span class="line">        <span class="keyword">return</span> &amp;conns[ii];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部都失败了，就很短的时候后再次尝试</span></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">10000</span>);   <span class="comment">// 百分之一秒之后再重试。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="freeconns-connection-conn"><a href="#freeconns-connection-conn" class="headerlink" title="freeconns(connection *conn)"></a>freeconns(connection *conn)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freeconns</span><span class="params">(connection *conn)</span> <span class="comment">// 释放/归还数据库连接。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;MAXCONNS;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;conns[ii]==conn)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex[ii]); <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="destroyconns"><a href="#destroyconns" class="headerlink" title="destroyconns()"></a>destroyconns()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">destroyconns</span><span class="params">()</span>        <span class="comment">// 释放数据库连接占用的资源（断开数据库连接，销毁锁）。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;MAXCONNS;ii++)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  conns[ii].<span class="built_in">disconnect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex[ii]);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接池性能"><a href="#连接池性能" class="headerlink" title="连接池性能"></a>连接池性能</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220819211047757.png" alt="image-20220819211047757"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>最开始我们是人为的设定线程池的大小，现在我们需要对他进行优化，不然太生硬了</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820095754504.png" alt="image-20220820095754504"></p>
<p>因此定义一个专门的线程池类，方便操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库连接池类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connpool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_conn</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    connection conn;            <span class="comment">// 数据库连接。</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;      <span class="comment">// 用于数据库连接的互斥锁。</span></span><br><span class="line">    <span class="keyword">time_t</span> atime;               <span class="comment">// 数据库连接上次使用的时间，如果未连接数据库则取值0。</span></span><br><span class="line">  &#125;*m_conns;                    <span class="comment">// 数据库连接池。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>  m_maxconns;              <span class="comment">// 数据库连接池的最大值。</span></span><br><span class="line">  <span class="keyword">int</span>  m_timeout;               <span class="comment">// 数据库连接超时时间，单位：秒。</span></span><br><span class="line">  <span class="keyword">char</span> m_connstr[<span class="number">101</span>];          <span class="comment">// 数据库连接参数：用户名/密码@连接名</span></span><br><span class="line">  <span class="keyword">char</span> m_charset[<span class="number">101</span>];          <span class="comment">// 数据库的字符集。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">connpool</span>();      <span class="comment">// 构造函数。</span></span><br><span class="line"> ~<span class="built_in">connpool</span>();      <span class="comment">// 析构函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数据库连接池，初始化锁，如果数据库连接参数有问题，返回false。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *connstr,<span class="keyword">const</span> <span class="keyword">char</span> *charset,<span class="keyword">int</span> maxconns,<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">  <span class="comment">// 断开数据库连接，销毁锁，释放数据库连接池的内存空间。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从数据库连接池中获取一个空闲的连接，成功返回数据库连接的地址。</span></span><br><span class="line">  <span class="comment">// 如果连接池已用完或连接数据库失败，返回空。</span></span><br><span class="line">  <span class="function">connection *<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 归还数据库连接。</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">free</span><span class="params">(connection *conn)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查数据库连接池，断开空闲的连接，在服务程序中，用一个专用的子线程调用此函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">checkpool</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="connpool-get"><a href="#connpool-get" class="headerlink" title="connpool::get()"></a>connpool::get()</h5><p>其实就是前面getconns()demo 的一个更完善的实现。</p>
<p>​        这串代码先用trylock找出了第一个空闲的位置，如果存在这样一个位置，则将他赋值给pos，并后续将其连接上，如果未找到，则将这次的锁给释放掉</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)从数据库连接池中寻找一个空闲的、已连接好的connection，如果找到了，返回它的地址。</span></span><br><span class="line"><span class="comment">// 2)如果没有找到，在连接池中找一个未连接数据库的connection，连接数据库，如果成功，返回connection的地址。</span></span><br><span class="line"><span class="comment">// 3)如果第2)步找到了未连接数据库的connection，但是，连接数据库失败，返回空。</span></span><br><span class="line"><span class="comment">// 4)如果第2)步没有找到未连接数据库的connection，表示数据库连接池已用完，也返回空。</span></span><br><span class="line"><span class="function">connection *<span class="title">connpool::get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pos=<span class="number">-1</span>;       <span class="comment">// 用于记录第一个未连接数据库的数组位置。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;m_maxconns;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_mutex_trylock</span>(&amp;m_conns[ii].mutex)==<span class="number">0</span>)       <span class="comment">// 尝试加锁。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (m_conns[ii].atime&gt;<span class="number">0</span>)       <span class="comment">// 如果数据库连接是已连接的状态。</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;取到连接%d。\n&quot;</span>,ii); </span><br><span class="line">        m_conns[ii].atime=<span class="built_in">time</span>(<span class="number">0</span>);   <span class="comment">// 把数据库连接的使用时间设置为当前时间。</span></span><br><span class="line">        <span class="keyword">return</span> &amp;m_conns[ii].conn;    <span class="comment">// 返回数据库连接的地址。</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pos==<span class="number">-1</span>) pos=ii;          <span class="comment">// 记录第一个未连接数据库的数组位置。</span></span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_conns[ii].mutex);     <span class="comment">// 释放锁。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos==<span class="number">-1</span>)   <span class="comment">// 如果连接池已用完，返回空。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;连接池已用完。\n&quot;</span>); <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接池没有用完，让m_conns[pos].conn连上数据库。</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;新连接%d。\n&quot;</span>,pos);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接数据库。</span></span><br><span class="line">  <span class="keyword">if</span> (m_conns[pos].conn.<span class="built_in">connecttodb</span>(m_connstr,m_charset)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果连接数据库失败，释放锁，返回空。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;连接数据库失败。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_conns[pos].mutex);  <span class="comment">// 释放锁。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  m_conns[pos].atime=<span class="built_in">time</span>(<span class="number">0</span>);      <span class="comment">// 把数据库连接的使用时间设置为当前时间。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;m_conns[pos].conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用连接池类后的线程主函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>     <span class="comment">// 线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pthread_cleanup_push</span>(thcleanup,arg);       <span class="comment">// 把线程清理函数入栈（关闭客户端的socket）。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> connfd=(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg;    <span class="comment">// 客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_setcanceltype</span>(PTHREAD_CANCEL_ASYNCHRONOUS,<span class="literal">NULL</span>);   <span class="comment">// 线程取消方式为立即取消。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>());           <span class="comment">// 把线程分离出去。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> strrecvbuf[<span class="number">1024</span>];     <span class="comment">// 接收客户端请求报文的buffer。</span></span><br><span class="line">  <span class="built_in">memset</span>(strrecvbuf,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strrecvbuf));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取客户端的报文，如果超时或失败，线程退出。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ReadT</span>(connfd,strrecvbuf,<span class="built_in"><span class="keyword">sizeof</span></span>(strrecvbuf),<span class="number">3</span>)&lt;=<span class="number">0</span>) <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是GET请求报文不处理，线程退出。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(strrecvbuf,<span class="string">&quot;GET&quot;</span>,<span class="number">3</span>)!=<span class="number">0</span>) <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;%s\n&quot;</span>,strrecvbuf);</span><br><span class="line"></span><br><span class="line">  connection *conn=oraconnpool.<span class="built_in">get</span>();   <span class="comment">// 获取一个数据库连接。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果数据库连接为空，向客户端返回内部错误，线程退出。</span></span><br><span class="line">  <span class="keyword">char</span> strsendbuf[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">if</span> (conn==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 在我们这个程序，线程取数据失败，就会很快退出(在实际开发中线程不会这么容易退出的)，以至于还没有将线程清理函数放入容器内，这就导致出现了段错误，存在无法清理干净的进程。</span></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100000</span>);  <span class="comment">// 防止线程太快退出。</span></span><br><span class="line">    <span class="built_in">memset</span>(strsendbuf,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strsendbuf));</span><br><span class="line">    <span class="built_in">sprintf</span>(strsendbuf,\</span><br><span class="line">           <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>\</span><br><span class="line">           <span class="string">&quot;Server: webserver\r\n&quot;</span>\</span><br><span class="line">           <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>\</span><br><span class="line">           <span class="string">&quot;&lt;retcode&gt;-1&lt;/retcode&gt;&lt;message&gt;internal error.&lt;/message&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">Writen</span>(connfd,strsendbuf,<span class="built_in">strlen</span>(strsendbuf));</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断URL中用户名和密码，如果不正确，返回认证失败的响应报文，线程退出。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Login</span>(conn,strrecvbuf,connfd)==<span class="literal">false</span>) &#123; oraconnpool.<span class="built_in">free</span>(conn); <span class="built_in">pthread_exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断用户是否有调用接口的权限，如果没有，返回没有权限的响应报文，线程退出。 </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CheckPerm</span>(conn,strrecvbuf,connfd)==<span class="literal">false</span>) &#123; oraconnpool.<span class="built_in">free</span>(conn); <span class="built_in">pthread_exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先把响应报文头部发送给客户端。</span></span><br><span class="line">  <span class="built_in">memset</span>(strsendbuf,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(strsendbuf));</span><br><span class="line">  <span class="built_in">sprintf</span>(strsendbuf,\</span><br><span class="line">         <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>\</span><br><span class="line">         <span class="string">&quot;Server: webserver\r\n&quot;</span>\</span><br><span class="line">         <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>);</span><br><span class="line">  <span class="built_in">Writen</span>(connfd,strsendbuf,<span class="built_in">strlen</span>(strsendbuf));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再执行接口的sql语句，把数据返回给客户端。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ExecSQL</span>(conn,strrecvbuf,connfd)==<span class="literal">false</span>) &#123; oraconnpool.<span class="built_in">free</span>(conn); <span class="built_in">pthread_exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  oraconnpool.<span class="built_in">free</span>(conn);;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cleanup_pop</span>(<span class="number">1</span>);         <span class="comment">// 把线程清理函数出栈。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820110549305.png" alt="image-20220820110549305"></p>
<p>容器中还有两个进程未退出，具体解决方法看上面代码块的usleep注释<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820110615100.png" alt="image-20220820110615100"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thcleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span>     <span class="comment">// 线程清理函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">close</span>((<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);      <span class="comment">// 关闭客户端的socket。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把本线程id从存放线程id的容器中删除。</span></span><br><span class="line">  <span class="comment">// 注意，特别注意，如果线程跑得太快，主程序可能还不及把线程的id放入容器。</span></span><br><span class="line">  <span class="comment">// 所以，这里可能会出现找不到线程id的情况。</span></span><br><span class="line">  <span class="built_in">pthread_spin_lock</span>(&amp;vthidlock);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;vthid.<span class="built_in">size</span>();ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_equal</span>(<span class="built_in">pthread_self</span>(),vthid[ii])) &#123; vthid.<span class="built_in">erase</span>(vthid.<span class="built_in">begin</span>()+ii); <span class="keyword">break</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pthread_spin_unlock</span>(&amp;vthidlock);</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;线程%lu退出。\n&quot;</span>,<span class="built_in">pthread_self</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>和连接池的思路不一样，并且同样情况下性能比连接池提升了四五倍</p>
<p>生产消费者模型条件变量+互斥锁，有客户端连接，就是生产了一个产品，再在thmain中处理这个任务，类似于消费这个产品。工作主函数就是消费者模型。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820111307347.png" alt="image-20220820111307347"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820111334410.png" alt="image-20220820111334410"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据库连接池。</span></span><br><span class="line"><span class="keyword">if</span> (oraconnpool.<span class="built_in">init</span>(starg.connstr,starg.charset,<span class="number">10</span>,<span class="number">50</span>)==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;oraconnpool.init() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 注意看就会发现，这里如果工作进程满了，就会进入checkpool</span></span><br><span class="line">  <span class="comment">// 创建检查数据库连接池的线程。</span></span><br><span class="line">  <span class="keyword">pthread_t</span> thid;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid,<span class="literal">NULL</span>,checkpool,<span class="number">0</span>)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;pthread_create() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动10个工作线程，线程数比CPU核数略多。</span></span><br><span class="line"><span class="comment">// 如果数量多太多，线程之间的切换也会浪费时间，相等或者少，CPU资源无法充分利用</span></span><br><span class="line"><span class="comment">// 通常一核同一时间处理一个线程。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">10</span>;ii++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> thid;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thid,<span class="literal">NULL</span>,thmain,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)ii)!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;pthread_create() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vthid.<span class="built_in">push_back</span>(thid);          <span class="comment">// 把线程id保存到vthid容器中。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_spin_init</span>(&amp;spin,<span class="number">0</span>);       <span class="comment">// 初始化给vthid加锁的自旋锁。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 等待客户端的连接请求。</span></span><br><span class="line">  <span class="keyword">if</span> (TcpServer.<span class="built_in">Accept</span>()==<span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    logfile.<span class="built_in">Write</span>(<span class="string">&quot;TcpServer.Accept() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logfile.<span class="built_in">Write</span>(<span class="string">&quot;客户端（%s）已连接。\n&quot;</span>,TcpServer.<span class="built_in">GetIP</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把客户端的socket放入队列，并发送条件信号。</span></span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);               <span class="comment">// 加锁。</span></span><br><span class="line">  sockqueue.<span class="built_in">push_back</span>(TcpServer.m_connfd);  <span class="comment">// 入队。</span></span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);             <span class="comment">// 解锁。</span></span><br><span class="line">  <span class="built_in">pthread_cond_signal</span>(&amp;cond);               <span class="comment">// 触发条件，激活一个线程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820143341329.png" alt="image-20220820143341329"></p>
<p>在整个程序中，需要等待的地方只有wait哪里，也就是我们工作进程的心跳信息更新地点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果缓存队列为空，等待，用while防止条件变量虚假唤醒。</span></span><br><span class="line">    <span class="keyword">while</span> (sockqueue.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">-------------------------&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="comment">// 给缓存队列加锁。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓存队列为空，等待，用while防止条件变量虚假唤醒。</span></span><br><span class="line">  <span class="keyword">while</span> (sockqueue.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now,<span class="literal">NULL</span>);            <span class="comment">// 获取当前时间。</span></span><br><span class="line">    now.tv_sec=now.tv_sec+<span class="number">20</span>;           <span class="comment">// 取20秒之后的时间。</span></span><br><span class="line">    <span class="comment">//  下面这个函数可以百度下什么意思，大抵就是说不管有没有等待到，过了20s，都会超时返回。</span></span><br><span class="line">    <span class="built_in">pthread_cond_timedwait</span>(&amp;cond,&amp;mutex,(struct timespec*)&amp;now);    <span class="comment">// 等待条件被触发。</span></span><br><span class="line">    vthid[pthnum].atime=<span class="built_in">time</span>(<span class="number">0</span>);        <span class="comment">// 更新当前线程的活动时间。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="监控线程"><a href="#监控线程" class="headerlink" title="监控线程"></a>监控线程</h5><p>并放置主函数中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">checkthmain</span><span class="params">(<span class="keyword">void</span> *arg)</span>    <span class="comment">// 监控线程主函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 遍历工作线程结构体的容器，检查每个工作线程是否超时。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;vthid.<span class="built_in">size</span>();ii++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 工作线程超时间为20秒，这里用25秒判断超时，足够。</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">time</span>(<span class="number">0</span>)-vthid[ii].atime)&gt;<span class="number">25</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 已超时。</span></span><br><span class="line">        logfile.<span class="built_in">Write</span>(<span class="string">&quot;thread %d(%lu) timeout(%d).\n&quot;</span>,ii,vthid[ii].pthid,<span class="built_in">time</span>(<span class="number">0</span>)-vthid[ii].atime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消已超时的工作线程。</span></span><br><span class="line">        <span class="built_in">pthread_cancel</span>(vthid[ii].pthid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新创建工作线程。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;vthid[ii].pthid,<span class="literal">NULL</span>,thmain,(<span class="keyword">void</span> *)(<span class="keyword">long</span>)ii)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          logfile.<span class="built_in">Write</span>(<span class="string">&quot;pthread_create() failed.\n&quot;</span>); <span class="built_in">EXIT</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vthid[ii].atime=<span class="built_in">time</span>(<span class="number">0</span>);      <span class="comment">// 设置工作线程的活动时间。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据安全策略"><a href="#数据安全策略" class="headerlink" title="数据安全策略"></a>数据安全策略</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145217366.png" alt="image-20220820145217366"></p>
<p>通常由硬件解决，软件解决反而麻烦很多，通常不需要我们考虑。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145306843.png" alt="image-20220820145306843"></p>
<p>我们能做些什么？</p>
<p>软件意义的登录，和唯一识别。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145415334.png" alt="image-20220820145415334"></p>
<p>黑名单和白名单逻辑上是冲突的，只能二选一，不能同时要</p>
<p>前面两种是系统层面的，不针对具体用户，第三种是针对具体用户的。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145513223.png" alt="image-20220820145513223"></p>
<p>思路：</p>
<p>不管采用那种，都需要修改这个数据结构：<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145607268.png" alt="image-20220820145607268"></p>
<p>可以选择一个结构体，除了采用客户端的socket，也要采用客户端的ip地址<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145635450.png" alt="image-20220820145635450"></p>
<p>如果采用绑定ip的方法，修改Login代码就可以了。</p>
<p>拿出IP地址，与客户端连接上的对比即可。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145737776.png" alt="image-20220820145737776"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145757049.png" alt="image-20220820145757049"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820145834253.png" alt="image-20220820145834253"></p>
<p>​        为何要将黑名单和白名单放在容器中呢？，原因很简单，这种名单一般是量很少，每当有用户登录，查找内存要比查找数据库快得多 。对于数据库操作，要有一个原则，能够操作数据库，就不操作数据库，这会很快。</p>
<p>​        并且，判断是否为黑名单白名单的代码也要放在工作线程中，不要直接在socket刚刚连接加锁就解决这个问题，原子操作尽量保证内容少。</p>
<h3 id="学习总结-4"><a href="#学习总结-4" class="headerlink" title="学习总结"></a>学习总结</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150201918.png" alt="image-20220820150201918"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150231645.png" alt="image-20220820150231645"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150256028.png" alt="image-20220820150256028"></p>
<blockquote>
<p>让每个数据库的数据都是一样的，反正MySQL不要钱，不过使用过程中有一个细节，需要均匀分摊，第一个用户连了A库，那第二个就连B，总之要将用户量平摊，使得每个数据库分配的量均匀。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150311463.png" alt="image-20220820150311463"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150454410.png" alt="image-20220820150454410"></p>
<blockquote>
<p>其实本质都是一样的，为了传输，只是各自的约定不同，带来的效率，安全性，稳定性等因素也会不同。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150617268.png" alt="image-20220820150617268"></p>
<h2 id="十四、IO复用-amp-网络代理"><a href="#十四、IO复用-amp-网络代理" class="headerlink" title="十四、IO复用&amp;网络代理"></a>十四、IO复用&amp;网络代理</h2><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150806264.png" alt="image-20220820150806264"></p>
<blockquote>
<p><strong>三种模型</strong></p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150854360.png" alt="image-20220820150854360"></p>
<blockquote>
<p><strong>正向代理&amp;反向代理</strong></p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820150945915.png" alt="image-20220820150945915"></p>
<h3 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h3><p>先来了解了解TCP缓冲区</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jigetage/article/details/86774687">(18条消息) tcp缓冲区_jigetage的博客-CSDN博客_tcp缓冲区</a></p>
</blockquote>
<p>什么是tcp缓冲区？每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p>
<p>二、缓冲区的意义<br>        write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。<br>        TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，比如nagle算法，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。<br>        read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
<p>如果TCP连接断开，网络缓冲区还有为发出去的数据，下次连接后会继续发送么，还是清空缓冲区?</p>
<p>​        接收端tcp断开，分为两种情况：1. 调用close主动断开，执行tcp三次挥手，正常结束。2. 接收端断网或者宕机，此时发送端是无法知道接收端已经断开，会一直往那个已经断开的socket缓冲区发数据，知道缓冲区满就会阻塞；如果接收端重新连接上来的话，此时不会继续发送数据，因为重连的socket已经变了，缓冲区会进行了重建；老的已经断开的socket需要发送端自己处理，即调用 clientSocket.close() 清理掉废弃的socket回收相应资源</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820152440757.png" alt="image-20220820152440757"></p>
<p>​        这是select的帮助文档，readfds是需要监视可读参数的集合，writefds反之，timeout是超时时间。第一个nfds下面讲</p>
<p>fd_set我们可能看不懂是啥，可以去看看他的声明。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820152628670.png" alt="image-20220820152628670"></p>
<p>​        把它替换一下。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820152643130.png" alt="image-20220820152643130"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820152717623.png" alt="image-20220820152717623"></p>
<p>​        这张图的意思是，假设现在有一个socket的集合，他们的socketID分别是3,4,5,6，就把位图中对应位置置为1就可以了，现在有一个新的socket连接上来，它的ID取值是9，那么就把第9个位置置为1即可！</p>
<p>​        如果有连接退出，将其置为0即可。</p>
<p>​        Linux提供的四个宏，用于操作位图，</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820153026403.png" alt="image-20220820153026403"></p>
<blockquote>
<p>CLR：将某一个socket置为空，ISSET：判断某一个socket在集合中，SET：将某一个socket置为1，ZERO：将全局置为空。</p>
</blockquote>
<p>现在我们可以了解nfds的意义了，它是指readfds，writefds，exceptfds三个位图中，最大的那个，也就是整个图有多大，exceptfds填NULL就行了，后面发展的模型都没用他了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化服务端用于监听的socket。</span></span><br><span class="line"><span class="keyword">int</span> listensock = <span class="built_in">initserver</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listensock=%d\n&quot;</span>,listensock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (listensock &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;initserver() failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">fd_set readfds;        <span class="comment">// 读事件socket的集合，包括监听socket和客户端连接上来的socket。</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;readfds);     <span class="comment">// 初始化读事件socket的集合。</span></span><br><span class="line"><span class="built_in">FD_SET</span>(listensock,&amp;readfds); <span class="comment">// 把listensock添加到读事件socket的集合中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxfd=listensock;        <span class="comment">// 记录集合中socket的最大值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 事件：1)新客户端的连接请求accept；2)客户端有报文到达recv，可以读；3)客户端连接已断开；</span></span><br><span class="line">  <span class="comment">//       4)可以向客户端发送报文send，可以写。可写事件可以简单理解为缓冲区没满，就可以写</span></span><br><span class="line">  <span class="comment">// 可读事件  可写事件</span></span><br><span class="line">  <span class="comment">// select() 等待事件的发生(监视哪些socket发生了事件)。</span></span><br><span class="line"></span><br><span class="line">  fd_set tmpfds=readfds;</span><br><span class="line">  <span class="comment">// 不能把readfds直接给他，我们后面要处理，需要保留，因此用副本 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span>    timeout.tv_sec=<span class="number">10</span>; timeout.tv_usec=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> infds=<span class="built_in">select</span>(maxfd+<span class="number">1</span>,&amp;tmpfds,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;timeout); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回失败。</span></span><br><span class="line">  <span class="keyword">if</span> (infds &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ERRORS</span></span><br><span class="line">    <span class="comment">//  EBADF  An  invalid  file descriptor was given in one of the sets.  (Perhaps a file descriptor that was already closed, or one on</span></span><br><span class="line">    <span class="comment">//         which an error has occurred.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  EINTR  A signal was caught; see signal(7).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  EINVAL nfds is negative or the value contained within timeout is invalid.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  ENOMEM unable to allocate memory for internal tables.</span></span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;select() failed&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时，在本程序中，select函数最后一个参数为空，不存在超时的情况，但以下代码还是留着。</span></span><br><span class="line">  <span class="keyword">if</span> (infds == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;select() timeout.\n&quot;</span>); <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果infds&gt;0，表示有事件发生的socket的数量。</span></span><br><span class="line">  <span class="comment">// ISSET检查位图每一位。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> eventfd=<span class="number">0</span>;eventfd&lt;=maxfd;eventfd++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(eventfd,&amp;tmpfds)&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;   <span class="comment">// 如果没有事件，continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生事件的是listensock，表示有新的客户端连上来。</span></span><br><span class="line">    <span class="keyword">if</span> (eventfd==listensock)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">      <span class="keyword">socklen_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(client);</span><br><span class="line">      <span class="keyword">int</span> clientsock = <span class="built_in">accept</span>(listensock,(struct sockaddr*)&amp;client,&amp;len);</span><br><span class="line">      <span class="keyword">if</span> (clientsock &lt; <span class="number">0</span>) &#123; <span class="built_in">perror</span>(<span class="string">&quot;accept() failed&quot;</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;accept client(socket=%d) ok.\n&quot;</span>,clientsock);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把新客户端的socket加入可读socket的集合。</span></span><br><span class="line">      <span class="built_in">FD_SET</span>(clientsock,&amp;readfds);</span><br><span class="line">      <span class="keyword">if</span> (maxfd&lt;clientsock) maxfd=clientsock;    <span class="comment">// 更新maxfd的值。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果是客户端连接的socket有事件，表示有报文发过来或者连接已断开。</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// 存放从客户端读取的数据。</span></span><br><span class="line">      <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">recv</span>(eventfd,buffer,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>)&lt;=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果客户端的连接已断开。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client(eventfd=%d) disconnected.\n&quot;</span>,eventfd);</span><br><span class="line">        <span class="built_in">close</span>(eventfd);            <span class="comment">// 关闭客户端的socket</span></span><br><span class="line">        <span class="built_in">FD_CLR</span>(eventfd,&amp;readfds);  <span class="comment">// 把已关闭客户端的socket从可读socket的集合中删除。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新计算maxfd的值，注意，只有当eventfd==maxfd时才需要计算。</span></span><br><span class="line">        <span class="keyword">if</span> (eventfd == maxfd)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> ii=maxfd;ii&gt;<span class="number">0</span>;ii--)  <span class="comment">// 从后面往前找。</span></span><br><span class="line">          <span class="comment">// 相比于从前往后找，这是一个聪明的办法。</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(ii,&amp;readfds))</span><br><span class="line">            &#123;</span><br><span class="line">              maxfd = ii; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果客户端有报文发过来。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv(eventfd=%d):%s\n&quot;</span>,eventfd,buffer);</span><br><span class="line">        <span class="comment">// 把接收到的报文内容原封不动的发回去。</span></span><br><span class="line">        fd_set tmpfds;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;tmpfds);</span><br><span class="line">        <span class="built_in">FD_SET</span>(eventfd,&amp;tmpfds);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">select</span>(eventfd+<span class="number">1</span>,<span class="literal">NULL</span>,&amp;tmpfds,<span class="literal">NULL</span>,<span class="literal">NULL</span>)&lt;=<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">perror</span>(<span class="string">&quot;select() failed&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">send</span>(eventfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于时间关系，剩下的select和poll，后面再聊了</p>
<h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820160705048.png" alt="image-20220820160705048"></p>
<p>​        创造句柄，类似于select的bit map，注册事件，意思是告诉socket需要监视那些事件，接下来调用wait等待事件的发生。</p>
<h2 id="十五、课程总结"><a href="#十五、课程总结" class="headerlink" title="十五、课程总结"></a>十五、课程总结</h2><h3 id="非结构化数据存储方案"><a href="#非结构化数据存储方案" class="headerlink" title="非结构化数据存储方案"></a>非结构化数据存储方案</h3><p>​        总的来说，没有最好的方案，只有最合适的方案。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/PIPJIN961111/article/details/102664666">https://blog.csdn.net/PIPJIN961111/article/details/102664666</a></p>
</blockquote>
<p>结构化与半结构化与非结构化数据<br>1.结构化数据<br>        结构化的数据是指可以使用关系型数据库表示存储，表现为二维形式的数据。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id      name    age     gender</span><br><span class="line">1       lyh     12      male</span><br><span class="line">2       liangyh 13      female</span><br><span class="line">3       liang   18      male</span><br></pre></td></tr></table></figure>

<p>所以，结构化的数据的存储和排列是很有规律的，这对查询和修改等操作很有帮助</p>
<p>​        但是它的扩展性不好，比如需要的时候加个字段，在实际运用中每次都进行反复的表结构变更，这容易导致后台接口从数据库取数据出错。</p>
<p>2.半结构化数据</p>
<p>​        半结构是有点勉强的说法，可以当做结构化，也可以当做非结构化，这里我们当做非结构化。</p>
<p>​        半结构化数据是结构化数据的一种形式，它并不符合关系型数据库或其他数据表的形式关联起来的数据模型结构，但包含相关标记，用来分隔语义元素以及对记录和字段进行分层。因此，它也被称为自描述的结构。</p>
<p>​        半结构化数据，属于同一类实体可以有不同的属性，即使他们被组合在一起，这些属性的顺序并不重要。</p>
<p>常见的半结构数据有XML和JSON，对于XML文件，例如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>A<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>13<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        从上面的例子中，属性的顺序是不重要的，不同的半结构化数据的属性的个数是不一定一样的。</p>
<p>​        标签是树的根节点，和`标签是子节点。通过这样的数据格式，可以自由地表达很多有用的信息，包括自我描述信息（元数据）。所以，半结构化数据的扩展性是很好的。</p>
<p>3.非结构化数据</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820165934876.png" alt="image-20220820165934876"></p>
<p>​        非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据。包括所有格式的办公文档、文本、图片、各类报表、图像和音频/视频信息等等。</p>
<p>hbase数据库是一个NoSql(Not Only SQL，泛指非关系型数据库)。</p>
<p>Hbase是一个分布式的、面向列，运行在HDFS上的数据库</p>
<p>适合存储访问超大规模的数据集,可以提供数据的实时随机读写</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="*方案一"></a>*方案一</h4><blockquote>
<p>*意味着用的多</p>
</blockquote>
<p>方便简洁，我们还有文件同步程序，快速实现同步功能。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170240310.png" alt="image-20220820170240310"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170317243.png" alt="image-20220820170317243"></p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="*方案二"></a>*方案二</h4><p>如果非结构化数据很少，也可以用啊</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170505565.png" alt="image-20220820170505565"></p>
<p>数据量大其实也可以用，具体要采用BOLB缓存技术</p>
<h5 id="BLOB缓存"><a href="#BLOB缓存" class="headerlink" title="BLOB缓存"></a>BLOB缓存</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820171255630.png" alt="image-20220820171255630"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820171342790.png" alt="image-20220820171342790"></p>
<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>如果软件有价值，这种方案肯定最合适</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170536728.png" alt="image-20220820170536728"></p>
<h4 id="方案四"><a href="#方案四" class="headerlink" title="*方案四"></a>*方案四</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170605869.png" alt="image-20220820170605869"></p>
<h4 id="方案五"><a href="#方案五" class="headerlink" title="方案五"></a>方案五</h4><p>至少90%的企业和政府是没有大数据的，用不上这个东西</p>
<p>总的来说HDFS是个好东西（分布式文件系统），适用于大数据，普通的小项目没必要用。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170634861.png" alt="image-20220820170634861"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170708653.png" alt="image-20220820170708653"></p>
<h4 id="方案六"><a href="#方案六" class="headerlink" title="方案六"></a>方案六</h4><p>哪些所谓的云存储，都是建立在别人的基础上搭建的虚拟平台而已，没什么好特别的。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820170836000.png" alt="image-20220820170836000"></p>
<h3 id="数据中心辅助模块"><a href="#数据中心辅助模块" class="headerlink" title="数据中心辅助模块"></a>数据中心辅助模块</h3><p>通常没什么人用，就自己用。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820185252645.png" alt="image-20220820185252645"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820190047900.png" alt="image-20220820190047900"></p>
<p>一个朴素的页面，拓展知识就好。</p>
<h4 id="实时同步"><a href="#实时同步" class="headerlink" title="实时同步"></a>实时同步</h4><p>早期采用。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820190137280.png" alt="image-20220820190137280"></p>
<h4 id="服务器资源信息获取"><a href="#服务器资源信息获取" class="headerlink" title="服务器资源信息获取"></a>服务器资源信息获取</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820190315492.png" alt="image-20220820190315492"></p>
<h3 id="数据表的设计技巧"><a href="#数据表的设计技巧" class="headerlink" title="数据表的设计技巧"></a>数据表的设计技巧</h3><blockquote>
<p>J:\11Projectc++\课程文档(1)\oracle数据库\37.索引的本质与SQL优化.docx</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820190552276.png" alt="image-20220820190552276"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820191211366.png" alt="image-20220820191211366"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820190803801.png" alt="image-20220820190803801"></p>
<p>​        例如我们在这里产生了外键，其实可以采取移除外键，并用更多相同的变量名来定位，外键保证了数据的完整性，但是也增加了数据库的开销，另外从观测数据表中读取数据的时候往往也需要全国站点参数中把站点名称，经纬度，海拔高度取出来。可以使用关联查询，但是这种方式也肯定比单表查询要慢。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820191115041.png" alt="image-20220820191115041"></p>
<p>​        可以设计成这样，这样会浪费磁盘空间，但现在的社会磁盘空间已经不值钱了。另外也不能保证数据的完整性，但是只要应用程序不乱搞通常也无大碍。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820200314523.png" alt="image-20220820200314523"></p>
<blockquote>
<p>最好delete都不要，只insert</p>
</blockquote>
<p>解决问题的办法就是，将更新一个表的操作，转换为insert一个表的操作（多个用户操作一个表，必然update存在竞争）</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820200522656.png" alt="image-20220820200522656"></p>
<p>当遇到七天过后还没签收之类的客户，肯定不能用常规的操作处理了</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820200841356.png" alt="image-20220820200841356"></p>
<p>我们可以考虑把它的信息做成归档表，其中，物流信息用xml或者json等格式来存放就好</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820200759255.png" alt="image-20220820200759255"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820200938523.png" alt="image-20220820200938523"></p>
<h3 id="触发器、自定义函数和存储过程"><a href="#触发器、自定义函数和存储过程" class="headerlink" title="触发器、自定义函数和存储过程"></a>触发器、自定义函数和存储过程</h3><p>数据库是项目的瓶颈，能不让他去做，就不让他去做。另外它的编程语言也比较菜=-=</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820201033569.png" alt="image-20220820201033569"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820201651735.png" alt="image-20220820201651735"></p>
<p>触发器也是以前用的多，只要框架里有的，都可以不用，下面这就是用于兼容问题的代码。<img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820201804335.png" alt="image-20220820201804335"></p>
<h3 id="数据的缓存方案"><a href="#数据的缓存方案" class="headerlink" title="数据的缓存方案"></a>数据的缓存方案</h3><p>数据为什么要缓存？</p>
<p>还是因为数据库太慢，Redis和Memcache做缓存已经不是秘密。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820201934810.png" alt="image-20220820201934810"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202030801.png" alt="image-20220820202030801"></p>
<blockquote>
<p>传统数据库稳，但是不快。</p>
</blockquote>
<p>​        但是有的时候Redis和Memcache也不能很好得装下大量的数据，这时候，文件缓存不失为一种很好的解决办法。</p>
<p>​        第一级是年月（记录存放一个月）第二级是每个城市的号码段，第三极目录是号码的数字，每个txt存放了这一个月的详单文件。详单内容按时间排序，再写一个TCP程序提供详单查询，采用HTTP协议，就像数据服务总线一样。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202221901.png" alt="image-20220820202221901"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202500235.png" alt="image-20220820202500235"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202546243.png" alt="image-20220820202546243"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202557782.png" alt="image-20220820202557782"></p>
<h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><p><strong>求职面试过程</strong></p>
<h4 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202845478.png" alt="image-20220820202845478"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202901263.png" alt="image-20220820202901263"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820202935401.png" alt="image-20220820202935401"></p>
<h4 id="项目介绍实例"><a href="#项目介绍实例" class="headerlink" title="项目介绍实例"></a>项目介绍实例</h4><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203011421.png" alt="image-20220820203011421"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203030339.png" alt="image-20220820203030339"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203102902.png" alt="image-20220820203102902"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203128068.png" alt="image-20220820203128068"></p>
<h4 id="获取项目背景资源"><a href="#获取项目背景资源" class="headerlink" title="获取项目背景资源"></a>获取项目背景资源</h4><p>我们如何打造这样一个介绍呢？</p>
<p>从这些地方找</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203209070.png" alt="image-20220820203209070"></p>
<h5 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h5><p>这些是能在网上找到的项目截图。</p>
<p>也要记得去门户网站和官网看</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203250553.png" alt="image-20220820203250553"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203315671.png" alt="image-20220820203315671"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203331465.png" alt="image-20220820203331465"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203347923.png" alt="image-20220820203347923"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203402680.png" alt="image-20220820203402680"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203453795.png" alt="image-20220820203453795"></p>
<h5 id="招标平台"><a href="#招标平台" class="headerlink" title="招标平台"></a>招标平台</h5><p>搜索关键字：：</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203928254.png" alt="image-20220820203928254"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203648358.png" alt="image-20220820203648358"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820203809767.png" alt="image-20220820203809767"></p>
<h5 id="数据开放平台"><a href="#数据开放平台" class="headerlink" title="数据开放平台"></a>数据开放平台</h5><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820204122929.png" alt="image-20220820204122929"></p>
<p>另外，这个项目和我们课程中的项目实在是太像了，课程开发的不需要任何修改，都能满足80%以上的需求。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820204330999.png" alt="image-20220820204330999"></p>
<h4 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h4><p>后台，三四个，前端，三四个啥的，打错了没关系，但不能吞吞吐吐。</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820204622543.png" alt="image-20220820204622543"></p>
<blockquote>
<p>优化工作就是指：比如以前对每一种程序编写一个入库程序，后来，我采用读取数据字典，采用XML这种方法，做成了通用的功能。</p>
<p>另外，负责通用模块开发，对具体业务不太熟，可以推掉很多问题，不知道有多少种数据，有多少数据量都可以理解，但是技术的细节，一定要清楚。</p>
</blockquote>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820204707801.png" alt="image-20220820204707801"></p>
<p>如果还不够，我们还可以新增一个APP项目</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820204944682.png" alt="image-20220820204944682"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820204957663.png" alt="image-20220820204957663"></p>
<p>​        我们把APP下载下来，每个功能都用一下，非常简单。APP软件功能一般都非常简单，采用HTTP或者自定义TCP协议都可以，</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820205053745.png" alt="image-20220820205053745"></p>
<p>另外想好面试官可能的提问，例如：</p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820205114772.png" alt="image-20220820205114772"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820205140249.png" alt="image-20220820205140249"></p>
<h1 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h1><p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820205246923.png" alt="image-20220820205246923"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820205404838.png" alt="image-20220820205404838"></p>
<p><img src="/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220820205517051.png" alt="image-20220820205517051"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:jjyaoao@126.com">jjyaoao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jjyaoao.space/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">http://jjyaoao.space/2022/04/15/C++%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jjyaoao.space" target="_blank">jjyaoao's Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%81%97%E5%BF%98%E6%8C%87%E5%8D%97/">遗忘指南</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">项目实战</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-61dbf69078ce19aa" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/01/09/HMjygFAKr2nPWdJ.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/01/09/HMjygFAKr2nPWdJ.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/01/09/JL43sbhxUEOuVeM.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/01/09/JL43sbhxUEOuVeM.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络第一章</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/15/Linux%E5%AD%A6%E4%B9%A0/"><img class="next-cover" src="https://s2.loli.net/2022/04/15/FltTRVUfbzYIowQ.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/17/22%E5%B9%B4%E5%A4%87%E6%88%98%E6%95%B0%E6%A8%A1%E5%9B%BD%E8%B5%9B/" title="2022备战国赛"><img class="cover" src="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-17</div><div class="title">2022备战国赛</div></div></a></div><div><a href="/2022/09/15/Cmake+Vscode+C++%E5%BC%80%E5%8F%91/" title="Cmake+vscode+C++"><img class="cover" src="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-15</div><div class="title">Cmake+vscode+C++</div></div></a></div><div><a href="/2022/09/10/Git/" title="Git"><img class="cover" src="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-10</div><div class="title">Git</div></div></a></div><div><a href="/2022/08/23/Geatpy-python%E4%BC%98%E5%8C%96%E5%BA%93/" title="Geatpy-python优化库"><img class="cover" src="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-23</div><div class="title">Geatpy-python优化库</div></div></a></div><div><a href="/2022/04/15/Linux%E5%AD%A6%E4%B9%A0/" title="Linux学习"><img class="cover" src="https://s2.loli.net/2022/04/15/FltTRVUfbzYIowQ.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="title">Linux学习</div></div></a></div><div><a href="/2022/05/30/MySQL%E4%BD%BF%E7%94%A8/" title="MySQL使用"><img class="cover" src="https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-30</div><div class="title">MySQL使用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTM1OC8zMTgyNQ=="></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%9D%BF%E5%9D%97-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">第一板块-如何开发永不停机的服务程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.</span> <span class="toc-text">章节内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E9%87%8D%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">后台开发的重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.2.</span> <span class="toc-text">程序的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">永不停机的服务程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">章节任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">生成测试数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">服务程序的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">守护进程的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%B0%8F%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.4.</span> <span class="toc-text">两个常见小工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.</span> <span class="toc-text">一：生成测试数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">小结任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%9B%BD%E6%B0%94%E8%B1%A1%E7%AB%99%E7%82%B9%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">全国气象站点参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%9B%BD%E6%B0%94%E8%B1%A1%E5%88%86%E9%92%9F%E8%A7%82%E6%B5%8B%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">全国气象分钟观测数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">1.3.4.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%EF%BC%9A%E6%90%AD%E5%BB%BA%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">①：搭建程序框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%EF%BC%9A%E5%8A%A0%E8%BD%BD%E7%AB%99%E7%82%B9%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">②：加载站点参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%EF%BC%9A%E6%A8%A1%E6%8B%9F%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.7.</span> <span class="toc-text">③：模拟观测数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%EF%BC%9A%E6%8A%8A%E7%AB%99%E7%82%B9%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.8.</span> <span class="toc-text">④：把站点观测数据写入文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">有漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">正确的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csv-xml-json"><span class="toc-number">1.3.9.</span> <span class="toc-text">csv,xml,json</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E5%BA%A6%E8%B6%85%E7%BA%A7%E5%A5%B3%E7%94%9F"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">再度超级女生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xml%E4%B8%8Ejson%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">xml与json比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">1.3.9.2.1.</span> <span class="toc-text">可读性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-number">1.3.9.2.2.</span> <span class="toc-text">可扩展性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E9%9A%BE%E5%BA%A6"><span class="toc-number">1.3.9.2.3.</span> <span class="toc-text">编码难度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.9.2.4.</span> <span class="toc-text">实例比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">二、服务程序的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.4.1.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%BC%95%E5%85%A5%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">实例引入信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">第一次优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BF%A1%E5%8F%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">1、信号基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">2、信号的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">3、信号的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BF%A1%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">4、信号有什么用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BF%A1%E5%8F%B7%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">5、信号应用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">6、发送信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">Linux多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-2%E5%8F%B7%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">0-1-2号进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">进程标识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">查看进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">获取进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">程序中创建进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%811%E3%80%812%E5%8F%A5"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">验证1、2句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%813%E3%80%814%E5%8F%A5"><span class="toc-number">1.4.2.3.2.</span> <span class="toc-text">验证3、4句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%815%E3%80%816%E5%8F%A5"><span class="toc-number">1.4.2.3.3.</span> <span class="toc-text">验证5、6句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E5%8F%A5"><span class="toc-number">1.4.2.3.4.</span> <span class="toc-text">第七句</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#fprintf"><span class="toc-number">1.4.2.3.4.1.</span> <span class="toc-text">fprintf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.4.2.4.1.</span> <span class="toc-text">僵尸进程的危害</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.4.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait"><span class="toc-number">1.4.2.4.3.</span> <span class="toc-text">wait()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E5%BA%A6-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">服务程序的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execl"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">execl()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execl-wait"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">execl()+wait()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execv"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">execv()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">1.4.3.3.1.</span> <span class="toc-text">main函数传参</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80"><span class="toc-number">1.4.3.3.1.1.</span> <span class="toc-text">解释一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%BA%8C"><span class="toc-number">1.4.3.3.1.2.</span> <span class="toc-text">解释二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">调度服务代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">三、守护进程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.5.1.</span> <span class="toc-text">Linux共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">共享内存的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shmget"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">shmget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shmat"><span class="toc-number">1.5.1.1.2.</span> <span class="toc-text">shmat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shmctl"><span class="toc-number">1.5.1.1.3.</span> <span class="toc-text">shmctl</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">Linux信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E4%BE%8B"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">引例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">信号量形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSEM%E7%B1%BB"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">CSEM类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PV"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">PV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5-%E5%88%A0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">查&#x2F;删信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%97%B6%E6%8A%A2%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">多个进程同时抢共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">信号量初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.5.2.7.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E9%80%A0%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.2.7.2.</span> <span class="toc-text">创造具体过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#PV%E6%93%8D%E4%BD%9C%E5%86%8D%E6%B7%B1%E5%85%A5"><span class="toc-number">1.5.2.7.2.1.</span> <span class="toc-text">PV操作再深入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sem-flg%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.2.7.2.2.</span> <span class="toc-text">sem_flg用法解析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">守护进程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">心跳机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">实现目标</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#STRCPY"><span class="toc-number">1.5.3.1.1.1.</span> <span class="toc-text">STRCPY()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">心跳实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">守护程序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6%E5%91%88%E7%8E%B0"><span class="toc-number">1.5.3.2.1.</span> <span class="toc-text">总体框架呈现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.3.2.2.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#kill-pid-0"><span class="toc-number">1.5.3.2.2.1.</span> <span class="toc-text">kill(pid, 0)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#exit%E4%B8%8E%E6%9E%90%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.3.2.2.2.</span> <span class="toc-text">exit与析构的关系</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%8C%E5%96%84%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">四、完善生成测试数据程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">生成历史数据文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.6.2.</span> <span class="toc-text">处理信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit%E6%9C%AA%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">exit未调用析构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tmp"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">&#x2F;tmp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BF%83%E8%B7%B3"><span class="toc-number">1.6.4.</span> <span class="toc-text">进程的心跳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E6%95%B0%E6%8D%AE%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.5.</span> <span class="toc-text">最终数据程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7"><span class="toc-number">1.7.</span> <span class="toc-text">五、开发常用小工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97"><span class="toc-number">1.7.1.</span> <span class="toc-text">压缩文件模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">开发框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E4%BF%A1%E5%8F%B7%E5%92%8CIO"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">关闭信号和IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">与超时时间点比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">压缩文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CDir"><span class="toc-number">1.7.1.4.1.</span> <span class="toc-text">CDir</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#OpenDir"><span class="toc-number">1.7.1.4.1.1.</span> <span class="toc-text">OpenDir()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SetDateFMT"><span class="toc-number">1.7.1.4.1.2.</span> <span class="toc-text">SetDateFMT()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MatchStr"><span class="toc-number">1.7.1.4.2.</span> <span class="toc-text">MatchStr()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#system"><span class="toc-number">1.7.1.4.3.</span> <span class="toc-text">system()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.1.4.4.</span> <span class="toc-text">压缩文件实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">清理历史数据文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#remove"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REMOVE"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">REMOVE()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RENAME"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">RENAME()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.</span> <span class="toc-text">六、服务程序的运行策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E8%B6%85%E6%97%B6"><span class="toc-number">2.</span> <span class="toc-text">检查服务程序是否超时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">启动数据中心的后台服务程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E8%84%9A%E6%9C%AC"><span class="toc-number">3.1.</span> <span class="toc-text">设置开机自启脚本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%9D%BF%E5%9D%97-%E5%9F%BA%E4%BA%8Eftp%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">第二板块-基于ftp协议的文件传输系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E5%86%85%E5%AE%B9-1"><span class="toc-number">4.1.</span> <span class="toc-text">章节内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ftp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">一、ftp基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%81%E8%A3%85"><span class="toc-number">4.1.2.</span> <span class="toc-text">二、ftp客户端封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">三、文件下载功能实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.4.</span> <span class="toc-text">四、文件上传功能实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ftp%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%97%B6%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">ftp协议是否过时？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ftp%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.3.</span> <span class="toc-text">ftp查看状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81FTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.4.</span> <span class="toc-text">一、FTP基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FTP%E7%AE%80%E4%BB%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">FTP简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FTP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.2.</span> <span class="toc-text">FTP工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">传输模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%81%E8%A3%85-1"><span class="toc-number">4.5.</span> <span class="toc-text">二、ftp客户端封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.5.1.</span> <span class="toc-text">基本连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95size-time"><span class="toc-number">4.5.2.</span> <span class="toc-text">测试size(),time()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95nlist"><span class="toc-number">4.5.3.</span> <span class="toc-text">测试nlist() </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD"><span class="toc-number">4.5.4.</span> <span class="toc-text">上传下载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">get()具体细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82"><span class="toc-number">4.5.4.2.</span> <span class="toc-text">put()具体细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-put%E5%B7%AE%E5%BC%82"><span class="toc-number">4.5.4.3.</span> <span class="toc-text">get&#x2F;put差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-put%E6%B5%8B%E8%AF%95"><span class="toc-number">4.5.4.4.</span> <span class="toc-text">get&#x2F;put测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.6.</span> <span class="toc-text">三、文件下载功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">4.6.1.</span> <span class="toc-text">makefile问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%B8%80"><span class="toc-number">4.6.2.</span> <span class="toc-text">目标一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">打开日志文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90xml"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">解析xml</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">存放目录的细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82"><span class="toc-number">4.6.2.4.</span> <span class="toc-text">下载文件的一个细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%89%A9%E5%85%85"><span class="toc-number">4.6.3.</span> <span class="toc-text">目标扩充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">删除&#x2F;备份文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">增量下载文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F-%E4%BF%AE%E6%94%B9%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.3.3.</span> <span class="toc-text">增量+修改下载文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.6.3.4.</span> <span class="toc-text">收尾工作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%A3%E4%BA%9B%E7%A8%8B%E5%BA%8F%E4%BC%9A%E6%8C%82%E6%AD%BB%EF%BC%9F"><span class="toc-number">4.6.3.4.1.</span> <span class="toc-text">那些程序会挂死？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.7.</span> <span class="toc-text">四、文件上传的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%AF%B9%E6%AF%94"><span class="toc-number">4.7.1.</span> <span class="toc-text">上传 &#x2F; 下载的步骤对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">4.7.2.</span> <span class="toc-text">上传和下载的不同：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%88%E4%B8%80%E4%B8%AA%E6%9D%83%E9%99%90%E5%B0%8F%E7%BB%86%E8%8A%82"><span class="toc-number">4.7.3.</span> <span class="toc-text">又一个权限小细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.</span> <span class="toc-text">学习总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%9D%BF%E5%9D%97-%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">第三板块-基于TCP协议的文件传输系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81socket%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.1.</span> <span class="toc-text">一、socket基础知识学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B0%81%E8%A3%85socket%E7%9A%84API"><span class="toc-number">5.2.</span> <span class="toc-text">二、封装socket的API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E5%92%8C%E5%88%86%E5%8C%85"><span class="toc-number">5.2.1.</span> <span class="toc-text">粘包和分包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">分包和粘包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%88%86%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">TCP分包的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">TCP粘包的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.2.1.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E5%88%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85%E5%8E%9F%E7%90%86%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="toc-number">5.2.2.</span> <span class="toc-text">TCP的分包与粘包原理的简单理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85-%E5%88%86%E5%8C%85%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">解决粘包&#x2F;分包常用方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.2.3.</span> <span class="toc-text">粘包实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="toc-number">5.2.4.</span> <span class="toc-text">TCP协议的保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E6%96%B9%E6%A1%88"><span class="toc-number">5.2.5.</span> <span class="toc-text">解决粘包方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8ASCII%E7%A0%81"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">采用ASCII码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E6%95%B4%E5%9E%8B"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">采用整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TcpWrite-TcpRead"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">TcpWrite()&#x2F;TcpRead()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TcpWrite"><span class="toc-number">5.2.5.3.1.</span> <span class="toc-text">TcpWrite()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Writen"><span class="toc-number">5.2.5.3.1.1.</span> <span class="toc-text">Writen()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TcpRead"><span class="toc-number">5.2.5.3.2.</span> <span class="toc-text">TcpRead()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Readn"><span class="toc-number">5.2.5.3.2.1.</span> <span class="toc-text">Readn()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.6.</span> <span class="toc-text">socket封装函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CTcpClient"><span class="toc-number">5.2.6.1.</span> <span class="toc-text">CTcpClient()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConnectToServer"><span class="toc-number">5.2.6.1.1.</span> <span class="toc-text">ConnectToServer()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%8F%E8%94%BD%E4%B8%8E%E5%90%A6SIGPIPE%E6%BC%94%E7%A4%BA"><span class="toc-number">5.2.6.1.1.1.</span> <span class="toc-text">屏蔽与否SIGPIPE演示</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Read"><span class="toc-number">5.2.6.1.2.</span> <span class="toc-text">Read()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BD%99%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.6.1.3.</span> <span class="toc-text">其余函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CTcpServer"><span class="toc-number">5.2.6.2.</span> <span class="toc-text">CTcpServer()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#InitServer"><span class="toc-number">5.2.6.2.1.</span> <span class="toc-text">InitServer()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%97%ADsocket"><span class="toc-number">5.2.6.2.2.</span> <span class="toc-text">关闭socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.2.7.</span> <span class="toc-text">网络字节序与主机字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%A4%A7%E7%AB%AF%E3%80%81%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.2.7.1.</span> <span class="toc-text">1、大端、小端字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.2.7.2.</span> <span class="toc-text">2、网络字节序和主机字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.2.7.3.</span> <span class="toc-text">3、IP地址的三种表示格式及在开发中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81inet-aton-%E3%80%81inet-addr-%E5%92%8Cinet-ntoa-%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.7.4.</span> <span class="toc-text">4、inet_aton()、inet_addr()和inet_ntoa()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80-%E7%BD%91%E7%BB%9C-%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.2.8.</span> <span class="toc-text">C语言-网络&#x2F;主机字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.2.8.1.</span> <span class="toc-text">如何判断字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.2.8.2.</span> <span class="toc-text">二、网络字节序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipv4-ipv6"><span class="toc-number">5.2.9.</span> <span class="toc-text">ipv4&#x2F;ipv6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIPv4%E5%92%8CIPv6%EF%BC%9F"><span class="toc-number">5.2.9.1.</span> <span class="toc-text">什么是IPv4和IPv6？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv4%E5%92%8CIPv6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.9.2.</span> <span class="toc-text">IPv4和IPv6之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv4%E6%88%96IPv6%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">5.2.9.3.</span> <span class="toc-text">IPv4或IPv6：使用哪个？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv4%E4%B8%8EIPv6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">5.2.9.4.</span> <span class="toc-text">IPv4与IPv6的安全性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">5.3.</span> <span class="toc-text">三、多进程的网络服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">主体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">基础实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E4%BC%98%E5%8C%96"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">再优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">新的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fork%E4%B8%80%E7%82%B9%E7%82%B9%E8%A1%A5%E5%85%85%EF%BC%9A"><span class="toc-number">5.3.1.3.1.</span> <span class="toc-text">fork一点点补充：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F-%E7%AB%AF-%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-number">5.3.1.4.</span> <span class="toc-text">多进程网络服务程序(端)的退出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%86%8D%E6%B7%B1%E5%85%A5"><span class="toc-number">5.3.1.4.1.</span> <span class="toc-text">问题再深入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA"><span class="toc-number">5.3.1.4.2.</span> <span class="toc-text">讨论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kill"><span class="toc-number">5.3.1.4.3.</span> <span class="toc-text">kill()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%93%B6APP%E8%BD%AF%E4%BB%B6%E4%B8%9A%E5%8A%A1"><span class="toc-number">5.3.2.</span> <span class="toc-text">网银APP软件业务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">网络通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">业务实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.3.2.2.1.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1"><span class="toc-number">5.3.2.2.1.1.</span> <span class="toc-text">登录业务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%9A%E5%8A%A1"><span class="toc-number">5.3.2.2.1.2.</span> <span class="toc-text">查询业务</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">5.3.2.2.2.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1-1"><span class="toc-number">5.3.2.2.2.1.</span> <span class="toc-text">登录业务</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.3.3.</span> <span class="toc-text">Tcp长连接，短连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">5.5.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">长连接与短连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-number">5.6.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.6.0.1.</span> <span class="toc-text">长连接与短连接的操作过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-3"><span class="toc-number">5.7.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.7.0.1.</span> <span class="toc-text">什么时候用长连接，短连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-4"><span class="toc-number">5.8.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tcp%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.8.0.1.</span> <span class="toc-text">Tcp短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tcp%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.8.0.2.</span> <span class="toc-text">Tcp长连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">5.8.0.2.1.</span> <span class="toc-text">Tcp长连接心跳机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%BB%8F%E9%AA%8C"><span class="toc-number">5.8.0.2.1.1.</span> <span class="toc-text">应用经验</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%9F%BA%E4%BA%8ETcp%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.9.</span> <span class="toc-text">四、基于Tcp协议的文件传输系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD"><span class="toc-number">5.9.1.</span> <span class="toc-text">文件上传功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exit%E4%B8%8Ereturn"><span class="toc-number">5.9.1.1.</span> <span class="toc-text">exit与return</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">5.9.1.2.</span> <span class="toc-text">文件上传服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.9.1.3.</span> <span class="toc-text">文件上传客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">5.9.1.4.</span> <span class="toc-text">上传文件内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-number">5.9.1.4.1.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E6%A1%86%E6%9E%B6"><span class="toc-number">5.9.1.4.1.1.</span> <span class="toc-text">主框架</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sendfile"><span class="toc-number">5.9.1.4.1.2.</span> <span class="toc-text">sendfile()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-number">5.9.1.4.2.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RecvFile"><span class="toc-number">5.9.1.4.2.1.</span> <span class="toc-text">RecvFile()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%8E%E8%BD%AC%E5%AD%98%E6%96%87%E4%BB%B6"><span class="toc-number">5.9.1.5.</span> <span class="toc-text">删除与转存文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E2%80%93%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">5.9.2.</span> <span class="toc-text">同步–异步通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">5.9.2.1.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">5.9.2.2.</span> <span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.9.2.2.1.</span> <span class="toc-text">异步通信的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.9.2.2.1.1.</span> <span class="toc-text">多进程实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E6%BC%94%E7%A4%BA"><span class="toc-number">5.9.2.2.1.2.</span> <span class="toc-text">IO复用演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E5%BC%82%E6%AD%A5"><span class="toc-number">5.9.2.3.</span> <span class="toc-text">文件上传(异步)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B6%E5%B0%BE-%E4%BC%98%E5%8C%96"><span class="toc-number">5.9.2.3.1.</span> <span class="toc-text">收尾+优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E4%BC%98%E5%8C%96"><span class="toc-number">5.9.2.3.1.1.</span> <span class="toc-text">时间间隔优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E4%BC%98%E5%8C%96"><span class="toc-number">5.9.2.3.1.2.</span> <span class="toc-text">心跳优化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="toc-number">5.9.3.</span> <span class="toc-text">文件下载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.10.</span> <span class="toc-text">学习总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">5.10.1.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91"><span class="toc-number">5.11.</span> <span class="toc-text">五、MySQL数据库开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%BB%BA%E5%BA%93"><span class="toc-number">5.11.1.</span> <span class="toc-text">MySQL建库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">5.11.2.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">5.11.3.</span> <span class="toc-text">查询数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.11.4.</span> <span class="toc-text">二进制大对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E7%9A%84%E5%90%AF%E7%A4%BA"><span class="toc-number">5.11.4.1.</span> <span class="toc-text">大对象操作的启示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E6%8A%80%E5%B7%A7"><span class="toc-number">5.11.5.</span> <span class="toc-text">数据库开发注意事项和技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.11.5.1.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">5.11.5.2.</span> <span class="toc-text">应用技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%A4%A7%E7%9A%84PowerDesigner"><span class="toc-number">5.11.6.</span> <span class="toc-text">强大的PowerDesigner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%99%E7%82%B9%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6%E5%85%A5%E5%BA%93"><span class="toc-number">5.11.7.</span> <span class="toc-text">站点参数文件入库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-number">5.11.7.1.</span> <span class="toc-text">业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%88%98%E6%96%97"><span class="toc-number">5.11.7.2.</span> <span class="toc-text">开始战斗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E8%BF%9B%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">5.11.7.3.</span> <span class="toc-text">心跳进程小技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%99%E7%82%B9%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93"><span class="toc-number">5.11.8.</span> <span class="toc-text">站点数据入库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-number">5.11.8.1.</span> <span class="toc-text">基础业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%BC%8F%E4%B8%9A%E5%8A%A1demo"><span class="toc-number">5.11.8.2.</span> <span class="toc-text">正式业务demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%9A%E5%8A%A1"><span class="toc-number">5.11.8.3.</span> <span class="toc-text">优化业务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%9A%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97%E5%86%85%E5%AE%B9"><span class="toc-number">5.11.8.3.1.</span> <span class="toc-text">任务一：优化日志内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BA%8C%EF%BC%9A%E5%A4%84%E7%90%86%E5%86%97%E4%BD%99%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.11.8.3.2.</span> <span class="toc-text">任务二：处理冗余的程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%89%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E5%88%86%E7%A6%BB"><span class="toc-number">5.11.8.3.3.</span> <span class="toc-text">任务三：程序模块分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%9B%9B%EF%BC%9A%E5%AF%B9csv%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">5.11.8.3.4.</span> <span class="toc-text">任务四：对csv格式的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82%E6%8A%A5%E9%94%99"><span class="toc-number">5.11.8.3.4.1.</span> <span class="toc-text">一个细节报错</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C"><span class="toc-number">5.11.8.4.</span> <span class="toc-text">最后收尾工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8CSQL%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">5.11.8.5.</span> <span class="toc-text">执行SQL脚本文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">5.11.8.5.1.</span> <span class="toc-text">流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BC%80%E5%8F%91%E6%95%B0%E6%8D%AE%E6%8A%BD%E5%8F%96%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.12.</span> <span class="toc-text">六、开发数据抽取子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%9B%AE%E6%A0%87"><span class="toc-number">5.12.1.</span> <span class="toc-text">开发目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%A1%86%E6%9E%B6"><span class="toc-number">5.12.2.</span> <span class="toc-text">搭建框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.12.2.1.</span> <span class="toc-text">宏结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-number">5.12.2.2.</span> <span class="toc-text">帮助文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">5.12.2.3.</span> <span class="toc-text">参数解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E4%B8%BB%E5%8A%9F%E8%83%BD"><span class="toc-number">5.12.2.4.</span> <span class="toc-text">全量抽取数据主功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number">5.12.2.4.1.</span> <span class="toc-text">进一步优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%8A%BD%E5%8F%96"><span class="toc-number">5.12.2.5.</span> <span class="toc-text">增量抽取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91-1"><span class="toc-number">5.12.2.5.1.</span> <span class="toc-text">业务逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E5%8F%96%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">5.12.2.6.</span> <span class="toc-text">数据抽取的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.12.3.</span> <span class="toc-text">学习总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.13.</span> <span class="toc-text">七、数据入库子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.13.1.</span> <span class="toc-text">数据入库的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">5.13.2.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82"><span class="toc-number">5.13.3.</span> <span class="toc-text">入库设计要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">5.13.4.</span> <span class="toc-text">数据入库基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">5.13.4.1.</span> <span class="toc-text">加载文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">5.13.4.2.</span> <span class="toc-text">查找文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%A2%91%E7%8E%87"><span class="toc-number">5.13.4.3.</span> <span class="toc-text">加载频率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E8%A1%A5%E5%85%85"><span class="toc-number">5.13.4.4.</span> <span class="toc-text">流程补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="toc-number">5.13.4.5.</span> <span class="toc-text">备份文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%85%A5%E5%BA%93%E8%BF%87%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">5.13.4.6.</span> <span class="toc-text">核心入库过程框架</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">5.13.4.6.1.</span> <span class="toc-text">新增结构体定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#allcols%E8%8E%B7%E5%8F%96%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">5.13.4.6.2.</span> <span class="toc-text">allcols获取全部字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5SQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.13.4.6.3.</span> <span class="toc-text">拼接SQL语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%91%E5%AE%9ASQL%E8%AF%AD%E5%8F%A5%E5%8F%82%E6%95%B0"><span class="toc-number">5.13.4.6.4.</span> <span class="toc-text">绑定SQL语句参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.13.4.6.5.</span> <span class="toc-text">执行SQL语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">5.13.4.7.</span> <span class="toc-text">完善与优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA"><span class="toc-number">5.13.4.8.</span> <span class="toc-text">执行错误提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">5.13.5.</span> <span class="toc-text">大量数据入库的方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">5.14.</span> <span class="toc-text">八、数据处理和统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">5.14.1.</span> <span class="toc-text">数据中心总体结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9"><span class="toc-number">5.14.2.</span> <span class="toc-text">数据处理的工作内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9"><span class="toc-number">5.14.3.</span> <span class="toc-text">数据统计的工作内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.15.</span> <span class="toc-text">九、数据同步子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">5.15.1.</span> <span class="toc-text">mysql高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%82%B9%E4%B8%8D%E8%B6%B3"><span class="toc-number">5.15.1.1.</span> <span class="toc-text">三点不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84"><span class="toc-number">5.15.2.</span> <span class="toc-text">数据架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dederated%E5%BC%95%E6%93%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">5.15.3.</span> <span class="toc-text">dederated引擎配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">5.15.3.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="toc-number">5.15.4.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">5.15.5.</span> <span class="toc-text">全表刷新功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%89%B9%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">5.15.6.</span> <span class="toc-text">分批刷新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%AD%A5%E5%88%86%E6%89%B9"><span class="toc-number">5.15.6.1.</span> <span class="toc-text">不同步分批</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97"><span class="toc-number">5.15.7.</span> <span class="toc-text">增量同步数据模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9E%E5%AD%97%E6%AE%B5%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">5.15.7.1.</span> <span class="toc-text">获取自增字段最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%AF%E7%94%A8FEDERATED%E5%BC%95%E6%93%8E"><span class="toc-number">5.15.7.2.</span> <span class="toc-text">不启用FEDERATED引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.15.8.</span> <span class="toc-text">学习总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.15.8.1.</span> <span class="toc-text">mysql触发器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">5.15.8.2.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3"><span class="toc-number">5.15.8.3.</span> <span class="toc-text">不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E7%9A%84binlog"><span class="toc-number">5.15.8.4.</span> <span class="toc-text">mysql的binlog</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.16.</span> <span class="toc-text">十、数据管理子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86"><span class="toc-number">5.16.1.</span> <span class="toc-text">数据清理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">5.16.1.1.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">5.16.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="toc-number">5.16.2.</span> <span class="toc-text">数据迁移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91"><span class="toc-number">5.17.</span> <span class="toc-text">十一、Oracle数据库开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E5%92%8Coracle%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.17.1.</span> <span class="toc-text">mysql和oracle的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">5.17.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.17.1.2.</span> <span class="toc-text">数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-number">5.17.2.</span> <span class="toc-text">Oracle开发基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.17.3.</span> <span class="toc-text">Oracle故障排除的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.17.4.</span> <span class="toc-text">用户和权限管理基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.17.5.</span> <span class="toc-text">序列生成器基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="toc-number">5.17.6.</span> <span class="toc-text">Oracle双引号单引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9"><span class="toc-number">5.17.7.</span> <span class="toc-text">数据入库子系统修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9"><span class="toc-number">5.17.8.</span> <span class="toc-text">数据清理子系统修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9"><span class="toc-number">5.17.9.</span> <span class="toc-text">数据迁移子系统修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E5%8F%96%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9"><span class="toc-number">5.17.10.</span> <span class="toc-text">数据抽取子系统修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9"><span class="toc-number">5.17.11.</span> <span class="toc-text">数据同步子系统修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">5.17.12.</span> <span class="toc-text">数据库集群方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RAC"><span class="toc-number">5.17.12.1.</span> <span class="toc-text">RAC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Guard"><span class="toc-number">5.17.12.2.</span> <span class="toc-text">Data Guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OGG"><span class="toc-number">5.17.12.3.</span> <span class="toc-text">OGG</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OGG-vs-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.17.12.3.1.</span> <span class="toc-text">OGG vs 数据同步子系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">5.17.12.4.</span> <span class="toc-text">硬件配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-DBA"><span class="toc-number">5.17.13.</span> <span class="toc-text">Oracle DBA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">5.17.14.</span> <span class="toc-text">Oracle新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E"><span class="toc-number">5.17.15.</span> <span class="toc-text">MySQL何去何从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostgreSQL%E5%8F%8A%E6%9B%B4%E5%A4%9A"><span class="toc-number">5.17.16.</span> <span class="toc-text">PostgreSQL及更多</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81linux%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.18.</span> <span class="toc-text">十二、linux线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.18.1.</span> <span class="toc-text">线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.18.1.1.</span> <span class="toc-text">线程的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.18.2.</span> <span class="toc-text">学习任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.18.3.</span> <span class="toc-text">创建简单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9D%9E%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2"><span class="toc-number">5.18.4.</span> <span class="toc-text">线程非正常终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Core-dump"><span class="toc-number">5.18.4.1.</span> <span class="toc-text">Core dump</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8A%9E%E6%B3%95"><span class="toc-number">5.18.5.</span> <span class="toc-text">终止线程的三种办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">5.18.6.</span> <span class="toc-text">线程参数的传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.18.6.1.</span> <span class="toc-text">强制转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BC%A0%E9%80%92%E5%9C%B0%E5%9D%80%E5%8F%82%E6%95%B0"><span class="toc-number">5.18.6.2.</span> <span class="toc-text">如何正确传递地址参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">5.18.6.3.</span> <span class="toc-text">传递多个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-number">5.18.6.4.</span> <span class="toc-text">线程退出状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">5.18.7.</span> <span class="toc-text">线程资源的回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AA%E5%88%86%E7%A6%BB"><span class="toc-number">5.18.7.1.</span> <span class="toc-text">线程未分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="toc-number">5.18.7.2.</span> <span class="toc-text">线程分离</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-detach"><span class="toc-number">5.18.7.2.1.</span> <span class="toc-text">pthread_detach()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">5.18.7.2.2.</span> <span class="toc-text">设置线程属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">5.18.7.2.3.</span> <span class="toc-text">阻塞</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">5.18.7.3.</span> <span class="toc-text">线程清理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E5%87%BD%E6%95%B0"><span class="toc-number">5.18.7.4.</span> <span class="toc-text">进程终止函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">5.18.7.5.</span> <span class="toc-text">线程的取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.18.8.</span> <span class="toc-text">线程和信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%81%E8%BE%BE%E5%87%BD%E6%95%B0"><span class="toc-number">5.18.8.1.</span> <span class="toc-text">进程送达函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86"><span class="toc-number">5.18.8.2.</span> <span class="toc-text">信号的更多知识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.18.9.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">5.18.9.1.</span> <span class="toc-text">什么是线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="toc-number">5.18.9.2.</span> <span class="toc-text">线程安全相关定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">5.18.9.2.1.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C11%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.18.9.2.2.</span> <span class="toc-text">C11原子类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">5.18.9.3.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">5.18.9.3.1.</span> <span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">5.18.9.3.1.1.</span> <span class="toc-text">属性</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.18.9.3.2.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">5.18.9.3.3.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">5.18.9.3.4.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.18.9.3.5.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="toc-number">5.18.9.3.6.</span> <span class="toc-text">细节说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.18.9.3.7.</span> <span class="toc-text">生产消费者模型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">5.18.9.3.7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.18.9.3.7.2.</span> <span class="toc-text">条件变量+互斥锁实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.18.9.3.7.3.</span> <span class="toc-text">信号量实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">5.18.9.4.</span> <span class="toc-text">多线程的网络服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-1"><span class="toc-number">5.18.9.4.1.</span> <span class="toc-text">线程安全</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.18.10.</span> <span class="toc-text">拓展学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.18.10.1.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">5.18.10.2.</span> <span class="toc-text">保证服务程序稳定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">5.18.10.3.</span> <span class="toc-text">异步通讯</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF"><span class="toc-number">5.19.</span> <span class="toc-text">十三、数据服务总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.19.1.</span> <span class="toc-text">HTTP协议的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">5.19.1.1.</span> <span class="toc-text">通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.19.1.2.</span> <span class="toc-text">报文格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%A4%E6%96%AD%E5%93%8D%E5%BA%94%E6%98%AF%E5%90%A6%E7%BB%93%E6%9D%9F"><span class="toc-number">5.19.1.3.</span> <span class="toc-text">客户端判断响应是否结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wget-iconv"><span class="toc-number">5.19.1.4.</span> <span class="toc-text">wget +iconv</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E6%A6%82%E5%BF%B5"><span class="toc-number">5.19.2.</span> <span class="toc-text">数据服务总线概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95demo%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.19.3.</span> <span class="toc-text">简单demo实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#url%E5%B0%8F%E6%8F%90%E7%A4%BA"><span class="toc-number">5.19.3.1.</span> <span class="toc-text">url小提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-number">5.19.4.</span> <span class="toc-text">功能需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.19.5.</span> <span class="toc-text">表的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E8%BF%9E%E6%8E%A5%E6%AF%8F%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.19.6.</span> <span class="toc-text">每连接每线程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Login"><span class="toc-number">5.19.6.1.</span> <span class="toc-text">Login()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CheckPerm"><span class="toc-number">5.19.6.2.</span> <span class="toc-text">CheckPerm()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExecSQL"><span class="toc-number">5.19.6.3.</span> <span class="toc-text">ExecSQL()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">5.19.6.4.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">5.19.6.5.</span> <span class="toc-text">优化方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">5.19.7.</span> <span class="toc-text">数据库连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">5.19.7.1.</span> <span class="toc-text">声明定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initconns"><span class="toc-number">5.19.7.2.</span> <span class="toc-text">initconns()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getconns"><span class="toc-number">5.19.7.3.</span> <span class="toc-text">getconns()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#freeconns-connection-conn"><span class="toc-number">5.19.7.4.</span> <span class="toc-text">freeconns(connection *conn)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#destroyconns"><span class="toc-number">5.19.7.5.</span> <span class="toc-text">destroyconns()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%A7%E8%83%BD"><span class="toc-number">5.19.7.6.</span> <span class="toc-text">连接池性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">5.19.7.7.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#connpool-get"><span class="toc-number">5.19.7.7.1.</span> <span class="toc-text">connpool::get()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.19.8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%9B%91%E6%8E%A7"><span class="toc-number">5.19.8.1.</span> <span class="toc-text">线程池的监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.19.8.1.1.</span> <span class="toc-text">监控线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5"><span class="toc-number">5.19.9.</span> <span class="toc-text">数据安全策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-4"><span class="toc-number">5.19.10.</span> <span class="toc-text">学习总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81IO%E5%A4%8D%E7%94%A8-amp-%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86"><span class="toc-number">5.20.</span> <span class="toc-text">十四、IO复用&amp;网络代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.20.1.</span> <span class="toc-text">select模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.20.2.</span> <span class="toc-text">epoll模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">5.21.</span> <span class="toc-text">十五、课程总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88"><span class="toc-number">5.21.1.</span> <span class="toc-text">非结构化数据存储方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">5.21.1.1.</span> <span class="toc-text">*方案一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-number">5.21.1.2.</span> <span class="toc-text">*方案二</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BLOB%E7%BC%93%E5%AD%98"><span class="toc-number">5.21.1.2.1.</span> <span class="toc-text">BLOB缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89"><span class="toc-number">5.21.1.3.</span> <span class="toc-text">方案三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E5%9B%9B"><span class="toc-number">5.21.1.4.</span> <span class="toc-text">*方案四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%94"><span class="toc-number">5.21.1.5.</span> <span class="toc-text">方案五</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E5%85%AD"><span class="toc-number">5.21.1.6.</span> <span class="toc-text">方案六</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97"><span class="toc-number">5.21.2.</span> <span class="toc-text">数据中心辅助模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">5.21.2.1.</span> <span class="toc-text">实时同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96"><span class="toc-number">5.21.2.2.</span> <span class="toc-text">服务器资源信息获取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">5.21.3.</span> <span class="toc-text">数据表的设计技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">5.21.4.</span> <span class="toc-text">触发器、自定义函数和存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="toc-number">5.21.5.</span> <span class="toc-text">数据的缓存方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C"><span class="toc-number">5.21.6.</span> <span class="toc-text">项目经验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="toc-number">5.21.6.1.</span> <span class="toc-text">一些技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.21.6.2.</span> <span class="toc-text">项目介绍实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF%E8%B5%84%E6%BA%90"><span class="toc-number">5.21.6.3.</span> <span class="toc-text">获取项目背景资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6"><span class="toc-number">5.21.6.3.1.</span> <span class="toc-text">百度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%9B%E6%A0%87%E5%B9%B3%E5%8F%B0"><span class="toc-number">5.21.6.3.2.</span> <span class="toc-text">招标平台</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0"><span class="toc-number">5.21.6.3.3.</span> <span class="toc-text">数据开放平台</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82"><span class="toc-number">5.21.6.4.</span> <span class="toc-text">其他细节</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">课程总结</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/04/15/YXoFfbxgWZIn1SM.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By jjyaoao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'cFvw1zyA64uttBS5jbYY7pwH-gzGzoHsz',
      appKey: '14rOjAUNzRyJSQt983q6gdza',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Livere' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善,感谢" data-fontsize="15px" data-random="false" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = 'zgYNWkNCSATLRhpg4';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>