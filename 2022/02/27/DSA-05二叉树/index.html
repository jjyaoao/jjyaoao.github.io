<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>二叉树 | jjyaoao's Home</title><meta name="keywords" content="DSA-05"><meta name="author" content="jjyaoao,jjyaoao@126.com"><meta name="copyright" content="jjyaoao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DSA第五章">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://jjyaoao.space/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="jjyaoao&#39;s Home">
<meta property="og:description" content="DSA第五章">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/02/27/kLgRpw2FjGySiKv.png">
<meta property="article:published_time" content="2022-02-27T10:58:36.000Z">
<meta property="article:modified_time" content="2022-04-18T12:55:32.674Z">
<meta property="article:author" content="jjyaoao">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="思维过程">
<meta property="article:tag" content="实战代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/27/kLgRpw2FjGySiKv.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/01/09/le6jcmPKuJihDdU.jpg"><link rel="canonical" href="http://jjyaoao.space/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?06fb7a80772d98cbf9e7beeb76e262e4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JOZPQM4N5F","apiKey":"42451c032f2166ed9800520810e2d223","indexName":"jjyaoao-blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-18 20:55:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/01/09/le6jcmPKuJihDdU.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">88</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/02/27/kLgRpw2FjGySiKv.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">jjyaoao's Home</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-27T10:58:36.000Z" title="发表于 2022-02-27 18:58:36">2022-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-18T12:55:32.674Z" title="更新于 2022-04-18 20:55:32">2022-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/">DSA-05二叉树</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>以下笔记为jjyaoao本人制作，欢迎借鉴学习和提出相关建议，转载需要标明出处<a target="_blank" rel="noopener" href="http://www.jjyaoao.space/">www.jjyaoao.space</a></p>
</blockquote>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227190959555.png" alt="image-20220227190959555"></p>
<h2 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227191351981.png" alt="image-20220227191351981"></p>
<h2 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h2><p>凡是兄弟之间有明确次序的树，我们把它叫做有序树</p>
<p><u>任何一颗树中所含的边数 = 顶点数目-1 = 其中所有定点度数之和</u></p>
<p>这个结论之所以重要，是因为我们可以得到边数和顶点个数是同阶的</p>
<p>也就是说，如果一棵树的总体规模，如果可以度量为顶点数+边数，那么它从渐进的意义来讲，是与顶点个数同阶的，也就是我们后面评判一棵树的规模，可以以顶点的数目n作为参照</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227191606564.png" alt="image-20220227191606564"></p>
<h2 id="路径-环路"><a href="#路径-环路" class="headerlink" title="路径+环路"></a>路径+环路</h2><p>这里我们用边的数目来代表它的路径长度</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227192230822.png" alt="image-20220227192230822"></p>
<h2 id="连通-无环"><a href="#连通-无环" class="headerlink" title="连通+无环"></a>连通+无环</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227192652059.png" alt="image-20220227192652059"></p>
<h2 id="深度-层次"><a href="#深度-层次" class="headerlink" title="深度+层次"></a>深度+层次</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227193021833.png" alt="image-20220227193021833"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227193322474.png" alt="image-20220227193322474"></p>
<p><em>何时取等号？</em></p>
<p>当节点v是深度最大的叶节点或祖先节点时，取等号</p>
<h1 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h1><h2 id="ADT接口"><a href="#ADT接口" class="headerlink" title="ADT接口"></a>ADT接口</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227193655840.png" alt="image-20220227193655840"></p>
<h2 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227193759974.png" alt="image-20220227193759974"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227193901814.png" alt="image-20220227193901814"></p>
<h2 id="孩子节点"><a href="#孩子节点" class="headerlink" title="孩子节点"></a>孩子节点</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227194115628.png" alt="image-20220227194115628"></p>
<h2 id="父亲-孩子"><a href="#父亲-孩子" class="headerlink" title="父亲+孩子"></a>父亲+孩子</h2><p>整合了父亲  和   孩子的优点</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227194422283.png" alt="image-20220227194422283"></p>
<h2 id="长子-兄弟"><a href="#长子-兄弟" class="headerlink" title="长子+兄弟"></a>长子+兄弟</h2><p>反观父亲+孩子出现的问题</p>
<p>根源在于每一个节点的出度是不尽相同的</p>
<p>解决方案：<em>每一个节点均设两个引用</em></p>
<p>这种方式是  对树本质的<strong>深刻理解</strong></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227194730644.png" alt="image-20220227194730644"></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><strong>有根有序树</strong></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227195032678.png" alt="image-20220227195032678"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227195211681.png" alt="image-20220227195211681"></p>
<h2 id="真二叉树"><a href="#真二叉树" class="headerlink" title="真二叉树"></a>真二叉树</h2><p>如果某一棵树原先度数是0，那么我们为他引入两个节点，如果原先度数是1，那么我们为他引入一个节点。</p>
<ul>
<li>一方面从渐进的意义上讲，阶数相当</li>
<li>另一方面，当我们后续实现就能看出，这种添加完全是假象的，不需要实际的添加节点进入，只是方便理解，实现。</li>
<li>犹如虚拟实现，想象它背后的逻辑是对的，不需要实际的实现它</li>
</ul>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227195555277.png" alt="image-20220227195555277"></p>
<h2 id="描述多叉树"><a href="#描述多叉树" class="headerlink" title="描述多叉树"></a>描述多叉树</h2><p>表面上是不可能的，竟然用一个特例，来描述整个现象</p>
<p>这也解释了为何树会变成一个小的标题；：因为二叉树就可以代表树</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227200404015.png" alt="image-20220227200404015"></p>
<h2 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h2><h3 id="BinNode类"><a href="#BinNode类" class="headerlink" title="BinNode类"></a>BinNode类</h3><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227200736089.png" alt="image-20220227200736089"></p>
<h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227201159646.png" alt="image-20220227201159646"></p>
<h3 id="BinTree类"><a href="#BinTree类" class="headerlink" title="BinTree类"></a>BinTree类</h3><p>虚方法updateHeight是为了，后面庞大的衍生类能对这个方法进行适当的重写</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227201346494.png" alt="image-20220227201346494"></p>
<h3 id="高度更新"><a href="#高度更新" class="headerlink" title="高度更新"></a>高度更新</h3><p>未涉及到变种，仍采用常规定义</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227201850643.png" alt="image-20220227201850643"></p>
<h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><p>通过调用binNode类的同名接口insertAsrc() 传入参数e，意味着创建一个e的节点，并且让x指向这个接口所返回的那个地址交给x此前为空的右孩子引用，从而使得引用能指向新晋生成的节点</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227203021139.png" alt="image-20220227203021139"></p>
<h3 id="子树接入"><a href="#子树接入" class="headerlink" title="子树接入"></a>子树接入</h3><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227203139822.png" alt="image-20220227203139822"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//将S当作节点x的左子树接入二叉树，S本身置空</span></span><br><span class="line"><span class="number">0002</span> BinNodePosi&lt;T&gt; BinTree&lt;T&gt;::<span class="built_in">attach</span> ( BinTree&lt;T&gt;* &amp;S, BinNodePosi&lt;T&gt; x ) &#123; <span class="comment">//x-&gt;lc == NULL</span></span><br><span class="line"><span class="number">0003</span>    <span class="keyword">if</span> ( x-&gt;lc = S-&gt;_root ) x-&gt;lc-&gt;parent = x; <span class="comment">//接入</span></span><br><span class="line"><span class="number">0004</span>    _size += S-&gt;_size; <span class="built_in">updateHeightAbove</span> ( x ); <span class="comment">//更新全树规模与x所有祖先的高度</span></span><br><span class="line"><span class="number">0005</span>    S-&gt;_root = <span class="literal">NULL</span>; S-&gt;_size = <span class="number">0</span>; <span class="built_in">release</span> ( S ); S = <span class="literal">NULL</span>; <span class="keyword">return</span> x; <span class="comment">//释放原树，返回接入位置</span></span><br><span class="line"><span class="number">0006</span> &#125;</span><br><span class="line"><span class="number">0007</span> </span><br><span class="line"><span class="number">0008</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//将S当作节点x的右子树接入二叉树，S本身置空</span></span><br><span class="line"><span class="number">0009</span> BinNodePosi&lt;T&gt; BinTree&lt;T&gt;::<span class="built_in">attach</span> ( BinNodePosi&lt;T&gt; x, BinTree&lt;T&gt;* &amp;S ) &#123; <span class="comment">//x-&gt;rc == NULL</span></span><br><span class="line"><span class="number">0010</span>    <span class="keyword">if</span> ( x-&gt;rc = S-&gt;_root ) x-&gt;rc-&gt;parent = x; <span class="comment">//接入</span></span><br><span class="line"><span class="number">0011</span>    _size += S-&gt;_size; <span class="built_in">updateHeightAbove</span> ( x ); <span class="comment">//更新全树规模与x所有祖先的高度</span></span><br><span class="line"><span class="number">0012</span>    S-&gt;_root = <span class="literal">NULL</span>; S-&gt;_size = <span class="number">0</span>; <span class="built_in">release</span> ( S ); S = <span class="literal">NULL</span>; <span class="keyword">return</span> x; <span class="comment">//释放原树，返回接入位置</span></span><br><span class="line"><span class="number">0013</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="子树删除"><a href="#子树删除" class="headerlink" title="子树删除"></a>子树删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//删除二叉树中位置x处的节点及其后代，返回被删除节点的数值</span></span><br><span class="line"><span class="number">0002</span> <span class="keyword">int</span> BinTree&lt;T&gt;::<span class="built_in">remove</span> ( BinNodePosi&lt;T&gt; x ) &#123; <span class="comment">//assert: x为二叉树中的合法位置</span></span><br><span class="line"><span class="number">0003</span>    <span class="built_in">FromParentTo</span> ( *x ) = <span class="literal">NULL</span>; <span class="comment">//切断来自父节点的指针</span></span><br><span class="line"><span class="number">0004</span>    <span class="built_in">updateHeightAbove</span> ( x-&gt;parent ); <span class="comment">//更新祖先高度</span></span><br><span class="line"><span class="number">0005</span>    <span class="keyword">int</span> n = <span class="built_in">removeAt</span> ( x ); _size -= n; <span class="keyword">return</span> n; <span class="comment">//删除子树x，更新规模，返回删除节点总数</span></span><br><span class="line"><span class="number">0006</span> &#125;</span><br><span class="line"><span class="number">0007</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//删除二叉树中位置x处的节点及其后代，返回被删除节点的数值</span></span><br><span class="line"><span class="number">0008</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeAt</span> <span class="params">( BinNodePosi&lt;T&gt; x )</span> </span>&#123; <span class="comment">//assert: x为二叉树中的合法位置</span></span><br><span class="line"><span class="number">0009</span>    <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//递归基：空树</span></span><br><span class="line"><span class="number">0010</span>    <span class="keyword">int</span> n = <span class="number">1</span> + <span class="built_in">removeAt</span> ( x-&gt;lc ) + <span class="built_in">removeAt</span> ( x-&gt;rc ); <span class="comment">//递归释放左、右子树</span></span><br><span class="line"><span class="number">0011</span>    <span class="built_in">release</span> ( x-&gt;data ); <span class="built_in">release</span> ( x ); <span class="keyword">return</span> n; <span class="comment">//释放被摘除节点，并返回删除节点总数</span></span><br><span class="line"><span class="number">0012</span> &#125; <span class="comment">//release()负责释放复杂结构，与算法无直接关系，具体实现详见代码包</span></span><br></pre></td></tr></table></figure>

<h3 id="子树分离"><a href="#子树分离" class="headerlink" title="子树分离"></a>子树分离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//二叉树子树分离算法：将子树x从当前树中摘除，将其封装为一棵独立子树返回</span></span><br><span class="line"><span class="number">0002</span> BinTree&lt;T&gt;* BinTree&lt;T&gt;::<span class="built_in">secede</span> ( BinNodePosi&lt;T&gt; x ) &#123; <span class="comment">//assert: x为二叉树中的合法位置</span></span><br><span class="line"><span class="number">0003</span>    <span class="built_in">FromParentTo</span> ( *x ) = <span class="literal">NULL</span>; <span class="comment">//切断来自父节点的指针</span></span><br><span class="line"><span class="number">0004</span>    <span class="built_in">updateHeightAbove</span> ( x-&gt;parent ); <span class="comment">//更新原树中所有祖先的高度</span></span><br><span class="line"><span class="number">0005</span>    BinTree&lt;T&gt;* S = <span class="keyword">new</span> BinTree&lt;T&gt;; S-&gt;_root = x; x-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//新树以x为根</span></span><br><span class="line"><span class="number">0006</span>    S-&gt;_size = x-&gt;<span class="built_in">size</span>(); _size -= S-&gt;_size; <span class="keyword">return</span> S; <span class="comment">//更新规模，返回分离出来的子树</span></span><br><span class="line"><span class="number">0007</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227203444357.png" alt="image-20220227203444357"></p>
<p>递归—-》迭代是很有必要的，递归的过程只具有渐进意义的O(n)，因为它每一步所装的箱子都是一样的大小，我们完全可以根据实际情况，来把他箱子改小，这在实际应用具有巨大的意义，虽然只是常数的提升！</p>
<p>先中后都属于<strong>深度搜索</strong></p>
<p><strong>VST貌似是指针函数的引用</strong></p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><strong>visit</strong>里面则放你需要做的事情（取来干嘛）</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227203724142.png" alt="image-20220227203724142"></p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>为此，我们只需引入栈</p>
<h5 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h5><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204013897.png" alt="image-20220227204013897"></p>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204309966.png" alt="image-20220227204309966"></p>
<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p><strong>染黑来代表这个节点接受访问</strong></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204410029.png" alt="image-20220227204410029"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204521557.png" alt="image-20220227204521557"></p>
<h5 id="迭代版2"><a href="#迭代版2" class="headerlink" title="迭代版2"></a>迭代版2</h5><p>为了推广到后面的中序，后序算法</p>
<h6 id="新思路"><a href="#新思路" class="headerlink" title="新思路"></a>新思路</h6><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204631651.png" alt="image-20220227204631651"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204742910.png" alt="image-20220227204742910"></p>
<h6 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h6><p><strong>最好熟读，并且背下来！</strong></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204924207.png" alt="image-20220227204924207"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227205241760.png" alt="image-20220227205241760"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问</span></span><br><span class="line"><span class="number">0002</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="number">0003</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongVine</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    BinNodePosi&lt;T&gt; x, </span></span></span><br><span class="line"><span class="params"><span class="function">    VST&amp; visit, </span></span></span><br><span class="line"><span class="params"><span class="function">    Stack&lt;BinNodePosi&lt;T&gt;&gt;&amp; S )</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//这里的visitAlongVine就是上面那张图的....leftbrach</span></span><br><span class="line"><span class="number">0004</span>    <span class="keyword">while</span> ( x ) &#123;</span><br><span class="line"><span class="number">0005</span>       <span class="built_in">visit</span> ( x-&gt;data ); <span class="comment">//访问当前节点</span></span><br><span class="line"><span class="number">0006</span>       S.<span class="built_in">push</span> ( x-&gt;rc ); <span class="comment">//右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈）</span></span><br><span class="line"><span class="number">0007</span>       x = x-&gt;lc;  <span class="comment">//沿左分支深入一层</span></span><br><span class="line"><span class="number">0008</span>    &#125;</span><br><span class="line"><span class="number">0009</span> &#125;</span><br><span class="line"><span class="number">0010</span> </span><br><span class="line"><span class="number">0011</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="number">0012</span> <span class="function"><span class="keyword">void</span> <span class="title">travPre_I2</span> <span class="params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#2）</span></span><br><span class="line"><span class="number">0013</span>    Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="number">0014</span>    <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line"><span class="number">0015</span>       <span class="built_in">visitAlongVine</span> ( x, visit, S ); <span class="comment">//从当前节点出发，逐批访问</span></span><br><span class="line"><span class="number">0016</span>       <span class="keyword">if</span> ( S.<span class="built_in">empty</span>() ) <span class="keyword">break</span>; <span class="comment">//直到栈空</span></span><br><span class="line"><span class="number">0017</span>       x = S.<span class="built_in">pop</span>(); <span class="comment">//弹出下一批的起点</span></span><br><span class="line"><span class="number">0018</span>    &#125;</span><br><span class="line"><span class="number">0019</span> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227205258504.png" alt="image-20220227205258504"></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227205401863.png" alt="image-20220227205401863"></p>
<p>改写迭代难度比先序要大，因为它并不是全是尾递归！！！</p>
<h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227205513370.png" alt="image-20220227205513370"></p>
<h4 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227205808403.png" alt="image-20220227205808403"></p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227205928756.png" alt="image-20220227205928756"></p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>与先序遍历的区别——-visit –&gt; go（vine）</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227210525111.png" alt="image-20220227210525111"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点</span></span><br><span class="line"><span class="number">0002</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongVine</span> <span class="params">( BinNodePosi&lt;T&gt; x, Stack&lt;BinNodePosi&lt;T&gt;&gt;&amp; S )</span> </span>&#123;</span><br><span class="line"><span class="number">0003</span>    <span class="keyword">while</span> ( x ) &#123; S.<span class="built_in">push</span> ( x ); x = x-&gt;lc; &#125; <span class="comment">//当前节点入栈后随即向左侧分支深入，迭代直到无左孩子</span></span><br><span class="line"><span class="number">0004</span> &#125;</span><br><span class="line"><span class="number">0005</span> </span><br><span class="line"><span class="number">0006</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="number">0007</span> <span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span> <span class="params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#1）</span></span><br><span class="line"><span class="number">0008</span>    Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="number">0009</span>    <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line"><span class="number">0010</span>       <span class="built_in">goAlongVine</span> ( x, S ); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line"><span class="number">0011</span>       <span class="keyword">if</span> ( S.<span class="built_in">empty</span>() ) <span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line"><span class="number">0012</span>       x = S.<span class="built_in">pop</span>(); <span class="built_in">visit</span> ( x-&gt;data ); <span class="comment">//弹出栈顶节点并访问之</span></span><br><span class="line"><span class="number">0013</span>       x = x-&gt;rc; <span class="comment">//转向右子树</span></span><br><span class="line"><span class="number">0014</span>    &#125;</span><br><span class="line"><span class="number">0015</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227210602115.png" alt="image-20220227210602115"></p>
<h4 id="分摊分析"><a href="#分摊分析" class="headerlink" title="分摊分析"></a>分摊分析</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227210908305.png" alt="image-20220227210908305"></p>
<p>难道我们的结论是总体需要n²的时间吗？？？</p>
<p>整个算法的确呈现迭代，而且每一步的goalongleftbranch或长或短，甚至有可能有达到Ω（n）的量级</p>
<p>​    不过我们不难发现，所有左侧链的长度加起来，也只是n 因此，我们刚才所得到的n²的结果只是一个假象</p>
<p>​    而我们得到n²的结论只是将估计量括起来当成一个方框，而累计的复杂度则是方框的面积</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227211211051.png" alt="image-20220227211211051"></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227211455758.png" alt="image-20220227211455758"></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227211629424.png" alt="image-20220227211629424"></p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227211717915.png" alt="image-20220227211717915"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227211832376.png" alt="image-20220227211832376"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在以S栈顶节点为根的子树中，找到最高左侧可见叶节点</span></span><br><span class="line"><span class="number">0002</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gotoLeftmostLeaf</span> <span class="params">( Stack&lt;BinNodePosi&lt;T&gt;&gt;&amp; S )</span> </span>&#123; <span class="comment">//沿途所遇节点依次入栈</span></span><br><span class="line"><span class="number">0003</span>    <span class="keyword">while</span> ( BinNodePosi&lt;T&gt; x = S.<span class="built_in">top</span>() ) <span class="comment">//自顶而下，反复检查当前节点（即栈顶）</span></span><br><span class="line"><span class="number">0004</span>       <span class="keyword">if</span> ( <span class="built_in">HasLChild</span> ( *x ) ) &#123; <span class="comment">//尽可能向左</span></span><br><span class="line"><span class="number">0005</span>          <span class="keyword">if</span> ( <span class="built_in">HasRChild</span> ( *x ) ) S.<span class="built_in">push</span> ( x-&gt;rc ); <span class="comment">//若有右孩子，优先入栈</span></span><br><span class="line"><span class="number">0006</span>          S.<span class="built_in">push</span> ( x-&gt;lc ); <span class="comment">//然后才转至左孩子</span></span><br><span class="line"><span class="number">0007</span>       &#125; <span class="keyword">else</span> <span class="comment">//实不得已</span></span><br><span class="line"><span class="number">0008</span>          S.<span class="built_in">push</span> ( x-&gt;rc ); <span class="comment">//才向右</span></span><br><span class="line"><span class="number">0009</span>    S.<span class="built_in">pop</span>(); <span class="comment">//返回之前，弹出栈顶的空节点</span></span><br><span class="line"><span class="number">0010</span> &#125;</span><br><span class="line"><span class="number">0011</span> </span><br><span class="line"><span class="number">0012</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="number">0013</span> <span class="function"><span class="keyword">void</span> <span class="title">travPost_I</span> <span class="params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树的后序遍历（迭代版）</span></span><br><span class="line"><span class="number">0014</span>    Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="number">0015</span>    <span class="keyword">if</span> ( x ) S.<span class="built_in">push</span> ( x ); <span class="comment">//根节点入栈</span></span><br><span class="line"><span class="number">0016</span>    <span class="keyword">while</span> ( !S.<span class="built_in">empty</span>() ) &#123; <span class="comment">//x始终为当前节点</span></span><br><span class="line"><span class="number">0017</span>       <span class="keyword">if</span> ( S.<span class="built_in">top</span>() != x-&gt;parent ) <span class="comment">////若栈顶非x之父（而为右兄）</span></span><br><span class="line"><span class="number">0018</span>          <span class="built_in">gotoLeftmostLeaf</span> ( S ); <span class="comment">//则在其右兄子树中找到HLVFL（相当于递归深入）</span></span><br><span class="line"><span class="number">0019</span>       x = S.<span class="built_in">pop</span>(); <span class="built_in">visit</span> ( x-&gt;data ); <span class="comment">//弹出栈顶（即前一节点之后继），并访问之</span></span><br><span class="line"><span class="number">0020</span>    &#125;</span><br><span class="line"><span class="number">0021</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="表达式树-RPN"><a href="#表达式树-RPN" class="headerlink" title="表达式树(RPN)"></a>表达式树(RPN)</h4><p>盯住<strong>红色</strong>部分</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227212132025.png" alt="image-20220227212132025"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227212124292.png" alt="image-20220227212124292"></p>
<p>仔细观察，这就是一个后序遍历</p>
<p>也可以理解为不断求值的过程</p>
<p>所以说RPN是不需要括号的，与其说是不需要，不如说是背后隐藏了一棵树在里面</p>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>可以看到层次遍历的接口形式和其他遍历完全一致</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228104402805.png" alt="image-20220228104402805"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="number">0002</span> <span class="keyword">void</span> BinNode&lt;T&gt;::<span class="built_in">travLevel</span> ( VST&amp; visit ) &#123; <span class="comment">//二叉树层次遍历算法</span></span><br><span class="line"><span class="number">0003</span>    Queue&lt;BinNodePosi&lt;T&gt;&gt; Q; <span class="comment">//辅助队列</span></span><br><span class="line"><span class="number">0004</span>    Q.<span class="built_in">enqueue</span> ( <span class="keyword">this</span> ); <span class="comment">//根节点入队</span></span><br><span class="line"><span class="number">0005</span>    <span class="keyword">while</span> ( !Q.<span class="built_in">empty</span>() ) &#123; <span class="comment">//在队列再次变空之前，反复迭代</span></span><br><span class="line"><span class="number">0006</span>       BinNodePosi&lt;T&gt; x = Q.<span class="built_in">dequeue</span>(); <span class="built_in">visit</span> ( x-&gt;data ); <span class="comment">//取出队首节点并访问之</span></span><br><span class="line"><span class="number">0007</span>       <span class="keyword">if</span> ( <span class="built_in">HasLChild</span> ( *x ) ) Q.<span class="built_in">enqueue</span> ( x-&gt;lc ); <span class="comment">//左孩子入队</span></span><br><span class="line"><span class="number">0008</span>       <span class="keyword">if</span> ( <span class="built_in">HasRChild</span> ( *x ) ) Q.<span class="built_in">enqueue</span> ( x-&gt;rc ); <span class="comment">//右孩子入队</span></span><br><span class="line"><span class="number">0009</span>    &#125;</span><br><span class="line"><span class="number">0010</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>节点进入后，左顾右盼，先左顾后右判        这里使用的是队列   和之前先序遍历使用的栈不同，先序遍历就是先右后左</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228104622270.png" alt="image-20220228104622270"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228104829062.png" alt="image-20220228104829062"></p>
<h2 id="遍历序列"><a href="#遍历序列" class="headerlink" title="遍历序列"></a>遍历序列</h2><p>我们可以知道，任何一棵树都能有三种遍历序列，</p>
<p>那现在我们试想一下，如果我们知道某棵树的遍历序列是否我们能够还原成那一棵树的初始状态，如果可以，那我们使用什么方法？</p>
<h3 id="先序-后序-中序"><a href="#先序-后序-中序" class="headerlink" title="先序|后序+中序"></a>先序|后序+中序</h3><p>首先通过 先/后 序遍历序列知道了根</p>
<p>再通过中序遍历，我们就可以很容易的将左右子树拆分开</p>
<p>为何我们不能通过先/后序列来确定整棵树的位置？</p>
<p>当右子树是空的的时候。我们得到的数据是这样的。</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228105656140.png" alt="image-20220228105656140"></p>
<p>当左子树是空的，我们得到的图是这样的</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228105749570.png" alt="image-20220228105749570"></p>
<p>可以看到，这里出现了歧义——&gt;</p>
<p>也就是，我们无法确定，到底真正的图是缺少了左子树还是右子树</p>
<h3 id="先序-后续-真"><a href="#先序-后续-真" class="headerlink" title="(先序+后续)*真"></a>(先序+后续)*真</h3><p>既然是真二叉树，那么它一定会有左子树和右子树，也就是说，我们先序遍历的第二个位置一定是左子树节点，后序遍历倒数第二个位置一定是右子树节点，我们从而可以快速，相互的定位他们在不同遍历中的位置。</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228110415453.png" alt="image-20220228110415453"></p>
<p>在这里，确实可以进行<strong>分而治之</strong>，从而通过递归的形式，完全可以重现出二叉树完整的结构</p>
<h3 id="知道序列画树"><a href="#知道序列画树" class="headerlink" title="知道序列画树"></a>知道序列画树</h3><p>​        我们通过观察，可知：</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220227204631651.png" alt="image-20220227204631651"></p>
<p>​        先序遍历的顺序，即为子树向左下方画出一条一条的线，同理可得，后序遍历的访问次序，是<strong>向着左上的箭头</strong>，而中序遍历是从左往右的结点顺序，因此，可得如下思路：<img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/tree.png" alt="tree"></p>
<p>我们可以得到，他的顺序</p>
<ul>
<li>先序A B D E C F</li>
<li>中序D B E A C F</li>
<li>后序D E B F C A</li>
</ul>
<p>观察，因为能构建出树，必有中序，所以通过中序和先(后)序得到的根节点，画出基础树，这里，我们用后序+中序来举例</p>
<p>​          A                                                不知道已经发现了吗，中序中，我们先不考虑根结点，可以发现，我们这里采用的遍历是按照左上</p>
<p>D B E    C F                    一列一列划线，意味着我们只需要默想后序的顺序，然后看着左边的基础树，脑海中一直想象着划线，如果与脑海中的相违背，就断一下，逐渐就会画好了hhhh，只是突然想到了，记忆下来图一乐，不知道会不会用到哟，估计到时候都忘了<img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/tree1.png" alt="tree1">                    </p>
<h1 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h1><h2 id="PFC编码"><a href="#PFC编码" class="headerlink" title="PFC编码"></a>PFC编码</h2><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228110530053.png" alt="image-20220228110530053"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228110854380.png" alt="image-20220228110854380"></p>
<h3 id="编码成本"><a href="#编码成本" class="headerlink" title="编码成本"></a>编码成本</h3><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228111104371.png" alt="image-20220228111104371"></p>
<p>其实优化的过程就是把M节点和那个蓝色节点交换，则得到了较优的结果</p>
<p>那么，为什么我们能赚到呢？</p>
<p>是因为我们出现了高度差为2的’’叶子’’节点，3，4更不用说，但这也必然会赚到，因为更多的点深度低了，（相比于深度高了的少量节点）以多博少</p>
<h3 id="频度"><a href="#频度" class="headerlink" title="频度"></a>频度</h3><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228111635194.png" alt="image-20220228111635194"></p>
<h3 id="带权编码成本"><a href="#带权编码成本" class="headerlink" title="带权编码成本"></a>带权编码成本</h3><p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228111854006.png" alt="image-20220228111854006"></p>
<p>四平八稳的方式不一定是最好的了……</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228112036346.png" alt="image-20220228112036346"></p>
<p>高高  低低，一定是赚的</p>
<h3 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h3><p>我要构建出理想的树，有两个考虑方式，历史只记住的成功的一个，但我们作为学习，也需要考虑失败的那个，从高处开始挂下去，从低处往高树挂</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228112328510.png" alt="image-20220228112328510"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228112347632.png" alt="image-20220228112347632"></p>
<h2 id="构造编码树"><a href="#构造编码树" class="headerlink" title="构造编码树"></a>构造编码树</h2><p>使用先中后随便一种遍历方式，都可以得到他们的次序（DFS)</p>
<p>访问到以后，会记录绳子，我们把他从底端打印到顶端（栈未完全封装）</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228112450337.png" alt="image-20220228112450337"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228112501063.png" alt="image-20220228112501063"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228112513027.png" alt="image-20220228112513027"></p>
<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>从第一个bit开始，最开始位置到根，如果是0就往左，1就往右，找到了叶子，就把叶子的那个字符pop（）打印出来，然后自己reset（）回到根，随着不断迭代，终止到最后一个叶子，从而完成了解码的工作</p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228113234676.png" alt="image-20220228113234676"></p>
<p><img src="/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220228113305640.png" alt="image-20220228113305640"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:jjyaoao@126.com">jjyaoao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jjyaoao.space/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/">http://jjyaoao.space/2022/02/27/DSA-05%E4%BA%8C%E5%8F%89%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jjyaoao.space" target="_blank">jjyaoao's Home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%80%9D%E7%BB%B4%E8%BF%87%E7%A8%8B/">思维过程</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81/">实战代码</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-61dbf69078ce19aa" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/01/09/HMjygFAKr2nPWdJ.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/01/09/HMjygFAKr2nPWdJ.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/01/09/JL43sbhxUEOuVeM.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/01/09/JL43sbhxUEOuVeM.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/28/DSA-06%E5%9B%BE/"><img class="prev-cover" src="https://s2.loli.net/2022/02/28/pNiqLMVWYg3bjDT.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/27/DSA-04%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"><img class="next-cover" src="https://s2.loli.net/2022/02/27/DkHVYhA8ajxUglo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">栈与队列</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/26/DSA-01%E5%BA%8F%E7%AB%A0/" title="序章"><img class="cover" src="https://s2.loli.net/2022/02/26/Xx9n2IU5fhKa1GN.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">序章</div></div></a></div><div><a href="/2022/02/26/DSA-03%E5%88%97%E8%A1%A8/" title="列表"><img class="cover" src="https://s2.loli.net/2022/03/05/Zuh5ICpjBMno2NW.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">列表</div></div></a></div><div><a href="/2022/02/26/DSA-02%E5%90%91%E9%87%8F/" title="向量"><img class="cover" src="https://s2.loli.net/2022/03/05/KiD5c4Qw1fgrM8u.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">向量</div></div></a></div><div><a href="/2022/02/27/DSA-04%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" title="栈与队列"><img class="cover" src="https://s2.loli.net/2022/02/27/DkHVYhA8ajxUglo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-27</div><div class="title">栈与队列</div></div></a></div><div><a href="/2022/03/06/DSA-09%E8%AF%8D%E5%85%B8/" title="词典"><img class="cover" src="https://s2.loli.net/2022/03/06/FKE7IBwksCfNQj3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-06</div><div class="title">词典</div></div></a></div><div><a href="/2022/02/28/DSA-06%E5%9B%BE/" title="图"><img class="cover" src="https://s2.loli.net/2022/02/28/pNiqLMVWYg3bjDT.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-28</div><div class="title">图</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTM1OC8zMTgyNQ=="></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%A0%B9%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">有根树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">有序树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84-%E7%8E%AF%E8%B7%AF"><span class="toc-number">1.4.</span> <span class="toc-text">路径+环路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A-%E6%97%A0%E7%8E%AF"><span class="toc-number">1.5.</span> <span class="toc-text">连通+无环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6-%E5%B1%82%E6%AC%A1"><span class="toc-number">1.6.</span> <span class="toc-text">深度+层次</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">树的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ADT%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">ADT接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">父节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">孩子节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E4%BA%B2-%E5%AD%A9%E5%AD%90"><span class="toc-number">2.4.</span> <span class="toc-text">父亲+孩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E5%AD%90-%E5%85%84%E5%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">长子+兄弟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">真二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">描述多叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">二叉树实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BinNode%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">BinNode类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">接口实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BinTree%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">BinTree类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E6%9B%B4%E6%96%B0"><span class="toc-number">3.3.3.</span> <span class="toc-text">高度更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5"><span class="toc-number">3.3.4.</span> <span class="toc-text">节点插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%A0%91%E6%8E%A5%E5%85%A5"><span class="toc-number">3.3.5.</span> <span class="toc-text">子树接入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%A0%91%E5%88%A0%E9%99%A4"><span class="toc-number">3.3.6.</span> <span class="toc-text">子树删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%A0%91%E5%88%86%E7%A6%BB"><span class="toc-number">3.3.7.</span> <span class="toc-text">子树分离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">先序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC1"><span class="toc-number">3.4.1.2.1.</span> <span class="toc-text">版本1</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">3.4.1.2.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.2.1.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.4.1.2.1.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E7%89%882"><span class="toc-number">3.4.1.2.2.</span> <span class="toc-text">迭代版2</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">3.4.1.2.2.1.</span> <span class="toc-text">新思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.4.1.2.2.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">3.4.1.2.2.3.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">难点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">观察</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90"><span class="toc-number">3.4.2.7.</span> <span class="toc-text">分摊分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.3.</span> <span class="toc-text">后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-RPN"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">表达式树(RPN)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.4.</span> <span class="toc-text">层次遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">3.5.</span> <span class="toc-text">遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F-%E5%90%8E%E5%BA%8F-%E4%B8%AD%E5%BA%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">先序|后序+中序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F-%E5%90%8E%E7%BB%AD-%E7%9C%9F"><span class="toc-number">3.5.2.</span> <span class="toc-text">(先序+后续)*真</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E5%BA%8F%E5%88%97%E7%94%BB%E6%A0%91"><span class="toc-number">3.5.3.</span> <span class="toc-text">知道序列画树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Huffman%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">Huffman树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PFC%E7%BC%96%E7%A0%81"><span class="toc-number">4.1.</span> <span class="toc-text">PFC编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E6%88%90%E6%9C%AC"><span class="toc-number">4.1.1.</span> <span class="toc-text">编码成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E5%BA%A6"><span class="toc-number">4.1.2.</span> <span class="toc-text">频度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E7%BC%96%E7%A0%81%E6%88%90%E6%9C%AC"><span class="toc-number">4.1.3.</span> <span class="toc-text">带权编码成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.4.</span> <span class="toc-text">编码算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%BC%96%E7%A0%81%E6%A0%91"><span class="toc-number">4.2.</span> <span class="toc-text">构造编码树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">解码</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/02/27/kLgRpw2FjGySiKv.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By jjyaoao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'cFvw1zyA64uttBS5jbYY7pwH-gzGzoHsz',
      appKey: '14rOjAUNzRyJSQt983q6gdza',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Livere' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善,感谢" data-fontsize="15px" data-random="false" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = 'zgYNWkNCSATLRhpg4';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>